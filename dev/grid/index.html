<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>grids · PorousMaterials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PorousMaterials.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PorousMaterials</a></li><li><a class="tocitem" href="../paths/">paths</a></li><li><a class="tocitem" href="../matter/">matter</a></li><li><a class="tocitem" href="../box/">boxes</a></li><li><a class="tocitem" href="../crystal/">crystals</a></li><li><a class="tocitem" href="../molecule/">molecules</a></li><li><a class="tocitem" href="../distance/">computing distances</a></li><li><a class="tocitem" href="../force_field/">forcefields</a></li><li><a class="tocitem" href="../eos/">equations of state</a></li><li><a class="tocitem" href="../henry/">Henry coefficients</a></li><li><a class="tocitem" href="../gcmc/">grand-canonical Monte Carlo simulations</a></li><li><a class="tocitem" href="../energy_min/">energy minimum</a></li><li class="is-active"><a class="tocitem" href>grids</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#detailed-docs"><span>detailed docs</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/master/docs/src/grid.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Potential-Energy-Grid"><a class="docs-heading-anchor" href="#Potential-Energy-Grid">Potential Energy Grid</a><a id="Potential-Energy-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Potential-Energy-Grid" title="Permalink"></a></h1><p><code>PorousMaterials.jl</code> allows us to calculate and store the ensemble average potential energy of a molecule inside a crystal. This is done by using the molecule as a probe to measure the potential energy on a grid of points superimposed on the unit cell of the crystal.</p><h3 id="Calculating-Potential-Energy-Grids"><a class="docs-heading-anchor" href="#Calculating-Potential-Energy-Grids">Calculating Potential Energy Grids</a><a id="Calculating-Potential-Energy-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Potential-Energy-Grids" title="Permalink"></a></h3><p>Superimpose a grid of points about the unit cell of SBMOF-1, compute the potential energy of xenon at each point, and store the data in a <a href="#PorousMaterials.Grid"><code>Grid</code></a> object using <a href="#PorousMaterials.energy_grid"><code>energy_grid</code></a>.</p><pre><code class="language-julia">xtal = Crystal(&quot;SBMOF-1.cif&quot;)
strip_numbers_from_atom_labels!(xtal)
molecule = Molecule(&quot;Xe&quot;)
ljforcefield = LJForceField(&quot;UFF&quot;)
grid = energy_grid(xtal, molecule, ljforcefield, 
                   resolution=0.5, units=:kJ_mol) 
# output
Computing energy grid of Xe in SBMOF-1.cif
	Regular grid (in fractional space) of 25 by 13 by 47 points superimposed over the unit cell.
Regular grid of 25 by 13 by 47 points superimposed over a unit cell and associated data.
	units of data attribute: kJ_mol
	origin: [0.000000, 0.000000, 0.000000]</code></pre><p>The <a href="#PorousMaterials.Grid"><code>Grid</code></a> object has the following attributes:</p><pre><code class="language-julia">grid.box      # Bravais lattice over which a grid of points is superimposed
grid.data     # 3 dim array containing data for each point
grid.n_pts    # number of grid points in x, y, z
grid.origin   # the origin of the grid
grid.units    # units associated with each data point</code></pre><h3 id="Saving-and-Retrieving-Grids"><a class="docs-heading-anchor" href="#Saving-and-Retrieving-Grids">Saving and Retrieving Grids</a><a id="Saving-and-Retrieving-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-Retrieving-Grids" title="Permalink"></a></h3><p>Write to a <code>.cube</code> volume file to visualize the potential energy contours. The output file location is determined by <code>rc[:paths][:grids]</code>.</p><pre><code class="language-julia">write_cube(grid, &quot;CH4_in_SBMOF1.cube&quot;)</code></pre><p>Likewise, we can read a <code>.cube</code> file to populate a <code>Grid</code> object:</p><pre><code class="language-julia">filename = joinpath(rc[:paths][:grids], &quot;CH4_in_SBMOF1.cube&quot;)
grid = read_cube(filename)</code></pre><h1 id="detailed-docs"><a class="docs-heading-anchor" href="#detailed-docs">detailed docs</a><a id="detailed-docs-1"></a><a class="docs-heading-anchor-permalink" href="#detailed-docs" title="Permalink"></a></h1><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.Grid" href="#PorousMaterials.Grid"><code>PorousMaterials.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (<code>Box</code>). Each grid point has data, <code>data</code>, associated with it, of type <code>T</code>, stored in a 3D array.</p><p><strong>Attributes</strong></p><ul><li><code>box::Box</code>: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.</li><li><code>n_pts::Tuple{Int, Int, Int}</code>: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.</li><li><code>data::Array{T, 3}</code>: three dimensional array conaining data associated with each grid point.</li><li><code>units::Symbol</code>: the units associated with each data point.</li><li><code>origin::Array{Float64, 1}</code>: the origin of the grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.energy_grid" href="#PorousMaterials.energy_grid"><code>PorousMaterials.energy_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid = energy_grid(crystal, molecule, ljforcefield; resolution=1.0, temperature=298.0, n_rotations=750)</code></pre><p>Superimposes a regular grid of points (regularly spaced in fractional coordinates of the <code>crystal.box</code>) over the unit cell of a crystal, with <code>n_gridpts</code> dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.</p><p>The ensemble average is a Boltzmann average over rotations:  - R T log ⟨e⁻ᵇᵁ⟩</p><p><strong>Arguments</strong></p><ul><li><code>crystal::Crystal</code>: crystal in which we seek to compute an energy grid for a molecule. <code>grid.box</code> will be <code>framework.box</code>.</li><li><code>molecule::Molecule</code>: molecule for which we seek an energy grid</li><li><code>ljforcefield::LJForceField</code>: molecular model for computing molecule-crystal interactions</li><li><code>resolution::Union{Float64, Tuple{Int, Int, Int}}=1.0</code>: maximum distance between grid points, in Å, or a tuple specifying the number of grid points in each dimension.</li><li><code>n_rotations::Int</code>: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.</li></ul><p>This is only relevant for molecules that are comprised of more than one Lennard Jones sphere.</p><ul><li><code>temperature::Float64</code>: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.</li><li><code>units::Symbol</code>: either <code>:K</code> or <code>:kJ_mol</code>, the units in which the energy should be stored in the returned <code>Grid</code>.</li><li><code>center::Bool</code>: shift coords of grid so that the origin is the center of the unit cell <code>crystal.box</code>.</li><li><code>verbose::Bool=true</code>: print some information.</li></ul><p><strong>Returns</strong></p><ul><li><code>grid::Grid</code>: A grid data structure containing the potential energy of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L253-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.write_cube" href="#PorousMaterials.write_cube"><code>PorousMaterials.write_cube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_cube(grid, filename, verbose=true)</code></pre><p>Write grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Grid</code>: grid with associated data at each grid point.</li><li><code>filename::AbstractString</code>: name of .cube file to which we write the grid; this is relative to <code>rc[:paths][:grids]</code>.</li><li><code>verbose::Bool</code>: print name of file after writing.</li><li><code>length_units::String</code>: units for length. Bohr or Angstrom.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L126-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.read_cube" href="#PorousMaterials.read_cube"><code>PorousMaterials.read_cube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid = read_cube(filename)</code></pre><p>Read a .cube file and return a populated <code>Grid</code> data structure.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: name of .cube file to which we write the grid; this is relative to <code>rc[:paths][:grids]</code></li></ul><p><strong>Returns</strong></p><ul><li><code>grid::Grid</code>: A grid data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L186-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.required_n_pts" href="#PorousMaterials.required_n_pts"><code>PorousMaterials.required_n_pts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">n_pts = required_n_pts(box, dx)</code></pre><p>Calculate the required number of grid pts in a, b, c unit cell directions required to keep distances between grid points less than <code>dx</code> apart, where <code>dx</code> is in units of Angstrom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.xf_to_id" href="#PorousMaterials.xf_to_id"><code>PorousMaterials.xf_to_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">voxel_id = xf_to_id(n_pts, xf)</code></pre><p>Returns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of <code>n_pts[1]</code> by <code>n_pts[2]</code> by <code>n_pts[3]</code> voxels. Periodic boundary conditions are applied.</p><p><strong>Arguments</strong></p><ul><li><code>n_pts::Tuple{Int, Int, Int}</code>: The number of points for each axis in the <code>Grid</code></li><li><code>xf::Array{Float64, 1}</code>: The fractional coordinates to be converted to an id</li></ul><p><strong>Returns</strong></p><ul><li><code>id::Array{Int, 1}</code>: The array indices for storing this point in space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L21-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.id_to_xf" href="#PorousMaterials.id_to_xf"><code>PorousMaterials.id_to_xf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xf = id_to_xf(voxel_id, n_pts)</code></pre><p>Given a <code>voxel_id</code> in a <code>Grid</code>, return the fractional coordinates to which this voxel corresponds.</p><p><strong>Arguments</strong></p><ul><li><code>n_pts::Tuple{Int, Int, Int}</code>: The number of voxels along each axis in the <code>Grid</code></li><li><code>voxel_id::Array{Int, 1}</code>: the voxel coordinates in <code>grid.data</code></li></ul><p><strong>Returns</strong></p><ul><li><code>xf::Array{Float64, 1}</code>: The fractional coordinates corresponding to the grid voxel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.update_density!" href="#PorousMaterials.update_density!"><code>PorousMaterials.update_density!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_density!(grid, molecule, species)</code></pre><p>updates the density grid based on an array of molecules. If a molecule doesn&#39;t match the specified species it won&#39;t be added to the density grid. This function doesn&#39;t calculate the actual densities, it will need a <code>./ = num_snapshots</code> at the end of the GCMC simulation.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Grid</code>: the grid to be updated</li><li><code>molecules::Array{Molecule, 1}</code>: An array of molecules whose positions will  be added to the grid</li><li><code>species::Symbol</code>: The species of atom that can be added to this density grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.compute_accessibility_grid" href="#PorousMaterials.compute_accessibility_grid"><code>PorousMaterials.compute_accessibility_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accessibility_grid, nb_segments_blocked, porosity = compute_accessibility_grid(crystal,
probe_molecule, ljforcefield; resolution::Union{Float64, Tuple{Int, Int, Int}}=1.0, energy_tol=10.0, energy_unit=:kJ_mol,
verbose=true, write_b4_after_grids=false, block_inaccessible_pockets=true)</code></pre><p>Overlay a grid of points about the unit cell. Compute the potential energy of a probe molecule at each point. If the potential energy is less than <code>energy_tol</code>, the grid point is declared as accessible to an adsorbate; otherwise inaccessible.</p><p>If <code>block_pockets</code> is true: Then perform a flood fill algorithm to label disparate (unconnected) segments in the grid.</p><p>Then build a graph whose vertices are the unconnected segments in the flood-filled grid and whose edges are the connections between the segments across the periodic boundary.</p><p>Then find any simple cycles in the grid. Any vertex that is involved in a simple cycle is considered accessible since a molecule can travel from that segment in the home unit cell to the same segment but in a different unit cell. If any vertex is not involved in a cycle, the segment is declared as inaccessible and all grid points in this segment are re-labeled as inaccessible.</p><p>Returns <code>accessibility_grid::Grid{Bool}</code> and <code>nb_segments_blocked</code>, the latter the number of segments that were blocked because they were determined to be inaccessible.</p><p><strong>Arguments</strong></p><ul><li><code>crystal::Crystal</code>: the crystal for which we seek to compute an accessibility grid.</li><li><code>probe_molecule::Molecule</code> a molecule serving as a probe to determine whether a given</li></ul><p>point can be occupied and accessed.</p><ul><li><code>LJForceField::LJForceField</code>: the force field used to compute the potential energy of</li></ul><p>the probe molecule</p><ul><li><ul><li><code>resolution::Union{Float64, Tuple{Int, Int, Int}}=1.0</code>: maximum distance between grid points, in Å, or a tuple specifying the number of grid points in each dimension.</li></ul></li><li><code>energy_tol::Float64</code>: if the computed potential energy is less than this, we declare the</li></ul><p>grid point to be occupiable. Also this is the energy barrier beyond which we assume the probe adsorbate cannot pass. Units given by <code>energy_units</code> argument</p><ul><li><code>energy_units::Symbol</code>: units of energy (<code>:kJ_mol</code> or <code>:K</code>) to be used in determining</li></ul><p>threshold for occupiability and whether molecule can percolate over barrier in channel. (see <code>energy_tol</code>)</p><ul><li><code>write_b4_after_grids::Bool</code>: write a .cube file of occupiability for visualization both</li></ul><p>before and after flood fill/blocking inaccessible pockets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L635-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.accessible" href="#PorousMaterials.accessible"><code>PorousMaterials.accessible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accessible(accessibility_grid, xf)
accessible(accessibility_grid, xf, repfactors)</code></pre><p>Using <code>accessibility_grid</code>, determine if fractional coordinate <code>xf</code> (relative to <code>accessibility_grid.box</code> is accessible or not. Here, we search for the nearest grid point. We then look at the accessibility of this nearest grid point and all surroudning 9 other grid points. The point <code>xf</code> is declared inaccessible if and only if all 10 of these grid points are inaccessible. We take this approach because, if the grid is coarse, we can allow energy computations to automatically determine accessibility at the boundary of accessibility e.g. during a molecular simulation where inaccessible pockets are blocked.</p><p>If a tuple of replication factors are also passed, it is assumed that the passed <code>xf</code> is relative to a replicated <code>accessibility_grid.box</code> so that <code>xf</code> is scaled by these rep. factors. So <code>xf = [0.5, 0.25, 0.1]</code> with <code>repfactors=(1, 2, 4)</code> actually is, relative to <code>accessibility_grid.box</code>, fractional coordinate <code>[0.5, 0.5, 0.4]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/6ba963b30461b42d2d25bda9dce6737fc51dad6f/src/grid.jl#L782-L798">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../energy_min/">« energy minimum</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 13 June 2021 19:15">Sunday 13 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
