var documenterSearchIndex = {"docs":
[{"location":"distance/","page":"computing distances","title":"computing distances","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"distance/#Distances","page":"computing distances","title":"Distances","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The distance between two Atoms in a Crystal is central to many operations within PorousMaterials.jl.  The distance function calculates the Cartesian displacement between the Coords (Cart or Frac) of two points, i and j, within a given box.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"xtal = Crystal(\"SBMOF-1.cif\")\ndistance(xtal.atoms.coords, xtal.box, 1, 10, false) # Cartesian distance within the unit cell\n# output\n4.962373067546231","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The apply_pbc argument allows for calculation of distances across the periodic boundaries of the box.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms.coords, xtal.box, 1, 10, true) # Cartesian distance accounting for periodic boundary\n# output\n4.143597209982431","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance also works on Atoms and Charges.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms, xtal.box, 3, 5, true)\n# output\n10.244292605252747","category":"page"},{"location":"distance/#docs","page":"computing distances","title":"docs","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"    distance","category":"page"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"energy_min/#Find-Potential-Energy-Minimum","page":"energy minimum","title":"Find Potential Energy Minimum","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"Here we show how to find the minimum energy (acc. to a force field) position of a molecule in a crystal.","category":"page"},{"location":"energy_min/#Example","page":"energy minimum","title":"Example","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"For example, we wish to find the minimum energy (acc. to the UFF) position of a xenon adsorbate in SBMOF-1. ","category":"page"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"xtal = Crystal(\"SBMOF-1.cif\")\nmolecule  = Molecule(\"Xe\")\nljff = LJForceField(\"UFF\")\n\n# grid search to find min energy position.\n#  gives good starting guess for optimization algorithm to fine tune.\nresolution = 1.0 # resolution of grid points in Å\nminimized_molecule, min_E = find_energy_minimum_gridsearch(xtal, molecule, ljff, resolution=resolution)\n# minimized_molecule: xenon at its min energy position\n# min_E: associated minimum energy of xenon (kJ/mol)\n\n# fine tune the minimum energy position according to the grid search.\nminimized_molecule, min_E = find_energy_minimum(xtal, minimized_molecule, ljff)\n# output\nComputing energy grid of Xe in SBMOF-1.cif\n\tRegular grid (in fractional space) of 13 by 7 by 24 points superimposed over the unit cell.\n(Molecule species: Xe\nCenter of mass (fractional coords): Frac([0.01749943805846959; 0.9372916114895011; 0.011192272400742498;;])\nAtoms:\n\n\tatom = Xe, xf = [0.017, 0.937, 0.011], -37.69376112588296)","category":"page"},{"location":"energy_min/#detailed-docs","page":"energy minimum","title":"detailed docs","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"    find_energy_minimum\n    find_energy_minimum_gridsearch","category":"page"},{"location":"energy_min/#PorousMaterials.find_energy_minimum","page":"energy minimum","title":"PorousMaterials.find_energy_minimum","text":"minimized_molecule, min_energy  = find_energy_minimum(xtal, molecule, ljff) # molecule set at initial guess\n\nfind the minimum energy position, and associated minimum energy, of a molecule in a crystal. n.b. if molecule has more than one atom, it will not minimize over the orientation (rotations). the optimizer needs an initial estimate of the minimum energy position.  pass molecule with good initial position. if you don't have a good initial position, use find_energy_minimum_gridsearch.\n\nArguments\n\nxtal::Crystal: the crystal\nmolecule::Molecule: the molecule, whose position we seek to tune until we reach a local minimum. must start at a good initial position close to the minimum.\nljff::LJForceField: the force field used to calculate crystal-molecule interaction energies\n\nReturns\n\nminimized_molecule::Molecule{Frac}: the molecule at its minimum energy position\nmin_energy::Float64: the associated minimum molecule-crystal interaciton energy (kJ/mol)\n\n\n\n\n\n","category":"function"},{"location":"energy_min/#PorousMaterials.find_energy_minimum_gridsearch","page":"energy minimum","title":"PorousMaterials.find_energy_minimum_gridsearch","text":"xf₀ = find_energy_minimum_gridsearch(xtal, molecule, ljff; resolution=(50, 50, 50))\n\nperform an energy_grid calculation and, via a grid search, find the minimum energy position of a molecule.\n\nArguments\n\nxtal::Crystal: The crystal being investigated\nmolecule::Molecule{Cart}: The molecule used to probe energy surface\nljff::LJForceField: The force field used to calculate interaction energies\nresolution::Union{Float64, Tuple{Int, Int, Int}}=1.0: maximum distance between grid points, in Å, or a tuple specifying the number of grid points in each dimension.\n\nReturns\n\nminimized_molecule::Molecule{Frac}: the molecule at its minimum energy position\nmin_energy::Float64: the associated minimum molecule-crystal interaciton energy (kJ/mol)\n\n\n\n\n\n","category":"function"},{"location":"henry/#Henry-Coefficient","page":"Henry coefficients","title":"Henry Coefficient","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"PorousMaterials.jl allows for Henry coefficient calculations using Widom insertions.","category":"page"},{"location":"henry/#Preparing-the-Henry-coefficient-simulation","page":"Henry coefficients","title":"Preparing the Henry coefficient simulation","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The simulation requires the following PorousMaterials.jl objects:","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"Crystal structure\nMolecule adsorbate\nLJForceField forcefield","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"In addition the the list above, one has to specify the temperature (in K) and the number of Widom insertions per unit volume (in Angstrom).","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"xtal = Crystal(\"SBMOF-1.cif\")           # The crystal structure we are interested in\nstrip_numbers_from_atom_labels!(xtal)   # We have to make sure the atom species have no numbers appended to them\nmethane = Molecule(\"CH4\")               # Here we choose to use methane as the adsorbate\nljff = LJForceField(\"UFF\")              # We will use the Universal Force Field (UFF) to calculate the interatomic interactions\ntemp = 298.0                            # Standard temperature (K)\nwidom_insertions = 2000                 # Number of insertions per unit volume\n\nresults = henry_coefficient(xtal, methane, temp, ljff, insertions_per_volume=widom_insertions)","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The results are also saved to rc[:paths][:simulations] as a .jld2 file that can be read using the JLD2 package.","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The output (and saved file) is a dictionary:","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"results\n# output\nDict{String, Any} with 16 entries:\n  \"⟨U⟩ (K)\"                              => -3623.51\n  \"err Qst (kJ/mol)\"                     => 0.0917643\n  \"⟨U, vdw⟩ (kJ/mol)\"                    => -30.1275\n  \"⟨U, es⟩ (kJ/mol)\"                     => 0.0\n  \"elapsed time (min)\"                   => 0.0978277\n  \"Qst (kJ/mol)\"                         => 32.6052\n  \"err henry coefficient [mmol/(g-bar)]\" => 6.12256\n  \"xtal\"                                 => \"SBMOF-1.cif\"\n  \"henry coefficient [mmol/(g-bar)]\"     => 46.1068\n  \"err ⟨U, es⟩ (kJ/mol)\"                 => 0.0\n  \"⟨U, vdw⟩ (K)\"                         => -3623.51\n  \"err ⟨U, vdw⟩ (kJ/mol)\"                => 0.0917643\n  \"⟨U, es⟩ (K)\"                          => 0.0\n  \"⟨U⟩ (kJ/mol)\"                         => -30.1275\n  \"henry coefficient [mol/(kg-Pa)]\"      => 0.000461068\n  \"henry coefficient [mol/(m³-bar)]\"     => 72406.2","category":"page"},{"location":"henry/#locating-the-saved-results","page":"Henry coefficients","title":"locating the saved results","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The name of the result filenames follow a convention outlined in henry_result_savename.","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"using JLD2\n# determine the canonical filename for the simulation\nresult_filename = henry_result_savename(xtal, methane, temp, ljff, widom_insertions)\n# load the results dictionary\n@load joinpath(rc[:paths][:simulations], result_filename) results","category":"page"},{"location":"henry/#detailed-docs","page":"Henry coefficients","title":"detailed docs","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"    henry_coefficient\n    henry_result_savename","category":"page"},{"location":"henry/#PorousMaterials.henry_coefficient","page":"Henry coefficients","title":"PorousMaterials.henry_coefficient","text":"result = henry_coefficient(crystal, molecule, temperature, ljforcefield,\n                            insertions_per_volume=200, verbose=true, ewald_precision=1e-6,\n                            autosave=true)\n\nConduct particle insertions to compute the Henry coefficient Kₕ of a molecule in a crystal. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): ⟨N⟩ = Kₕ P, where P is pressure and Kₕ is the Henry coefficient.\n\nKₕ = β ⟨e^{-β U}⟩, where the average is over positions and orientations of the molecule in the crystal.\n\nArguments\n\ncrystal::Crystal: the porous crystal in which we seek to simulate adsorption\nmolecule::Molecule: the adsorbate molecule\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\nljforcefield::LJForceField: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\ninsertions_per_volume::Int: number of Widom insertions to perform for computing the\n\naverage, per unit cell volume (Å³)\n\nverbose::Bool: whether or not to print off information during the simulation.\newald_precision::Float64: desired precision for Ewald summations; used to determine\n\nthe replication factors in reciprocal space.\n\nautosave::Bool: save results file as a .jld2 in rc[:paths][:simulations]\nfilename_comment::AbstractString: An optional comment that will be appended to the name of the saved file.\n\nReturns\n\nresult::Dict{String, Float64}: A dictionary containing all the results from the Henry coefficient simulation\n\n\n\n\n\n","category":"function"},{"location":"henry/#PorousMaterials.henry_result_savename","page":"Henry coefficients","title":"PorousMaterials.henry_result_savename","text":"save_name = henry_result_savename(crystal, molecule, temperature,\n                               ljforcefield, insertions_per_volume;\n                               comment=\"\")\n\nDetermine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\nArguments\n\ncrystal::Crystal: The porous crystal being tested\nmolecule::Molecule: The molecule being tested inside the crystal\ntemperature::Float64: The temperature used in the simulation units: Kelvin (K)\nljforcefield::LJForceField: The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces\ninsertions_per_volume::Union{Int, Float64}: The number of widom insertions per unit volume.   Will be scaled according to the crystal we're working with\ncomment::AbstractString: An optional comment that will be appended to the filename\n\n\n\n\n\n","category":"function"},{"location":"matter/","page":"matter","title":"matter","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"matter/#Matter-and-Coordinates","page":"matter","title":"Matter and Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Atoms and Charges are the building blocks of Crystals and Molecules in PorousMaterials.jl. Each have coordinates in both Cartesian and Fractional space (associated with unit cell information, i.e., a Box).","category":"page"},{"location":"matter/#Coordinates","page":"matter","title":"Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"we store coordinates as an abstract Coords type that has two subtypes: Cart and Frac for Cartesian and Fractional, respectively. see the Wikipedia page on fractional coordinates, which are defined in the context of a periodic system, e.g. within a crystal.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"construct coordinates of n particles by passing a n by 3 array ","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coord = Cart([1.0, 2.0, 5.0])  # construct cartesian coordinate of a particle\ncoord.x                        # 3 x 1 array, [1, 2, 3]\n\ncoord = Frac([0.1, 0.2, 0.5])  # construct fractional coordinate of a particle\ncoord.xf                       # 3 x 1 array, [0.1, 0.2, 0.3]","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"the coordinates of multiple particles are stored column-wise:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords = Cart([\n  0.651027   0.274176   0.386178  0.371651  0.619131;\n  0.0681196  0.0267313  0.836004  0.819681  0.585807;\n  0.667704   0.825569   0.780142  0.606194  0.572355\n])      # five particles at uniform random coordinates","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"many Array operations work on Coords, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords[2]                      # coordinate of 2nd particle\ncoords[2:3]                    # (slicing by index) coords of particles 2 and 3\ncoords[[1, 2, 5]]              # (slicing by index) coords of particles 1, 2, and 5\ncoords[rand(Bool, 5)]          # (boolean slicing) coords, selected at random\nlength(coords)                 # number of particles, (5)","category":"page"},{"location":"matter/#manipulating-coordinates","page":"matter","title":"manipulating coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Coords are immutable:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x = rand(3, 5)\n# output\nERROR: setfield!: immutable struct of type Cart cannot be changed","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"but we can manipulate the values of Array{Float64, 2} where coordinates (through coords.x or coords.xf) are stored:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x[2, 3] = 100.0\ncoords.x[:] = [ # need the [:] to say \"overwrite all of the elements\"\n  0.496997  0.560528   0.496615  0.213062  0.21751;\n  0.772372  0.697443   0.133055  0.211073  0.02676;\n  0.230555  0.0988727  0.592699  0.193649  0.16536\n]","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"fractional coordinates can be wrapped to be inside the unit cell box:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords = Frac([1.2, -0.3, 0.9])\nwrap!(coords)\n# output\n3×1 Matrix{Float64}:\n 0.19999999999999996\n 0.7\n 0.9","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can translate coordinates by a vector dx:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Cart([1.0, 2.0, 3.0])\ncoords = Cart([1.0, 0.0, 0.0])  \ntranslate_by!(coords, dx)\n# output\n3×1 Matrix{Float64}:\n 2.0\n 2.0\n 3.0","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"if dx::Frac and coords::Cart, translate_by! requires a Box to convert between fractional and cartesian, as the last argument:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Frac([0.1, 0.2, 0.3])\nbox = unit_cube()\ncoords = Cart([1.0, 0.0, 0.0])\ntranslate_by!(coords, dx, box)\n# output\n3×1 Matrix{Float64}:\n 1.1\n 0.20000000000000004\n 0.3","category":"page"},{"location":"matter/#Atoms","page":"matter","title":"Atoms","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"an atom is specified by its coordinates and atomic species. we can construct a set of atoms (perhaps, comprising a molecule or crystal) as follows.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"species = [:O, :H, :H]            # atomic species are represnted with Symbols\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of each\n               0.0 0.586  0.586; \n               0.0 0.0    0.0   ]\n             )\natoms = Atoms(species, coords)    # 3 atoms comprising water\natoms.n                           # number of atoms, 3\natoms.coords                      # coordinates; atoms.coords.x gives the array of coords\natoms.species                     # array of species\natoms::Atoms{Cart}                # successful type assertion, as opposed to atoms::Atoms{Frac}\n# output\nAtoms{Cart}(3, [:O, :H, :H], Cart([0.0 0.757 -0.757; 0.0 0.586 0.586; 0.0 0.0 0.0]))","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"the last line illustrates the two subtypes of Atoms, depending on whether the Coords are stored as Fractional or Cartesian.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can slice atoms, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms[2:3]\n# output\nAtoms{Cart}(2, [:H, :H], Cart([0.757 -0.757; 0.586 0.586; 0.0 0.0]))","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"and combine them:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms_combined = atoms[1] + atoms[2:3]\nisapprox(atoms, atoms_combined)\n# output\ntrue","category":"page"},{"location":"matter/#Charges","page":"matter","title":"Charges","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Charges, well, point charges, work analogously to atoms, except instead of species, the values of the point charges are stored in an array, q.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"q = [-1.0, 0.5, 0.5]              # values of point charges, units: electrons\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of the point charges\n               0.0 0.586  0.586; \n               0.0 0.0    0.0   ]\n             )\ncharges = Charges(q, coords)      # 3 point charges\ncharges.n                         # number of charges, 3\ncharges.coords                    # retreive coords\ncharges.q                         # retreive q\ncharges::Charges{Cart}            # successful type assertion, as opposed to charges::Charges{Frac}\n# output\nCharges{Cart}(3, [-1.0, 0.5, 0.5], Cart([0.0 0.757 -0.757; 0.0 0.586 0.586; 0.0 0.0 0.0]))","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can determine if the set of point charges comprise a charge-neutral system by:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"net_charge(charges)                 # 0.0\nneutral(charges)                    # true","category":"page"},{"location":"matter/#detailed-docs","page":"matter","title":"detailed docs","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"    Coords\n    Frac\n    Cart\n    Atoms\n    Charges\n    net_charge\n    neutral\n    translate_by!","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"molecule/#Molecules","page":"molecules","title":"Molecules","text":"","category":"section"},{"location":"molecule/#Loading-Molecule-Files","page":"molecules","title":"Loading Molecule Files","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"Molecule input files are stored in PorousMaterials.PATH_TO_MOLECULES. Each molecule possesses its own directory containing two files: charges.csv and atoms.csv, comma-separated-value files, which describe the point charges and Lennard Jones spheres, respectively, that compose the molecule. Only rigid molecules are currently supported. Units of length are in Angstroms (AA); units of charges are electrons.","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"molecule = Molecule(\"CO2\")\n# output\nMolecule species: CO2\nCenter of mass (fractional coords): Cart([0.0; 0.0; 0.0;;])\nAtoms:\n\n\tatom = C_CO2, x = [0.000, 0.000, 0.000]\n\tatom = O_CO2, x = [-1.160, 0.000, 0.000]\n\tatom = O_CO2, x = [1.160, 0.000, 0.000]\nPoint charges:\n\tcharge = 0.700000, x = [0.000, 0.000, 0.000]\n\tcharge = -0.350000, x = [-1.160, 0.000, 0.000]\n\tcharge = -0.350000, x = [1.160, 0.000, 0.000]","category":"page"},{"location":"molecule/#Building-Blocks-of-PorousMaterials:-Molecules","page":"molecules","title":"Building Blocks of PorousMaterials: Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"# access the attributes that comprise the molecule object\nmolecule.species   # molecule species\nmolecule.com       # center-of-mass\nmolecule.atoms     # Lennard-Jones spheres\nmolecule.charges   # point charges","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"To see specific information about the atoms and charges attributes of the molecule see Atoms and Charges.","category":"page"},{"location":"molecule/#Moving-Molecules","page":"molecules","title":"Moving Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"We can translate and roatate a molecule:","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"# convert to Molecule{Frac}\nmolecule = Frac(molecule, unit_cube())\n\n# translate center-of-mass to [1.0, 2.0, 3.0] in fractional coordinates\nx = Cart([1.0, 2.0, 3.0])\ntranslate_to!(molecule, x, unit_cube())\n\n# translate by [0.1, 0.0, 0.0] in fractional coordinates\ndx = Cart([0.1, 0.0, 0.0])\ntranslate_by!(molecule, dx, unit_cube())\n\n# conduct a uniform random rotation about the center-of-mass\nrandom_rotation!(molecule, unit_cube()) ","category":"page"},{"location":"molecule/#detailed-docs","page":"molecules","title":"detailed docs","text":"","category":"section"},{"location":"molecule/#Molecules-2","page":"molecules","title":"Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"    Molecule\n    translate_to!\n    random_rotation!\n    random_rotation_matrix()\n    ion\n    distortion","category":"page"},{"location":"molecule/#PorousMaterials.Molecule","page":"molecules","title":"PorousMaterials.Molecule","text":"Data structure for a molecule/adsorbate.\n\nAttributes\n\nspecies::Symbol: Species of molecule, e.g. :CO2\natoms::Atoms: array of Lennard-Jones spheres comprising the molecule\ncharges::Charges: array of point charges comprising the molecule\ncom::Coords: center of mass\n\n\n\n\n\n","category":"type"},{"location":"molecule/#PorousMaterials.translate_to!","page":"molecules","title":"PorousMaterials.translate_to!","text":"translate_to!(molecule, xf)\ntranslate_to!(molecule, x)\ntranslate_to!(molecule, xf, box)\ntranslate_to!(molecule, x, box)\n\nTranslate a molecule so that its center of masss is at a point xf in fractional coordinate space or at x in Cartesian coordinate space. For the latter, a unit cell box is required for context.\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_rotation!","page":"molecules","title":"PorousMaterials.random_rotation!","text":"random_rotation!(molecule{Frac}, box)\nrandom_rotation!(molecule{Cart})\n\nrandomly rotate a molecule about its center of mass.\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_rotation_matrix-Tuple{}","page":"molecules","title":"PorousMaterials.random_rotation_matrix","text":"r = random_rotation_matrix() # rotation matrix in cartesian coords\n\nGenerate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x,  this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x). the point x is in Cartesian coordinates here. See James Arvo. Fast Random Rotation Matrices.\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\nReturns\n\nr::Array{Float64, 2}: A 3x3 random rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"molecule/#PorousMaterials.ion","page":"molecules","title":"PorousMaterials.ion","text":"molecule = ion(q, coords)\n\nFacilitate constructing a point charge by constructing a molecule: Molecule(:ion, Atoms{Frac}(0), Charges(q, coords), coords)\n\nArguments\n\nq::Float64: value of point charge, units: electrons\ncoords::Frac: fractional coordinates of the charge\n\nReturns\n\nmolecule::Molecule{Frac}: the ion as a molecule with Fractional coordinates\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.distortion","page":"molecules","title":"PorousMaterials.distortion","text":"is_distorted = distortion(molecule, ref_molecule, box; \n                          atol=1e-12, throw_warning=true)\n\nDetermine whether a molecule has distortion w.r.t. a reference molecule via pairwise distance comparison of the atoms and charges coordinates.\n\nArguments\n\nmolecule::Molecule{Frac}: molecule you want to compare\nref_molecule::Molecule{Frac}: reference molecule\nbox::Box: box used for the fractional coordinates\natol::Float64=1e-12: absolute tolerance for distance comparison\nthrow_warning::Bool=true: issue a warning if there is distortion\n\nReturns\n\nis_distorted::Bool: true if there is distortion w.r.t. reference molecule \n\n\n\n\n\n","category":"function"},{"location":"molecule/#Molecular-Movement","page":"molecules","title":"Molecular Movement","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"    apply_periodic_boundary_condition!\n    random_insertion!\n    remove_molecule!\n    random_translation!\n    random_reinsertion!\n    needs_rotations","category":"page"},{"location":"molecule/#PorousMaterials.apply_periodic_boundary_condition!","page":"molecules","title":"PorousMaterials.apply_periodic_boundary_condition!","text":"apply_periodic_boundary_condition!(molecule::Molecule{Frac})\n\nCheck if each of a molecule's center-of-mass coordinates is within the bounds (0.0, 1.0) in fractional coordinates, and translate if needed.  \n\nArguments\n\nmolecule::Molecule{Frac}: the molecule to be checked\n\nReturns\n\nnothing, if the molecule is within the boundary; ohterwise, the coordinates of the input molecule will be modified\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_insertion!","page":"molecules","title":"PorousMaterials.random_insertion!","text":"random_insertion!(molecules::Array{Molecule{Frac}, 1}, box::Box, template::Molecule{Cart})\n\nInsert a molecule into the simulation box and perform a random rotation if needed. this function calls (insert_w_random_orientation!)[@ref], supplying it with a random position vector.\n\nArguments\n\nmolecules::Array{Molecule{Frac}, 1}: array containing the molecules in the simulation\nbox::Box: the box  used for fractional coordinats\ntemplate::Molecule{Cart}: reference molecule of the type inserted\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.remove_molecule!","page":"molecules","title":"PorousMaterials.remove_molecule!","text":"remove_molecule!(molecule_id, molecules)\n\nRemove a molecule from the array of molecules.\n\nArguments\n\nmolecule_id::Int: the ID of the molecule to be removed\nmolecules::Array{<:Molecule, 1}: array of molecules to be modified\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_translation!","page":"molecules","title":"PorousMaterials.random_translation!","text":"random_reinsertion!(molecule, box)\n\nPerform a translational perturbation in Cartesian coordinates on a molecule, apply the periodic boundry conditions, and keep a copy of the original in case it needs to be restored.\n\nArguements\n\nmolecule::Molecule{Frac}: molecule to be translated\nbox::Box: the box used in rotation\n\nReturns\n\nold_molecule::Molecule{Frac}: a copy of the original molecule\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_reinsertion!","page":"molecules","title":"PorousMaterials.random_reinsertion!","text":"random_reinsertion!(molecule, box)\n\nPerform a translation and rotated (if needed) on a molecule, and keep a copy of the original in case it needs to be restored.\n\nArguements\n\nmolecule::Molecule{Frac}: molecule to be translated and rotated (if needed)\nbox::Box: the box used in rotation\n\nReturns\n\nold_molecule::Molecule{Frac}: a copy of the original molecule\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.needs_rotations","page":"molecules","title":"PorousMaterials.needs_rotations","text":"needs_rotations(molecule) # true or false\n\nDetermine whether a molecule needs to undergo rotation.\n\n`true` if molecule.atoms.n + molecule.charges.n > 1\n\n\n\n\n\n","category":"function"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"force_field/#Lennard-Jones-Force-Fields-and-Potential-Energy","page":"forcefields","title":"Lennard-Jones Force Fields and Potential Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Lennard-Jones force field parameters are stored in comma-separated-value format in rc[:paths][:forcefields].","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Interaction of an adsorbate with the crystal is modeled as pair-wise additive and with Lennard-Jones potentials of the form:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"V(r) = 4 * ϵ * [ x ^ 12 - x ^ 6 ], where x = σ / r","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"The Lennard-Jones force field input files, e.g. UFF.csv contain a list of pure (i.e. X-X, where X is an atom) sigmas (σ) and epsilons (ϵ) with units Angstrom (Å) and Kelvin (K), respectively. Note that, e.g., in the UFF paper, the Lennard-Jones potential is written in a different form; thus, parameters need to be converted to correspond to the functional form used in PorousMaterials.jl.","category":"page"},{"location":"force_field/#Building-Blocks-of-PorousMaterials:-Lennard-Jones-Force-Fields","page":"forcefields","title":"Building Blocks of PorousMaterials: Lennard-Jones Force Fields","text":"","category":"section"},{"location":"force_field/#Loading-Force-Field-Files-and-Accessing-Attributes","page":"forcefields","title":"Loading Force Field Files and Accessing Attributes","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Reading in Lennard-Jones force field parameters is made easy with the LJForceField function. Let's load in the parameters from the Universal Force Field file (UFF.csv):","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"# read in Lennard-Jones force field parameters from the Universal Force Field\nljforcefield = LJForceField(\"UFF\", r_cutoff=14.0, mixing_rules=\"Lorentz-Berthelot\")\n# output\nForce field: UFF\nNumber of atoms included: 108\nCut-off radius (Å) = 14.0\n   Ra-   Ra ϵ =  203.30076 K, σ =    3.27583 Å\n   Cl-   Cl ϵ =  114.23087 K, σ =    3.51638 Å\n   Al-   Al ϵ =  254.12595 K, σ =    4.00815 Å\n   Be-   Be ϵ =   42.77367 K, σ =    2.44552 Å\n   Re-   Re ϵ =   33.21250 K, σ =    2.63171 Å\n   Cr-   Cr ϵ =    7.54830 K, σ =    2.69319 Å\n   Na-   Na ϵ =   15.09659 K, σ =    2.65755 Å\n   Sb-   Sb ϵ =  225.94565 K, σ =    3.93777 Å\n   Cf-   Cf ϵ =    6.54186 K, σ =    2.95155 Å\n   Kr-   Kr ϵ =  110.70833 K, σ =    3.68921 Å\n   Ni-   Ni ϵ =    7.54830 K, σ =    2.52481 Å\n    S-    S ϵ =  137.88220 K, σ =    3.59478 Å\n  CH4-  CH4 ϵ =  148.00000 K, σ =    3.73000 Å\n   Fm-   Fm ϵ =    6.03864 K, σ =    2.92749 Å\n   Ru-   Ru ϵ =   28.18030 K, σ =    2.63973 Å\n   Tl-   Tl ϵ =  342.18940 K, σ =    3.87274 Å\n   re-   re ϵ =    0.00010 K, σ =    5.00000 Å\n   Tm-   Tm ϵ =    3.01932 K, σ =    3.00589 Å\nC_CO2-C_CO2 ϵ =   27.00000 K, σ =    2.80000 Å\n    W-    W ϵ =   33.71572 K, σ =    2.73417 Å\n    O-    O ϵ =   30.19318 K, σ =    3.11815 Å\n   Nd-   Nd ϵ =    5.03220 K, σ =    3.18496 Å\n   Tb-   Tb ϵ =    3.52254 K, σ =    3.07449 Å\n   Th-   Th ϵ =   13.08371 K, σ =    3.02549 Å\n   Zr-   Zr ϵ =   34.72216 K, σ =    2.78317 Å\n    F-    F ϵ =   25.16099 K, σ =    2.99698 Å\n   Co-   Co ϵ =    7.04508 K, σ =    2.55866 Å\n   Fr-   Fr ϵ =   25.16099 K, σ =    4.36540 Å\n   Gd-   Gd ϵ =    4.52898 K, σ =    3.00055 Å\n   Rh-   Rh ϵ =   26.67064 K, σ =    2.60944 Å\n   Pu-   Pu ϵ =    8.05152 K, σ =    3.05044 Å\n   Lw-   Lw ϵ =    5.53542 K, σ =    2.88295 Å\n   Ar-   Ar ϵ =   93.09564 K, σ =    3.44600 Å\n   Ca-   Ca ϵ =  119.76629 K, σ =    3.02816 Å\n   Cm-   Cm ϵ =    6.54186 K, σ =    2.96313 Å\n    N-    N ϵ =   34.72216 K, σ =    3.26069 Å\n   As-   As ϵ =  155.49489 K, σ =    3.76850 Å\n   Yb-   Yb ϵ =  114.73409 K, σ =    2.98897 Å\n   Se-   Se ϵ =  146.43693 K, σ =    3.74623 Å\n    Y-    Y ϵ =   36.23182 K, σ =    2.98006 Å\n   Am-   Am ϵ =    7.04508 K, σ =    3.01213 Å\n   Pt-   Pt ϵ =   40.25758 K, σ =    2.45354 Å\n    I-    I ϵ =  170.59148 K, σ =    4.00904 Å\n   Fe-   Fe ϵ =    6.54186 K, σ =    2.59430 Å\n   Ba-   Ba ϵ =  183.17197 K, σ =    3.29900 Å\n   Hf-   Hf ϵ =   36.23182 K, σ =    2.79831 Å\n   Es-   Es ϵ =    6.03864 K, σ =    2.93907 Å\n   Po-   Po ϵ =  163.54640 K, σ =    4.19524 Å\n   Eu-   Eu ϵ =    4.02576 K, σ =    3.11191 Å\n    C-    C ϵ =   52.83807 K, σ =    3.43085 Å\n   Zn-   Zn ϵ =   62.39924 K, σ =    2.46155 Å\n   Cs-   Cs ϵ =   22.64489 K, σ =    4.02419 Å\n   Mn-   Mn ϵ =    6.54186 K, σ =    2.63795 Å\n   Rn-   Rn ϵ =  124.79849 K, σ =    4.24513 Å\n   Bk-   Bk ϵ =    6.54186 K, σ =    2.97471 Å\n   Ir-   Ir ϵ =   36.73504 K, σ =    2.53015 Å\n   Rb-   Rb ϵ =   20.12879 K, σ =    3.66516 Å\n   In-   In ϵ =  301.42860 K, σ =    3.97608 Å\n   Hg-   Hg ϵ =  193.73958 K, σ =    2.40988 Å\n   Te-   Te ϵ =  200.28144 K, σ =    3.98232 Å\n   At-   At ϵ =  142.91439 K, σ =    4.23177 Å\n   Bi-   Bi ϵ =  260.66780 K, σ =    3.89323 Å\n   Cu-   Cu ϵ =    2.51610 K, σ =    3.11369 Å\n   Tc-   Tc ϵ =   24.15455 K, σ =    2.67091 Å\n   Sn-   Sn ϵ =  285.32557 K, σ =    3.91283 Å\n   Pa-   Pa ϵ =   11.07083 K, σ =    3.05044 Å\n   Lu-   Lu ϵ =   20.63201 K, σ =    3.24287 Å\n   Mo-   Mo ϵ =   28.18030 K, σ =    2.71902 Å\n   Ac-   Ac ϵ =   16.60625 K, σ =    3.09855 Å\n    U-    U ϵ =   11.07083 K, σ =    3.02460 Å\n   Li-   Li ϵ =   12.58049 K, σ =    2.18359 Å\n   Er-   Er ϵ =    3.52254 K, σ =    3.02104 Å\n   Ta-   Ta ϵ =   40.76080 K, σ =    2.82415 Å\nS_H2S-S_H2S ϵ =  122.00000 K, σ =    3.60000 Å\n   Cd-   Cd ϵ =  114.73409 K, σ =    2.53728 Å\n   Os-   Os ϵ =   18.61913 K, σ =    2.77960 Å\n   Ti-   Ti ϵ =    8.55473 K, σ =    2.82860 Å\n    B-    B ϵ =   90.57955 K, σ =    3.63754 Å\n    V-    V ϵ =    8.05152 K, σ =    2.80099 Å\nH_H2S-H_H2S ϵ =   50.00000 K, σ =    2.50000 Å\n   Si-   Si ϵ =  202.29432 K, σ =    3.82641 Å\n   Ga-   Ga ϵ =  208.83618 K, σ =    3.90481 Å\n   Au-   Au ϵ =   19.62557 K, σ =    2.93373 Å\n   Mg-   Mg ϵ =   55.85739 K, σ =    2.69141 Å\n    K-    K ϵ =   17.61269 K, σ =    3.39611 Å\n   Ag-   Ag ϵ =   18.11591 K, σ =    2.80455 Å\n   Sc-   Sc ϵ =    9.56117 K, σ =    2.93551 Å\n   Ge-   Ge ϵ =  190.72027 K, σ =    3.81305 Å\n   Nb-   Nb ϵ =   29.68996 K, σ =    2.81969 Å\n   Ce-   Ce ϵ =    6.54186 K, σ =    3.16804 Å\n   Pm-   Pm ϵ =    4.52898 K, σ =    3.16002 Å\n   Pd-   Pd ϵ =   24.15455 K, σ =    2.58272 Å\n   Dy-   Dy ϵ =    3.52254 K, σ =    3.05400 Å\n   Sr-   Sr ϵ =  118.25663 K, σ =    3.24376 Å\n   Ho-   Ho ϵ =    3.52254 K, σ =    3.03707 Å\n   No-   No ϵ =    5.53542 K, σ =    2.89364 Å\nO_CO2-O_CO2 ϵ =   79.00000 K, σ =    3.05000 Å\n   Sm-   Sm ϵ =    4.02576 K, σ =    3.13596 Å\n   Br-   Br ϵ =  126.30814 K, σ =    3.73197 Å\n   Pb-   Pb ϵ =  333.63466 K, σ =    3.82819 Å\n   Xe-   Xe ϵ =  167.06894 K, σ =    3.92352 Å\n   Np-   Np ϵ =    9.56117 K, σ =    3.05044 Å\n    P-    P ϵ =  153.48201 K, σ =    3.69456 Å\n   La-   La ϵ =    8.55473 K, σ =    3.13775 Å\n   Md-   Md ϵ =    5.53542 K, σ =    2.91680 Å\n    H-    H ϵ =   22.14167 K, σ =    2.57113 Å\n   Pr-   Pr ϵ =    5.03220 K, σ =    3.21258 Å\n   He-   He ϵ =   28.18319 K, σ =    2.10430 Å","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"This also prints all of the atoms included in the loaded forcefield with their given ϵ and σ. This was excluded because it would use too much space on this page. ","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"We can access attributes LJForceField such as pure_σ, pure_ϵ, and interaction values:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"# access the Lennard-Jones epsilon & sigma for Xe \nljforcefield.pure_ϵ[:Xe] # K\nljforcefield.pure_σ[:Xe] # Å\n\n# access the Lennard-Jones epsilon & sigma for Xe-C interactions\nljforcefield.ϵ[:Xe][:C]  # K\nljforcefield.σ²[:Xe][:C] # Å (store σ² for faster computation)","category":"page"},{"location":"force_field/#Checking-Force-Field-Coverage","page":"forcefields","title":"Checking Force Field Coverage","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"When running simulations, it is necessary to have the force field terms for all of the atoms. This can be checked using forcefield_coverage:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"# check is the atoms in a crystal are covered\nxtal = Crystal(\"SBMOF-1.cif\")\nforcefield_coverage(xtal, ljforcefield)\n\n# check if the atoms in a molecule are covered\nmolecule = Molecule(\"CO2\")\nforcefield_coverage(molecule, ljforcefield)","category":"page"},{"location":"force_field/#Simulation-Box-and-the-Cutoff-Radius","page":"forcefields","title":"Simulation Box and the Cutoff Radius","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Find the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius.In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop.The replication_factors function ensures enough replication factors such that the nearest image convention can be applied.","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"r_cutoff = 14.0 # Å\nrepfactors = replication_factors(xtal.box, r_cutoff) \n# output\n(3, 6, 2)","category":"page"},{"location":"force_field/#Potential-Energies:-Van-der-Waals","page":"forcefields","title":"Potential Energies: Van der Waals","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at Cartesian coordinates [0.0, 1.0, 3.0] using the UFF as a molecular model?","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"# load molecule and convert it to fractional\nmolecule = Molecule(\"Xe\")\nmolecule = Frac(molecule, xtal.box) \ntranslate_to!(molecule, Cart([0.0, 1.0, 3.0]), xtal.box) # need box b/c we're in Cartesian\nenergy = vdw_energy(xtal, molecule, ljforcefield) # K\n# output\n5.73882798944654e6","category":"page"},{"location":"force_field/#detailed-docs","page":"forcefields","title":"detailed docs","text":"","category":"section"},{"location":"force_field/#Forcefields","page":"forcefields","title":"Forcefields","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    LJForceField\n    replication_factors\n    forcefield_coverage","category":"page"},{"location":"force_field/#PorousMaterials.LJForceField","page":"forcefields","title":"PorousMaterials.LJForceField","text":"Data structure for a Lennard Jones forcefield.\n\nAttributes\n\nname::String: name of forcefield; correponds to filename\npure_σ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones σ of an X-X interaction, where X is an atom. (units: Angstrom)\npure_ϵ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones ϵ of an X-X interaction, where X is an atom. (units: K)\nσ²::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones σ² (units: Angstrom²) for cross-interactions. Example use is sigmas_squared[:He][:C]\nϵ::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones ϵ (units: K) for cross-interactions. Example use is epsilons[:He][:C]\nr²_cutoff::Float64: The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom²). We store σ² to speed up computations, which involve σ², not σ.\n\n\n\n\n\n","category":"type"},{"location":"force_field/#PorousMaterials.replication_factors","page":"forcefields","title":"PorousMaterials.replication_factors","text":"repfactors = replication_factors(unitcell, r_cutoff)\n\nFind the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied.\n\nA non-replicated supercell has 1 as the replication factor in each dimension (repfactors = (1, 1, 1)).\n\nArguments\n\nunitcell::Box: The unit cell of the crystal\nr_cutoff::Float64: Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom)\n\nReturns\n\nrepfactors::Tuple{Int, Int, Int}: The replication factors in the a, b, c directions\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.forcefield_coverage","page":"forcefields","title":"PorousMaterials.forcefield_coverage","text":"forcefield_coverage(atoms, ljforcefield)\nforcefield_coverage(molecule, ljforcefield)\nforcefield_coverage(crystal, ljforcefield)\n\nCheck that the force field contains parameters for every species in atoms::Atoms. Will print out which atoms are missing.\n\nArguments\n\natoms::Atoms: a set of atoms\nljforcefield::LJForceField: A Lennard Jones forcefield object containing information on atom interactions\n\nReturns\n\nall_covered::Bool: returns true if all species in the atoms are covered by the force field.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Potential-Energy","page":"forcefields","title":"Potential Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    PotentialEnergy\n    SystemPotentialEnergy","category":"page"},{"location":"force_field/#Nearest-Image-Conventions","page":"forcefields","title":"Nearest Image Conventions","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    nearest_image!","category":"page"},{"location":"force_field/#Electrostatics-Energy","page":"forcefields","title":"Electrostatics Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    Eikr\n    total\n    electrostatic_potential\n    electrostatic_potential_energy\n    precompute_kvec_wts\n    setup_Ewald_sum\n    total_electrostatic_potential_energy","category":"page"},{"location":"force_field/#PorousMaterials.Eikr","page":"forcefields","title":"PorousMaterials.Eikr","text":"eikr = Eikr(eikar, eikbr, eikcr)\n\nmutable struct for holding the eikr vectors\n\nAttributes\n\neikar::OffsetArray{Complex{Float64}}: array for storing e^{i * ka ⋅ r}; has indices   0:kreps[1] and corresponds to recip. vectors in a-direction\neikbr::OffsetArray{Complex{Float64}}: array for storing e^{i * kb ⋅ r}; has indices   -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction\neikcr::OffsetArray{Complex{Float64}}: array for storing e^{i * kc ⋅ r}; has indices   -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction\n\n\n\n\n\n","category":"type"},{"location":"force_field/#PorousMaterials.electrostatic_potential_energy","page":"forcefields","title":"PorousMaterials.electrostatic_potential_energy","text":"ϕ = electrostatic_potential_energy(crystal, molecule, eparams, eikr)\n\nCompute the electrostatic potential energy of a molecule inside a crystal.\n\nThe electrostatic potential is created by the point charges assigned to the crystal atoms in crystal.charges. Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at differences in energy in a Monte Carlo simulation.\n\nWarning: it is assumed that the crystal is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in eparams.sr_cutoff_r.\n\nArguments\n\ncrystal::Crystal: Crystal structure (see crystal.charges for charges)\nmolecule::Molecule: The molecule being compared to the atoms in the crystal.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\npot::EwaldSum: Electrostatic potential between crystal and molecule (units: K)\n\n\n\n\n\nϕ = electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCompute the electrostatic potential energy of a system comprised of an array of Molecules.\n\nThe EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive.\n\nReturns an EwaldSum type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (ϕ.sr, ϕ.lr, ϕ.self, ϕ.intra).\n\nUnits of energy: Kelvin\n\nArguments\n\nmolecules::Array{Molecules, 1}: array of molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: the box the energy is being computed in\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.precompute_kvec_wts","page":"forcefields","title":"PorousMaterials.precompute_kvec_wts","text":"kvectors = precompute_kvec_wts(kreps, box, α, max_mag_k_sqrd=Inf)\n\nFor speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry:     cos(-k⋅(x-xᵢ)) + cos(k⋅(x-xᵢ)) = 2 cos(k⋅(x-xᵢ))\n\nIf max_mag_k_sqrd is passed, k-vectors with a magnitude greater than max_mag_k_sqrd are not included.\n\nArguments\n\nkreps::Tuple{Int, Int, Int}: number of k-vector replications required in a, b, c\nbox::Box: the simulation box containing the reciprocal lattice.\nα::Float64: Ewald sum convergence parameter (units: inverse Å)\nmax_mag_k_sqrd::Float64: cutoff for |k|² in Fourier sum; if passed, do not include\n\nk-vectors with magnitude squared greater than this.\n\nReturns\n\nkvectors::Array{Kvector, 1}: array of k-vectors to include in the Fourier sum and their\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.setup_Ewald_sum","page":"forcefields","title":"PorousMaterials.setup_Ewald_sum","text":"eparams = setup_Ewald_sum(box, sr_cutoff_r; ϵ=1e-6, verbose=false)\n\nGiven the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information.\n\nAlso, pre-compute weights on k-vector contributions to Ewald sum in Fourier space.\n\nAlso, allocate OffsetArrays for storing e^{i * k ⋅ r} where r = x - xⱼ and k is a reciprocal lattice vector.\n\nArguments\n\nbox::Box: the simulation box containing the reciprocal lattice.\nsr_cutoff_r::Float64: cutoff-radius (units: Å) for short-range contributions to Ewald\nϵ::Float64: desired level of precision. Typical value is 1e-6, but this does not\nverbose::Bool: If true will print results\n\nReturns\n\neparams::EwaldParams: data structure containing Ewald summation settings\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.total_electrostatic_potential_energy","page":"forcefields","title":"PorousMaterials.total_electrostatic_potential_energy","text":"total_ϕ = total_electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCalculates the total electrostatic potential energy of an array of Molecules using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this\n\nArguments\n\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: The box the energy is being computed in.\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\ntotal_ϕ = total_electrostatic_potential_energy(crystal, molecules, eparams, eikr)\n\nExplanation of totalelectrostaticpotential_energy that uses crystal\n\nArguments\n\ncrystal::Crystal: Crystal structure (see crystal.charges for charges)\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Van-der-Waals-Energy","page":"forcefields","title":"Van der Waals Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    lennard_jones\n    vdw_energy\n    vdw_energy_no_PBC","category":"page"},{"location":"force_field/#PorousMaterials.lennard_jones","page":"forcefields","title":"PorousMaterials.lennard_jones","text":"energy = lennard_jones(r², σ², ϵ)  (units: Kelvin)\n\nCalculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. σ and ϵ are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of ϵ are).\n\nArguments\n\nr²::Float64: distance between two (pseudo)atoms in question squared (Angstrom²)\nσ²::Float64: sigma parameter in Lennard Jones potential squared (units: Angstrom²)\nϵ::Float64: epsilon parameter in Lennard Jones potential (units: Kelvin)\n\nReturns\n\nenergy::Float64: Lennard Jones potential energy\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.vdw_energy","page":"forcefields","title":"PorousMaterials.vdw_energy","text":"energy = vdw_energy(crystal, molecule, ljforcefield)\n\nCalculates the van der Waals interaction energy between a molecule and a crystal. Applies the nearest image convention to find the closest replicate of a specific atom.\n\nWARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See replicate and replication_factors.\n\n\n\n\n\nggenergy = vdwenergy(moleculeid, molecules, ljforcefield, simulationbox)\n\nCalculates van der Waals interaction energy of a single adsorbate molecules[molecule_id] with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention.\n\nArguments\n\nmolecule_id::Int: Molecule ID used to determine which molecule in molecules we wish to calculate the guest-guest interactions\nmolecules::Array{Molecule, 1}: An array of Molecule data structures\nljforcefield::LJForceField: A Lennard Jones forcefield data structure describing the interactions between different atoms\nsimulation_box::Box: The simulation box for the computation.\n\nReturns\n\ngg_energy::Float64: The guest-guest interaction energy of molecules[molecule_id] with the other molecules in molecules\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.vdw_energy_no_PBC","page":"forcefields","title":"PorousMaterials.vdw_energy_no_PBC","text":"potenergy = vdwenergynoPBC(atomsi, atomsj , ljff)\n\ncompute vdw potential energy without periodic boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"paths/","page":"paths","title":"paths","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"paths/#Data-paths","page":"paths","title":"Data paths","text":"","category":"section"},{"location":"paths/","page":"paths","title":"paths","text":"PorousMaterials.jl is built on Xtals.jl.  All bindings are re-exported.  As such, the global variable dictionary rc is part of the PorousMaterials namespace.  This is where data such as atomic masses and covalent radii are stored.","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"keys(rc)\n# output\nKeySet for a Dict{Symbol, Any} with 5 entries. Keys:\n  :covalent_radii\n  :bonding_rules\n  :atomic_masses\n  :cpk_colors\n  :paths","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"rc[:paths] gives a listing of the read/write paths for various kinds of information.  By default, rc[:paths][:data] will be set to ./data based on the present working directory when the module is imported.  All the other paths are set relative to rc[:paths][:data]:","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"keys(rc[:paths])\n# output\nKeySet for a Dict{Symbol, String} with 6 entries. Keys:\n  :forcefields\n  :grids\n  :molecules\n  :crystals\n  :data\n  :simulations","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"So, for example, if PorousMaterials is loaded in /my_project, then rc[:paths][:data] will by default be /my_project/data and the other paths will be subdirectories, e.g. /my_project/data/simulations.","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"To move the root of the data tree and change all the paths together, use set_paths:","category":"page"},{"location":"paths/","page":"paths","title":"paths","text":"set_paths(\"other_project\")\n# now rc[:paths][:data] is \"other_project/data\"\n# rc[:paths][:crystals] is \"other_project/data/crystals\"\n# etc.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"eos/#Equation-of-State","page":"equations of state","title":"Equation of State","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"PorousMaterials.jl provides Peng-Robinson and van der Waals equation of state calculations to find the properties of a real fluid.","category":"page"},{"location":"eos/#Peng-Robinson-equation-of-state","page":"equations of state","title":"Peng-Robinson equation of state","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The Peng-Robinson equation of state can be written as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where V_m is the molar volume, R is the gas constant, and T is temperature.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"Variables a and b can be calculated using the critical temperature, T_c and pressure, P_c, of the fluid:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_a)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_b)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"and alpha can be calculated using acentric factor omega and critical temperature:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_alpha)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_kappa)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"and","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_Tr)","category":"page"},{"location":"eos/#Van-der-Waals-equation-of-state","page":"equations of state","title":"Van der Waals equation of state","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The van der Waals equation can be written as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: VDWEOS)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where a and b are the van der Waals constants. a and b can be calculated from fluid critical propertis, but PorousMaterials.jl reads them in as experimentally determined values.","category":"page"},{"location":"eos/#reading-in-fluid-characteristics","page":"equations of state","title":"reading in fluid characteristics","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"PengRobinsonFluid and VdWFluid are structs defining the characteristics of a fluid of interest, depending on which equation of state is used.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For Peng-Robinson fluids, PorousMaterials.jl reads in the critical temperature, critical pressure, and acentric factor of fluid::Symbol from the properties .csv file rc[:paths][:data], \"PengRobinson_fluid_props.csv\").","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For van der Waals fluids, van der Waals constants of fluid::Symbol are read in from the properties .csv file joinpath(rc[:paths][:data], \"VdW_fluid_props.csv\").","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"*** NOTE: DO NOT DELETE LAST THREE COMMENT LINES IN PengRobinson_fluid_props.csv AND VdW_fluid_props.csv","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The characteristics can be read as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For Peng-Robinson fluids","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"fluid = PengRobinsonFluid(:Xe)       # Input fluid as a symbol. The fluids reader stores the information in fluid as a struct\nfluid.fluid                          # The name of the fluid\nfluid.Pc                             # The critical pressure of the fluid\nfluid.Tc                             # The critical temperature of the fluid\nfluid.ω                              # The acentric factor of the fluid","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For van der Waals fluids","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"fluid = VdWFluid(:Xe)                # Input fluid as a symbol. The fluids reader stores the information in fluid as a struct\nfluid.fluid                          # The name of the fluid\nfluid.a                              # The van der Waals constant a of the fluid\nfluid.b                              # The van der Waals constant b of the fluid","category":"page"},{"location":"eos/#calculating-density,-fugacity,-and-molar-volume","page":"equations of state","title":"calculating density, fugacity, and molar volume","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"Using a given temperature and pressure, PorousMaterials.jl the equation of state can be used to calculate the dnesity, fugacity, and molar volume of a real fluid, stored as a dictionary.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"T = 298.0 # K                        # The temperature in Kelvin of interest type Float64.\nP = 1.0 # bar                        # The pressure in bar of interest type Float64.\nprops = calculate_properties(fluid, T, P, verbose=true) # verbose::Bool will print results if `true`\n# output\nXe properties at T = 298.000000 K, P = 1.000000 bar:\n\tcompressibility factor: 0.995117906779058\n\tfugacity coefficient: 0.9951492697826048\n\tmolar volume (L/mol): 24.65612613988038\n\tfugacity (bar): 0.9951492697826048\n\tdensity (mol/m³): 40.55787167565373\nDict{String, Float64} with 5 entries:\n  \"compressibility factor\" => 0.995118\n  \"fugacity coefficient\"   => 0.995149\n  \"molar volume (L/mol)\"   => 24.6561\n  \"fugacity (bar)\"         => 0.995149\n  \"density (mol/m³)\"       => 40.5579","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The output is a dictionary containing the following keys:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"props[\"compressibility factor\"]    # the compressibility factor\nprops[\"density (mol/m³)\"]          # fluid density in mol/m³\nprops[\"fugacity (bar)\"]            # the fugacity in bar\nprops[\"fugacity coefficient\"]      # the fugacity coefficient\nprops[\"molar volume (L/mol)\"]      # the molar volume in L/mol","category":"page"},{"location":"eos/#detailed-docs","page":"equations of state","title":"detailed docs","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"    PengRobinsonFluid\n    VdWFluid\n    calculate_properties","category":"page"},{"location":"eos/#PorousMaterials.PengRobinsonFluid","page":"equations of state","title":"PorousMaterials.PengRobinsonFluid","text":"fluid = PengRobinsonFluid(fluid)\n\nReads in critical temperature, critical pressure, and acentric factor of the fluid::Symbol from the properties .csv file joinpath(PorousMaterials.rc[:paths][:data], \"PengRobinson_fluid_props.csv\") and returns a complete PengRobinsonFluid data structure. **NOTE: Do not delete the last three comment lines in PengRobinsonfluidprops.csv\n\nArguments\n\nfluid::Symbol: The fluid molecule you wish to construct a PengRobinsonFluid struct for\n\nReturns\n\nPengRobinsonFluid::struct: Data structure containing Peng-Robinson fluid parameters.\n\n\n\n\n\n","category":"type"},{"location":"eos/#PorousMaterials.VdWFluid","page":"equations of state","title":"PorousMaterials.VdWFluid","text":"fluid = VdWFluid(fluid)\n\nReads in van der Waals constants of the fluid::Symbol from the properties .csv file joinpath(PorousMaterials.rc[:paths][:data], \"VdW_fluid_props.csv\") and returns a complete VdWFluid data structure. ***NOTE: Do not delete the last three comment lines in VdWfluidprops.csv\n\nArguments\n\nfluid::Symbol: The fluid you wish to construct a VdWFluid struct for\n\nReturns\n\nVdWFluid::struct: Data structure containing van der Waals constants\n\n\n\n\n\n","category":"type"},{"location":"eos/#PorousMaterials.calculate_properties","page":"equations of state","title":"PorousMaterials.calculate_properties","text":"props = calculate_properties(fluid, T, P, verbose=true)\n\nUse equation of state to calculate density, fugacity, and molar volume of a real fluid at a given temperature and pressure.\n\nArguments\n\nfluid::Union{PengRobinsonFluid, VdWFluid}: Peng-Robinson/ van der Waals fluid data structure\nT::Float64: Temperature (units: Kelvin)\nP::Float64: Pressure (units: bar)\nverbose::Bool: will print results if true\n\nReturns\n\nprop_dict::Dict: Dictionary of Peng-Robinson/ van der Waals fluid properties\n\n\n\n\n\n","category":"function"},{"location":"box/","page":"boxes","title":"boxes","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"box/#The-Spatial-Box","page":"boxes","title":"The Spatial Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Within PorousMaterials.jl, the 3D space in which all Coords are located is the Box.  Each Crystal has its own Box, equivalent to the unit cell of a material, containing as attributes the unit cell edge lengths (a b c), crystallographic dihedral angles (α β γ), volume, conversion factors for translating between Fractional and Cartesian coordinates, and the reciprocal (Fourier transform) vectors for the Bravais lattice.","category":"page"},{"location":"box/#defining-a-box","page":"boxes","title":"defining a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box is most conveniently constructed from its basic spatial data (a b c α β γ).  For example, given the unit cell of Co-MOF-74, we can define its Box:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"a = 26.13173 # Å\nb = 26.13173\nc = 6.722028\nα = π/2 # radians\nβ = π/2\nγ = 2*π/3\nbox = Box(a, b, c, α, β, γ)\n# output\nBravais unit cell of a crystal.\n\tUnit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 120.000000 deg.\n\tUnit cell dimensions a = 26.131730 Å. b = 26.131730 Å, c = 6.722028 Å\n\tVolume of unit cell: 3975.275878 Å³","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box may also be defined by providing only the Fractional-to-Cartesian conversion matrix:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"box = Box([26.1317 -13.0659 0; 0 22.6307 0; 0 0 6.72203])\n# output\nBravais unit cell of a crystal.\n\tUnit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 120.000113 deg.\n\tUnit cell dimensions a = 26.131700 Å. b = 26.131711 Å, c = 6.722030 Å\n\tVolume of unit cell: 3975.265115 Å³","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"To quickly get a simple unit-cubic Box, use the unit_cube function.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"unit_cube()\n# output\nBravais unit cell of a crystal.\n\tUnit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 90.000000 deg.\n\tUnit cell dimensions a = 1.000000 Å. b = 1.000000 Å, c = 1.000000 Å\n\tVolume of unit cell: 1.000000 Å³","category":"page"},{"location":"box/#transforming-coordinates","page":"boxes","title":"transforming coordinates","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Conversions are provided for switching between Fractional and Cartesian Coords using the Box (works for Atoms and Charges, too)","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"xtal = Crystal(\"SBMOF-1.cif\")\nCart(xtal.atoms.coords, xtal.box)\n# output\nCart([4.594867082350715 -0.952720283971488 … 0.8392490029633858 -1.5321086078257065; 1.4395486200000005 4.2228986200000005 … 1.4289162230000012 4.212266223; 5.89964228469024 5.359217037237699 … 17.537474811394276 16.239103154389543])","category":"page"},{"location":"box/#replicating-a-box","page":"boxes","title":"replicating a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For simulations in larger volumes than a single crystallograhic unit cell, the Box may be replicated along each or any of the three crystallographic axes.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"replicated_box = replicate(box, (2,2,2))\n# output\nBravais unit cell of a crystal.\n\tUnit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 120.000113 deg.\n\tUnit cell dimensions a = 52.263400 Å. b = 52.263422 Å, c = 13.444060 Å\n\tVolume of unit cell: 31802.120923 Å³","category":"page"},{"location":"box/#exporting-a-box","page":"boxes","title":"exporting a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For visualization of the unit cell boundaries, the Box may be written out to a .vtk file for use in Visit","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"write_vtk(box, \"box.vtk\")\n# output\n","category":"page"},{"location":"box/#detailed-docs","page":"boxes","title":"detailed docs","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"    Box\n    unit_cube\n    replicate\n    write_vtk\n    Frac","category":"page"},{"location":"gcmc/#Grand-canonical-Monte-Carlo-Simulations","page":"grand-canonical Monte Carlo simulations","title":"Grand-canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Simulate the adsorption of CO_2 in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"xtal = Crystal(\"FIQCEN_clean.cif\") # load a crystal structure\nstrip_numbers_from_atom_labels!(xtal) # clean up the atom labels\nljforcefield = LJForceField(\"UFF\", r_cutoff=12.8) # load the UFF forcefield\nmolecule = Molecule(\"CO2\") # load the CO2 molecule\ntemperature = 298.0 # K\npressure = 1.0 # bar\n# conduct Grand-Canonical Monte Carlo simulation (VERY short, should use thousands of cycles!)\nresults, molecules = μVT_sim(xtal, molecule, temperature, pressure, ljforcefield,\n            n_burn_cycles=50, n_sample_cycles=50)","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Or, compute the entire adsorption isotherm at once, parallelized across many cores (this works by cleverly queuing a μVT_sim for each pressue across the specified number of cores for optimal efficiency):","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"pressures = [0.2, 0.6, 0.8, 1.0] # bar\n# loop over all pressures and compute entire adsorption isotherm in parallel\nresults = adsorption_isotherm(xtal, molecule, temperature, pressures, ljforcefield,\n            n_burn_cycles=50, n_sample_cycles=50)","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"results = stepwise_adsorption_isotherm(xtal, molecule, temperature, pressures, forcefield,\n               n_burn_cycles=50, n_sample_cycles=50)","category":"page"},{"location":"gcmc/#detailed-docs","page":"grand-canonical Monte Carlo simulations","title":"detailed docs","text":"","category":"section"},{"location":"gcmc/#Grand-Canonical-Monte-Carlo-Simulations","page":"grand-canonical Monte Carlo simulations","title":"Grand-Canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"    μVT_sim\n    adsorption_isotherm\n    stepwise_adsorption_isotherm\n    μVT_output_filename\n    isotherm_sim_results_to_dataframe","category":"page"},{"location":"gcmc/#PorousMaterials.μVT_sim","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.μVT_sim","text":"results, molecules = μVT_sim(xtal, molecule_templates, temperature, pressure,\n                             ljff; molecules=Array{Molecule, 1}[], settings=settings)\n\nRuns a grand-canonical (μVT) Monte Carlo simulation of the adsorption of a molecule in a xtal at a particular temperature and pressure using a Lennard Jones force field.\n\nMarkov chain Monte Carlo moves include:\n\ndeletion/insertion\ntranslation\nreinsertion\nidentity change (if multiple components) see here\n\nTranslation stepsize is dynamically updated during burn cycles so that acceptance rate of translations is ~0.4.\n\nA cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals.\n\nArguments\n\nxtal::Crystal: the porous xtal in which we seek to simulate adsorption\nmolecule_templates::Array{Molecule, 1}: an array of the templates of unique adsorbate molecules of which we seek to simulate\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\npressures::Array{Float64, 1}: pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material for each adsorbate. units: bar   the adsorption\nljff::LJForceField: the molecular model used to describe the\nmolecules::Array{Array{Molecule{Cart}, 1}, 1}: a starting configuration of molecules in the xtal with an array per species.\nn_cycles_per_volume::Int: the number of MC cycles per volume, split evenly between n_burn_cycles and 'n_sample_cycles, where   n_burn_cycles is the number of cycles to allow the system to reach equilibrium before sampling; and,   n_sample_cycles is the number of cycles used for sampling\nsample_frequency::Int: during the sampling cycles, sample e.g. the number of    adsorbed gas molecules every this number of Markov proposals\nverbose::Bool: whether or not to print off information during the simulation\newald_precision::Float64: desired precision for the long range Ewald summation\neos::Symbol: equation of state to use for calculation of fugacity from pressure\nwrite_adsorbate_snapshots::Bool: whether the simulation will create and save a snapshot file\nsnapshot_frequency::Int: the number of cycles taken between each snapshot (after burn cycle completion)\ncalculate_density_grid::Bool: whether the simulation will keep track of a density grid for adsorbates\ndensity_grid_dx::Float64: The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by required_n_pts.\ndensity_grid_molecular_species::Symbol: the adsorbate for which we will make a density grid of its position (center).\ndensity_grid_sim_box::Bool: true if we wish for the density grid to be over the \n\nentire simulation box as opposed to the box of the crystal passed in. false if we wish the density grid to be over the original xtal.box, before replication, passed in.\n\nautosave::Bool: true if we wish to automatically save the simulation results to the standard path/filename.\nresults_filename_comment::AbstractString: An optional comment that will be appended to the name of the saved file (if autosaved)\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.adsorption_isotherm","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.adsorption_isotherm","text":"results = adsorption_isotherm(xtal, molecule_templates, temperature, \n                              partial_pressures,\n                              ljff; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              density_grid_sim_box=true,\n                              results_filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in parallel. Arguments are the same as μVT_sim, as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures, and we only consider a single species. To give Julia access to multiple cores, run your script as julia -p 4 mysim.jl to allocate e.g. four cores. See Parallel Computing.\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.stepwise_adsorption_isotherm","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.stepwise_adsorption_isotherm","text":"results = stepwise_adsorption_isotherm(xtal, molecule_templates, temperature, pressures,\n                              ljff; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              density_grid_sim_box::Bool=true,\n                              results_filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in series. Arguments are the same as μVT_sim, as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of pressures is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see adsorption_isotherm which runs the μVT simulation at each pressure in parallel.\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.μVT_output_filename","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.μVT_output_filename","text":"filename = μVT_output_filename(xtal, molecule_templates, temperature, \n                               pressures, ljff, n_burn_cycles, \n                               n_sample_cycles; comment=\"\", extension=\".jld2\")\n\nThis is the function that establishes the file naming convention used by μVT_sim.\n\nArguments\n\nxtal::Crystal: porous xtal used in adsorption simulation\nmolecule_templates::Array{Molecule, 1}: template of the adsorbate molecules used in adsorption simulation\ntemperature::Float64:temperature of bulk gas phase in equilibrium with adsorbed phase in       the porous material. units: Kelvin (K) \npressures::Array{Float64, 1}: partial pressures of bulk gas phase in equilibrium with adsorbed phase in the       porous material. units: bar\nljff::LJForceField: the molecular model used in adsorption simulation\nn_burn_cycles::Int: number of cycles to allow the system to reach equilibrium before sampling.    \nn_sample_cycles::Int: number of cycles used for sampling\ncomment::String=\"\": remarks to be included in the filename\nextension::String=\".jld2\": the file extension\n\nReturns\n\nfilename::String: the name of the specific .jld2 simulation file\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.isotherm_sim_results_to_dataframe","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.isotherm_sim_results_to_dataframe","text":"dataframe = isotherm_sim_results_to_dataframe(desired_props, xtal,\n                                              molecule, temperature,\n                                              pressures, ljff,\n                                              n_burn_cycles, n_sample_cycles;\n                                              where_are_jld_files=nothing)`\n\nconvert the .jld2 results output files auto-saved from μVT_sim into a DataFrame. each row of the DataFrame corresponds to a pressure in the adsorption isotherm. desired_props is an array of desired properties from the results.  to locate the requested output files, this function calls μVT_output_filename to retrieve the file names.\n\nArguments\n\ndesired_props::Array{String, 1}: An array containing names of properties to be retrieved from the .jld2 file\nxtal::Crystal: The porous crystal\nmolecule::Array{Molecule{Cart}, 1}: The adsorbate molecule\ntemperature::Float64: The temperature in the simulation, units: Kelvin (K)\npressures::Array{Array{Float64, 1}, 1}: The pressures in the adsorption isotherm simulation(s), units: bar\nljff::LJForceField: The molecular model being used in the simulation to describe intermolecular Van       der Waals interactions\nn_burn_cycles::Int64: The number of burn cycles used in this simulation\nn_sample_cycles::Int64: The number of sample cycles used in the simulations\nwhere_are_jld_files::Union{String, Nothing}=nothing: The location to the simulation files. defaults to   PorousMaterials.rc[:paths][:simulations].\ncomment::String=\"\": comment appended to outputfilename\n\nReturns\n\ndataframe::DataFrame: A DataFrame containing the simulated data along the adsorption isotherm, whose   columns are for the specified properties\n\nNote\n\nA range of pressures can be used to select a batch of simulation files to be included in the DataFrame.\n\nExample\n\nxtal = Crystal(\"SBMOF-1.cif\")\nmolecule = Molecule(\"Xe\")\nljff = LJForceField(\"UFF\", mixing_rules=\"Lorentz-Berthelot\")\ntemperature = 298.0 # K\npressures = 10 .^ range(-2, stop=2, length=15)\n\ndataframe = isotherm_sim_results_to_dataframe([\"pressure (bar)\", \"⟨N⟩ (mmol/g)\"], \n                                              xtal, molecule, temperature,\n                                              pressures, ljff, 10000, 10000)\ndataframe[Symbol(\"pressure (bar)\")] # pressures\ndataframe[Symbol(\"⟨N⟩ (mmol/g)\")] # adsorption at corresponding pressures\n\n\n\n\n\n","category":"function"},{"location":"grid/","page":"grids","title":"grids","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"grid/#Potential-Energy-Grid","page":"grids","title":"Potential Energy Grid","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"PorousMaterials.jl allows us to calculate and store the ensemble average potential energy of a molecule inside a crystal. This is done by using the molecule as a probe to measure the potential energy on a grid of points superimposed on the unit cell of the crystal.","category":"page"},{"location":"grid/#Calculating-Potential-Energy-Grids","page":"grids","title":"Calculating Potential Energy Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"Superimpose a grid of points about the unit cell of SBMOF-1, compute the potential energy of xenon at each point, and store the data in a Grid object using energy_grid.","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"xtal = Crystal(\"SBMOF-1.cif\")\nstrip_numbers_from_atom_labels!(xtal)\nmolecule = Molecule(\"Xe\")\nljforcefield = LJForceField(\"UFF\")\ngrid = energy_grid(xtal, molecule, ljforcefield, \n                   resolution=0.5, units=:kJ_mol) \n# output\nComputing energy grid of Xe in SBMOF-1.cif\n\tRegular grid (in fractional space) of 25 by 13 by 47 points superimposed over the unit cell.\nRegular grid of 25 by 13 by 47 points superimposed over a unit cell and associated data.\n\tunits of data attribute: kJ_mol\n\torigin: [0.000000, 0.000000, 0.000000]","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"The Grid object has the following attributes:","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"grid.box      # Bravais lattice over which a grid of points is superimposed\ngrid.data     # 3 dim array containing data for each point\ngrid.n_pts    # number of grid points in x, y, z\ngrid.origin   # the origin of the grid\ngrid.units    # units associated with each data point","category":"page"},{"location":"grid/#Saving-and-Retrieving-Grids","page":"grids","title":"Saving and Retrieving Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"Write to a .cube volume file to visualize the potential energy contours. The output file location is determined by rc[:paths][:grids].","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"write_cube(grid, \"CH4_in_SBMOF1.cube\")","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"Likewise, we can read a .cube file to populate a Grid object:","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"filename = joinpath(rc[:paths][:grids], \"CH4_in_SBMOF1.cube\")\ngrid = read_cube(filename)","category":"page"},{"location":"grid/#detailed-docs","page":"grids","title":"detailed docs","text":"","category":"section"},{"location":"grid/#Grids","page":"grids","title":"Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"    Grid\n    energy_grid\n    write_cube\n    read_cube\n    required_n_pts\n    xf_to_id\n    id_to_xf\n    update_density!\n    compute_accessibility_grid\n    accessible","category":"page"},{"location":"grid/#PorousMaterials.Grid","page":"grids","title":"PorousMaterials.Grid","text":"Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (Box). Each grid point has data, data, associated with it, of type T, stored in a 3D array.\n\nAttributes\n\nbox::Box: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.\nn_pts::Tuple{Int, Int, Int}: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.\ndata::Array{T, 3}: three dimensional array conaining data associated with each grid point.\nunits::Symbol: the units associated with each data point.\norigin::Array{Float64, 1}: the origin of the grid.\n\n\n\n\n\n","category":"type"},{"location":"grid/#PorousMaterials.energy_grid","page":"grids","title":"PorousMaterials.energy_grid","text":"grid = energy_grid(crystal, molecule, ljforcefield; resolution=1.0, temperature=298.0, n_rotations=750)\n\nSuperimposes a regular grid of points (regularly spaced in fractional coordinates of the crystal.box) over the unit cell of a crystal, with n_gridpts dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.\n\nThe ensemble average is a Boltzmann average over rotations:  - R T log ⟨e⁻ᵇᵁ⟩\n\nArguments\n\ncrystal::Crystal: crystal in which we seek to compute an energy grid for a molecule. grid.box will be framework.box.\nmolecule::Molecule: molecule for which we seek an energy grid\nljforcefield::LJForceField: molecular model for computing molecule-crystal interactions\nresolution::Union{Float64, Tuple{Int, Int, Int}}=1.0: maximum distance between grid points, in Å, or a tuple specifying the number of grid points in each dimension.\nn_rotations::Int: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.\n\nThis is only relevant for molecules that are comprised of more than one Lennard Jones sphere.\n\ntemperature::Float64: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.\nunits::Symbol: either :K or :kJ_mol, the units in which the energy should be stored in the returned Grid.\ncenter::Bool: shift coords of grid so that the origin is the center of the unit cell crystal.box.\nverbose::Bool=true: print some information.\n\nReturns\n\ngrid::Grid: A grid data structure containing the potential energy of the system\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.write_cube","page":"grids","title":"PorousMaterials.write_cube","text":"write_cube(grid, filename, verbose=true)\n\nWrite grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.\n\nArguments\n\ngrid::Grid: grid with associated data at each grid point.\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to rc[:paths][:grids].\nverbose::Bool: print name of file after writing.\nlength_units::String: units for length. Bohr or Angstrom.\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.read_cube","page":"grids","title":"PorousMaterials.read_cube","text":"grid = read_cube(filename)\n\nRead a .cube file and return a populated Grid data structure.  It will detect and skip over atomic information if it is present in the file.\n\nArguments\n\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to rc[:paths][:grids]\nhas_units::Bool=true: flag for function to read units from file header\n\nReturns\n\ngrid::Grid: A grid data structure\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.required_n_pts","page":"grids","title":"PorousMaterials.required_n_pts","text":"n_pts = required_n_pts(box, dx)\n\nCalculate the required number of grid pts in a, b, c unit cell directions required to keep distances between grid points less than dx apart, where dx is in units of Angstrom.\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.xf_to_id","page":"grids","title":"PorousMaterials.xf_to_id","text":"voxel_id = xf_to_id(n_pts, xf)\n\nReturns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of n_pts[1] by n_pts[2] by n_pts[3] voxels. Periodic boundary conditions are applied.\n\nArguments\n\nn_pts::Tuple{Int, Int, Int}: The number of points for each axis in the Grid\nxf::Array{Float64, 1}: The fractional coordinates to be converted to an id\n\nReturns\n\nid::Array{Int, 1}: The array indices for storing this point in space\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.id_to_xf","page":"grids","title":"PorousMaterials.id_to_xf","text":"xf = id_to_xf(voxel_id, n_pts)\n\nGiven a voxel_id in a Grid, return the fractional coordinates to which this voxel corresponds.\n\nArguments\n\nn_pts::Tuple{Int, Int, Int}: The number of voxels along each axis in the Grid\nvoxel_id::Array{Int, 1}: the voxel coordinates in grid.data\n\nReturns\n\nxf::Array{Float64, 1}: The fractional coordinates corresponding to the grid voxel\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.update_density!","page":"grids","title":"PorousMaterials.update_density!","text":"update_density!(grid, molecule, species)\n\nupdates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a ./ = num_snapshots at the end of the GCMC simulation.\n\nArguments\n\ngrid::Grid: the grid to be updated\nmolecules::Array{Molecule, 1}: An array of molecules whose positions will  be added to the grid\nspecies::Symbol: The species of atom that can be added to this density grid\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.compute_accessibility_grid","page":"grids","title":"PorousMaterials.compute_accessibility_grid","text":"accessibility_grid, nb_segments_blocked, porosity = compute_accessibility_grid(crystal,\nprobe_molecule, ljforcefield; resolution::Union{Float64, Tuple{Int, Int, Int}}=1.0, energy_tol=10.0, energy_unit=:kJ_mol,\nverbose=true, write_b4_after_grids=false, block_inaccessible_pockets=true)\n\nOverlay a grid of points about the unit cell. Compute the potential energy of a probe molecule at each point. If the potential energy is less than energy_tol, the grid point is declared as accessible to an adsorbate; otherwise inaccessible.\n\nIf block_pockets is true: Then perform a flood fill algorithm to label disparate (unconnected) segments in the grid.\n\nThen build a graph whose vertices are the unconnected segments in the flood-filled grid and whose edges are the connections between the segments across the periodic boundary.\n\nThen find any simple cycles in the grid. Any vertex that is involved in a simple cycle is considered accessible since a molecule can travel from that segment in the home unit cell to the same segment but in a different unit cell. If any vertex is not involved in a cycle, the segment is declared as inaccessible and all grid points in this segment are re-labeled as inaccessible.\n\nReturns accessibility_grid::Grid{Bool} and nb_segments_blocked, the latter the number of segments that were blocked because they were determined to be inaccessible.\n\nArguments\n\ncrystal::Crystal: the crystal for which we seek to compute an accessibility grid.\nprobe_molecule::Molecule a molecule serving as a probe to determine whether a given\n\npoint can be occupied and accessed.\n\nLJForceField::LJForceField: the force field used to compute the potential energy of\n\nthe probe molecule\n\nresolution::Union{Float64, Tuple{Int, Int, Int}}=1.0: maximum distance between grid points, in Å, or a tuple specifying the number of grid points in each dimension.\nenergy_tol::Float64: if the computed potential energy is less than this, we declare the\n\ngrid point to be occupiable. Also this is the energy barrier beyond which we assume the probe adsorbate cannot pass. Units given by energy_units argument\n\nenergy_units::Symbol: units of energy (:kJ_mol or :K) to be used in determining\n\nthreshold for occupiability and whether molecule can percolate over barrier in channel. (see energy_tol)\n\nwrite_b4_after_grids::Bool: write a .cube file of occupiability for visualization both\n\nbefore and after flood fill/blocking inaccessible pockets\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.accessible","page":"grids","title":"PorousMaterials.accessible","text":"accessible(accessibility_grid, xf)\naccessible(accessibility_grid, xf, repfactors)\n\nUsing accessibility_grid, determine if fractional coordinate xf (relative to accessibility_grid.box is accessible or not. Here, we search for the nearest grid point. We then look at the accessibility of this nearest grid point and all surroudning 9 other grid points. The point xf is declared inaccessible if and only if all 10 of these grid points are inaccessible. We take this approach because, if the grid is coarse, we can allow energy computations to automatically determine accessibility at the boundary of accessibility e.g. during a molecular simulation where inaccessible pockets are blocked.\n\nIf a tuple of replication factors are also passed, it is assumed that the passed xf is relative to a replicated accessibility_grid.box so that xf is scaled by these rep. factors. So xf = [0.5, 0.25, 0.1] with repfactors=(1, 2, 4) actually is, relative to accessibility_grid.box, fractional coordinate [0.5, 0.5, 0.4].\n\n\n\n\n\n","category":"function"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"(Image: PorousMaterials.jl) A pure-Julia package for classical molecular modeling of adsorption in porous crystals such as metal-organic frameworks (MOFs).","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the potential energy of a molecule at particular position and orientation inside of a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Write a potential energy grid of a molecule inside a porous material to visualize binding sites","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the Henry coefficient of a gas in a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Run grand-canonical Monte Carlo simulations of gas adsorption in a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Designed for high-throughput computations to minimize input files and querying results from output files. User-friendly. Instructive error messages thrown when they should be. Well-documented. Easy to install.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In development, please contribute, post issues 🐛, and improve!","category":"page"},{"location":"#Installation","page":"PorousMaterials","title":"Installation","text":"","category":"section"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Download and install the Julia programming language, v1.5 or higher.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, open the package manager (using ]) and enter the following:","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"pkg> add PorousMaterials","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, load all functions in PorousMaterials.jl into the namespace:","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"julia> using PorousMaterials # that's it","category":"page"},{"location":"#Tests","page":"PorousMaterials","title":"Tests","text":"","category":"section"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Run the tests in the script tests/runtests.jl manually or by ] test PorousMaterials in the Julia REPL.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and must be run separately; they are found in tests/henry.jl and tests/gcmc_long.jl.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"DocTestSetup = quote\n  using PorousMaterials\nend","category":"page"},{"location":"crystal/#Crystals","page":"crystals","title":"Crystals","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"PorousMaterials.jl maintains a data structure Crystal that stores information about a crystal structure file.","category":"page"},{"location":"crystal/#reading-in-a-crystal-structure-file","page":"crystals","title":"reading in a crystal structure file","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Currently, the crystal structure file reader accepts .cif and .cssr file formats. PorousMaterials.jl looks for the crystal structure files in rc[:paths][:crystals] which is by default ./data/crystals. By typing rc[:paths][:crystals] = \"my_crystal_dir\", PorousMaterials.jl now looks for the crystal structure file in my_crystal_dir. The files can be read as:","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal = Crystal(\"SBMOF-1.cif\")       # The crystal reader stores the information in xtal\nxtal.name                           # The name of the crystal structure file\nxtal.box                            # The unit cell information\nxtal.atoms                          # The atom coordinates (in fractional space) and the atom identities\nxtal.charges                        # The charge magnitude and coordinates (in fractional space)\nxtal.bonds                          # Bonding information in the structure. By default this is an empty graph,\n                                    #  but use `read_bonds_from_file=true` argument in `Crystal` to read from crystal structure file\nxtal.symmetry                       # Symmetry information of the crystal. By default converts the symmetry to P1 symmetry.\n                                    #  Use `convert_to_p1=false` argument in `Crystal` to keep original symmetry","category":"page"},{"location":"crystal/#fixing-atom-species","page":"crystals","title":"fixing atom species","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Often, the atoms species are appended by numbers. This messes with the internal workings of PorousMaterials.jl. To circumvent this problem, the function strip_numbers_from_atom_labels!(xtal) removes the appending numbers. It is important to use this function prior to GCMC or Henry coefficient calculations.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"strip_numbers_from_atom_labels!(xtal)\n\n# output","category":"page"},{"location":"crystal/#converting-the-coordinates-to-cartesian-space","page":"crystals","title":"converting the coordinates to cartesian space","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"The coordinates of the crystals are stored in fractional coordinates. If one needs to analyze the cartesian coordinates of the crystal, that can be done by using the unit cell information of the crystal.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal.atoms.coords.xf                                    # array of fractional coordinates\ncart_coords = xtal.box.f_to_c * xtal.atoms.coords.xf    # array of cartesian coordinates\n# output\n3×120 Matrix{Float64}:\n 4.59487  -0.95272   2.68943   8.23701  …  8.8164    0.839249  -1.53211\n 1.43955   4.2229    4.12715   1.3438      1.35443   1.42892    4.21227\n 5.89964   5.35922  16.6181   17.1585      6.27862  17.5375    16.2391","category":"page"},{"location":"crystal/#creating-a-super-cell","page":"crystals","title":"creating a super cell","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"For many simulations, one needs to replicate the unit cell multiple times to create a bigger super cell.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"super_xtal = replicate(xtal, (2,2,2))       # Replicates the original unit cell once in each dimension\n# output\nName: SBMOF-1.cif\nBravais unit cell of a crystal.\n\tUnit cell angles α = 90.000000 deg. β = 100.897000 deg. γ = 90.000000 deg.\n\tUnit cell dimensions a = 23.238600 Å. b = 11.133400 Å, c = 45.862400 Å\n\tVolume of unit cell: 11651.776815 Å³\n\n\t# atoms = 960\n\t# charges = 960\n\tchemical formula: Ca₃₂C₄₄₈H₂₅₆O₁₉₂S₃₂\n\tspace Group: P1\n\tsymmetry Operations:\n\t\t'x, y, z'\n\tbonding graph:\n\t\t# vertices = 960\n\t\t# edges = 0","category":"page"},{"location":"crystal/#finding-other-properties","page":"crystals","title":"finding other properties","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"rho = crystal_density(xtal)         # Crystal density of the crystal in kg/m^2\nmw = molecular_weight(xtal)         # The molecular weight of the unit cell in amu\nformula = chemical_formula(xtal)    # The irreducible chemical formula of the crystal","category":"page"},{"location":"crystal/#assigning-new-charges","page":"crystals","title":"assigning new charges","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"If the crystal structure file does not contains partial charges, we provide methods to assign new charges to the crystal","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"species_to_charges = Dict(:Ca => 2.0, :C => 1.0, :H => -1.0)                # This method assigns a static charge to atom species\ncharged_xtal = assign_charges(xtal, species_to_charges, 1e-5)                # This function creates a new charged `Crystal` object.\n                                                                            #   The function checks for charge neutrality with a tolerance of 1e-5\nnew_charges = Charges([2.0, 1.0, -1.0, -1.0, ...], xtal.atoms.coords)\nother_charged_xtal = Crystal(xtal.name, xtal.box, xtal.atoms,               # Here we create a new `Charges` object using an array of new charges.\n                             new_charges, xtal.bonds, xtal.symmetry)        #   The number of charges in the array has to be equal to the number of atoms\n                                                                            #   and finally a new `Crystal` object is manually created","category":"page"},{"location":"crystal/#writing-crystal-files","page":"crystals","title":"writing crystal files","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"We provide methods to write both .xyz and .cif files","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"write_cif(xtal, \"my_new_cif_file.cif\")      # Stored in the current directory\nwrite_xyz(xtal, \"my_new_xyz_file.xyz\")      # stored in the current directory","category":"page"},{"location":"crystal/#detailed-docs","page":"crystals","title":"detailed docs","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"    Crystal\n    SymmetryInfo\n    replicate\n    molecular_weight\n    crystal_density\n    chemical_formula\n    assign_charges\n    write_cif\n    write_xyz","category":"page"},{"location":"crystal/#Xtals.write_xyz","page":"crystals","title":"Xtals.write_xyz","text":"write_xyz(box, molecules, xyz_file)\n\nWrites the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end.\n\nThis writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion.\n\nArguments\n\nbox::Box: The box the molecules are in, to convert molecule positions      to cartesian coordinates\nmolecules::Array{Array{Molecule{Frac}, 1}, 1}: The array containing arrays of molecules, separated by species, to be written to the file\nxyz_file::IOStream: The open 'write' file stream the data will be saved to\n\n\n\n\n\n","category":"function"}]
}
