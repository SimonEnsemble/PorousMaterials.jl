var documenterSearchIndex = {"docs":
[{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"Matter is the foundation for every data type defined in PorousMaterials. Two structs are used to define all atomic structures: Atoms and Charges. Every atom, molecule, or crystal structure can be simulated by understanding its atoms and its point charges.","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"We chose to store each collection as a single object (Atoms) rather than an array of objects (Array{Atom}) because it allows us to store the locations in contiguous memory. We found significant speed increases when storing each collection as a single object.","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"One array of locations also allowed us to take advantage of broadcasting. For example, it is useful when calculating the energy inside a framework. Instead of looping through every atom, we can instead run this line:","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"dxf = broadcast(-, framework.atoms.xf, molecule.atoms.xf[i])","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"This calculates the distance between one atom in a molecule and every atom in the framework.","category":"page"},{"location":"manual/matter/#Building-Blocks-of-PorousMaterials:-Matter-1","page":"Matter","title":"Building Blocks of PorousMaterials: Matter","text":"","category":"section"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"In PorousMaterials.jl, crystals and molecules are composed of Atoms and Charges","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"To create a carbon atom at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice):","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"xf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\natoms = Atoms([:C], xf) # constructor\natoms.species[1] # :C\natoms.xf[:, 1] # [0.1, 0.2, 0.5]","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"To create a point charge of +1 at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice):","category":"page"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"xf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\ncharges = Charges([1.0], xf)\ncharges.q[1] # 1.0\ncharges.xf[:, 1] # [0.1, 0.2, 0.5]","category":"page"},{"location":"manual/matter/#Matter-1","page":"Matter","title":"Matter","text":"","category":"section"},{"location":"manual/matter/#","page":"Matter","title":"Matter","text":"    Atoms\n    Charges","category":"page"},{"location":"manual/matter/#PorousMaterials.Atoms","page":"Matter","title":"PorousMaterials.Atoms","text":"Data structure holds a set of atom species and their positions in fractional coordinates.\n\nFractional coords of atom i is charges.xf[:, i].\n\nExample use\n\natoms = Atoms(2, [:C, :F], [0.0 1.0; 2.0 3.0; 4.0 5.0])\n\nAttributes\n\nn_atoms::Int: number of atoms\nspecies::Array{Symbol, 1}: atom species\nxf::Array{Float64, 2}: fractional coordinates in the columns\n\n\n\n\n\n","category":"type"},{"location":"manual/matter/#PorousMaterials.Charges","page":"Matter","title":"PorousMaterials.Charges","text":"Data structure holds a set of point charges and their positions in fractional coordinates.\n\nFractional coords of charge i is charges.xf[:, i].\n\nExample use\n\ncharges = Charges(2, [-1.0, 1.0], [0.0 1.0; 2.0 3.0; 4.0 5.0])\n\nAttributes\n\nn_charges::Int: number of charges\nq::Array{Float64, 1}: signed magnitude of charges (units: electrons)\nxf::Array{Float64, 2}: fractional coordinates in the columns\n\n\n\n\n\n","category":"type"},{"location":"guides/help_wanted/#Help-wanted-and-needed-1","page":"Help Wanted","title":"Help wanted and needed","text":"","category":"section"},{"location":"guides/help_wanted/#","page":"Help Wanted","title":"Help Wanted","text":"the speed of a GCMC or Henry simulation is determined primarily by how fast PorousMaterials.jl can compute the electrostatic and vdw potential energy. Some core functions that can speed up this are:\nnearest_image! in src/NearestImage.jl\nEwald sums in src/Electrostatics.jl. (electrostatics are a huge bottleneck.)\nsrc/VdWEnergetics.jl\nThe scripts test/vdw_timing.jl and test/ewald_timing.jl time the functions for benchmarking.","category":"page"},{"location":"guides/help_wanted/#","page":"Help Wanted","title":"Help Wanted","text":"consolidate eikar, eikbr, eikcr somehow without slowing down the Ewald sum.\nmore tests added to tests/runtests.jl, tests/henry_tests.jl, tests/gcmc_tests.jl\ngeometric-based pore size calculations (largest free and included spheres), surface area, and porosity calculations that take Framework's as input\n~~handle .cif's without P1 symmetry. i.e. convert any .cif to P1 symmetry~~\nextend gcmc_simulation to handle mixtures\nbetter default rules for choosing Ewald sum parameters? alpha, kvectors required...\nHenry coefficient code prints off Ewald sum params 5 times if run with one core...\nset good defaults for gcmc_simulation probabilities (as now) but also allow user to change through default arguments to the function\nautomatically adjust the translation step δ in gcmc_simulation during burn cycles to have 50% acceptance of translation moves (online gradient descent?)\nEQEq or other charge equilibration schemes for assinging charges, taking a Framework as input.","category":"page"},{"location":"manual/boxes_crystals_grids/#Loading-in-Crystal-Structure-Files-1","page":"Boxes, Crystals, and Grids","title":"Loading in Crystal Structure Files","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"Place .cif and .cssr crystal structure files in PorousMaterials.PATH_To_CRYSTALS. PorousMaterials.jl can load in .cif files of any symmetry as long as the symmetry operations are included. From here you can start julia and do the following to load a framework and start working with it.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"using PorousMaterials\n\nf = Framework(\"SBMOF-1.cif\")","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"PorousMaterials will then output information about the framework you just loaded:","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"Name: SBMOF-1.cif\nBravais unit cell of a crystal.\n        Unit cell angles α = 90.000000 deg. β = 100.897000 deg. γ = 90.000000 deg.\n        Unit cell dimensions a = 11.619300 Å. b = 5.566700 Å, c = 22.931200 Å\n        Volume of unit cell: 1456.472102 Å³\n\nNumber of atoms = 120\nNumber of charges = 0\nChemical formula: Dict(:H=>8,:S=>1,:Ca=>1,:O=>6,:C=>14)","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"If the file is not in P1 symmetry, it will be converted within the framework reader and this message will be displayed.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"┌ Warning: Name_of_file.cif is not in P1 symmetry. It is being converted to P1 for use in PorousMaterials.jl.\n└ @ PorousMaterials ~/osu_undergrad/simon_ensemble/PorousMaterials.jl/src/Crystal.jl:284","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"PorousMaterials also gives the option to read in structures in the lower level symmetries and convert them to P1 before simulation.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"framework = Framework(\"ORIVOC_clean.cif\"; remove_overlap=true, convert_to_p1=false)\n# the remove_overlap argument is specific to this structure, not all frameworks need it\n\n###\n    Perform any operation on the structure while it is not in P1\n###\n\nframework = apply_symmetry_rules(framework)\n# the framework is now in P1 and it can be used in simulations","category":"page"},{"location":"manual/boxes_crystals_grids/#Generating-Bond-Information-for-Frameworks-1","page":"Boxes, Crystals, and Grids","title":"Generating Bond Information for Frameworks","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"The bonds are stored in a SimpleGraph from the LightGraphs.jl package, and can be accessed through the bonds attribute.  ","category":"page"},{"location":"manual/boxes_crystals_grids/#Reading-from-a-file-1","page":"Boxes, Crystals, and Grids","title":"Reading from a file","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"PorousMaterials can read in bonds from .cif files if they have the tags _geom_bond_atom_site_label_1 and _geom_bond_atom_site_label_2. To choose to read bonds from a file, pass read_bonds_from_file=true to the Framework constructor.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"using PorousMaterials\n\nf = Framework(\"KAXQIL_clean.cif\"; read_bonds_from_file=true, convert_to_p1=false)\n\nf.bonds","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"This example uses a structure that is not in P1 symmetry. PorousMaterials cannot replicate a structure or apply symmetry rules if it currently has bonds. However, this structure can be converted to P1 without bonds, and then bonds can be inferred for the full P1 structure.","category":"page"},{"location":"manual/boxes_crystals_grids/#Inferring-bonds-using-BondingRules-1","page":"Boxes, Crystals, and Grids","title":"Inferring bonds using BondingRules","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"PorousMaterials can infer bonds for a structure and populate the bond graph by using BondingRules. Each BondingRule has two species of atoms that it works for. It also has a minimum and maximum distance that a bond can be defined for the two atoms.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"using PorousMaterials\n\nf = Framework(\"SBMOF-1.cif\")\n\n# define an array of BondingRule's that will be used to define bonds in the\n#   framework. These need to be in the order that they are applied\nbonding_rules = [BondingRule(:H, :*, 0.4, 1.2),\n                 BondingRule(:*, :*, 0.4, 1.9)]\n\n# Alternatively, you could get the above bonding rules with the following command\nbonding_rules = default_bondingrules()\n\n# infer the bonds for the framework f with bonds across periodic boundaries\ninfer_bonds!(f, true, bonding_rules)\n\n# redefine bonding_rules to account for edge cases between Ca and O atoms. `pushfirst!` adds the newly\n#   defined Bondingrule to the front of `bonding_rules`\npushfirst!(BondingRule(:Ca, :O, 0.4, 2.5), bonding_rules)\n\n# remove old bonds from framework before inferring bonds with new rules\nremove_bonds!(f)\n\n# re-infer bonds\ninfer_bonds!(f, true, bonding_rules)\n\n# output the bond information to visualize it and double check\nwrite_bond_information(f, \"SBMOF-1_bonds.vtk\")\n\n# run sanity checks\nbond_sanity_check(framework)","category":"page"},{"location":"manual/boxes_crystals_grids/#Building-Blocks-of-PorousMaterials:-Bravais-lattice-1","page":"Boxes, Crystals, and Grids","title":"Building Blocks of PorousMaterials: Bravais lattice","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"We later apply periodic boundary conditions to mimic a crystal of infinite extent. A Box describes a Bravais lattice.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"To make a 10 by 10 by 10 Å Bravais lattice with right angles:","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"box = Box(10.0, 10.0, 10.0, π/2, π/2, π/2)\n\nbox.a, box.b, box.c # unit cell dimensions (10.0 Å)\nbox.α, box.β, box.γ # unit cell angles (1.57... radians)\nbox.Ω # volume (1000.0 Å³)\nbox.f_to_c # fractional to Cartesian coordinate transformation matrix\nbox.c_to_f # Cartesian to fractional coordinate transformation matrix\nbox.reciprocal_lattice # rows are reciprocal lattice vectors","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"Replicate a box as follows:","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"box = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2\nbox.a # 20 Å","category":"page"},{"location":"manual/boxes_crystals_grids/#Building-Blocks-of-PorousMaterials:-Porous-Crystals-1","page":"Boxes, Crystals, and Grids","title":"Building Blocks of PorousMaterials: Porous Crystals","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"using PorousMaterials\n\n# read in xtal structure file\nframework = Framework(\"SBMOF-1.cif\")\n\n# access unit cell box\nframework.box\n\n# access Lennard-Jones spheres and point charges comprising the crystal\nframework.atoms\nframework.charges\n\n# remove annoying numbers on the atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# compute crystal density\nρ = crystal_density(framework) # kg/m3\n\n# compute the chemical formula\ncf = chemical_formula(framework)\n\n# assign charges according to atom type\ncharges = Dict(:Ca => 3.0, :O => 2.0, :C => -1.0, :S => 7.0, :H => -1.0)\ncharged_framework = assign_charges(framework, charges)\n\n# replicate & visualize\nframework = replicate(framework, (3, 3, 3))\nwrite_to_xyz(framework, \"SBMOF-1.xyz\")","category":"page"},{"location":"manual/boxes_crystals_grids/#Demo-of-Potential-Energy-Grid-1","page":"Boxes, Crystals, and Grids","title":"Demo of Potential Energy Grid","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"Superimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"using PorousMaterials\n\nframework = Framework(\"SBMOF-1.cif\")\nmolecule = Molecule(\"Xe\")\nforcefield = LJForceField(\"UFF.csv\")\n\ngrid = energy_grid(framework, molecule, forcefield,\n    n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"Write to a .cube volume file to visualize the potential energy contours.","category":"page"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"write_cube(grid, \"CH4_in_SBMOF1.cube\")","category":"page"},{"location":"manual/boxes_crystals_grids/#Boxes-1","page":"Boxes, Crystals, and Grids","title":"Boxes","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"    Box\n    replicate\n    UnitCube\n    write_vtk\n    inside","category":"page"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.Box","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.Box","text":"box = Box(a, b, c, α, β, γ, volume, f_to_c, c_to_f, reciprocal_lattice)\nbox = Box(a, b, c, α, β, γ)\nbox = Box(a, b, c) # α=β=γ=π/2 assumed.\nbox = Box(f_to_c)\n\nData structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.\n\nAttributes\n\na,b,c::Float64: unit cell dimensions (units: Angstroms)\nα,β,γ::Float64: unit cell angles (units: radians)\nΩ::Float64: volume of the unit cell (units: cubic Angtroms)\nf_to_c::Array{Float64,2}: the 3x3 transformation matrix used to map fractional\n\ncoordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom\n\nc_to_f::Array{Float64,2}: the 3x3 transformation matrix used to map Cartesian\n\ncoordinates to fractional coordinates. units: inverse Angstrom\n\nreciprocal_lattice::Array{Float64, 2}: the rows are the reciprocal lattice vectors.\n\nThis choice was made (instead of columns) for speed of Ewald Sums.\n\n\n\n\n\n","category":"type"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.replicate","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.replicate","text":"new_box = replicate(original_box, repfactors)\n\nReplicates a Box in positive directions to construct a new Box representing a supercell. The original_box is replicated according to the factors in repfactors. Note replicate(original_box, repfactors=(1, 1, 1)) returns same Box. The new fractional coordinates as described by f_to_c and c_to_f still ∈ [0, 1].\n\nArguments\n\noriginal_box::Box: The box that you want to replicate\nrepfactors::Tuple{Int, Int, Int}: The factor you want to replicate the box by\n\nReturns\n\nbox::Box: Fully formed Box object\n\n\n\n\n\nreplicated_frame = replicate(framework, repfactors)\n\nReplicates the atoms and charges in a Framework in positive directions to construct a new Framework. Note replicate(framework, (1, 1, 1)) returns the same Framework.\n\nArguments\n\nframework::Framework: The framework to replicate\nrepfactors::Tuple{Int, Int, Int}: The factors by which to replicate the crystal structure in each direction.\n\nReturns\n\nreplicated_frame::Framework: Replicated framework\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.UnitCube","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.UnitCube","text":"unit_cube = UnitCube()\n\nThis function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.write_vtk","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.write_vtk","text":"write_vtk(box, filename; verbose=true, center_at_origin=false)\nwrite_vtk(framework)\n\nWrite a Box to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a Framework is passed, the Box of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.\n\nAppends \".vtk\" extension to filename automatically if not passed.\n\nArguments\n\nbox::Box: a Bravais lattice\nfilename::AbstractString: filename of the .vtk file output (absolute path)\nframework::Framework: A framework containing the crystal structure information\ncenter_at_origin::Bool: center box at origin if true. if false, the origin is the corner of the box.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.inside","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.inside","text":"inside_box = inside(x, box) # true or false\n\nDetermine whether a Cartesian vector x lays inside a Box. This works by computing the  fractional coordinates of vector x and ensuring each lie within the interval [0, 1].\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#Crystals-1","page":"Boxes, Crystals, and Grids","title":"Crystals","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"    Framework\n    remove_overlapping_atoms_and_charges\n    strip_numbers_from_atom_labels!\n    wrap_atoms_to_unit_cell\n    chemical_formula\n    molecular_weight\n    crystal_density\n    replicate(::Framework, ::Tuple{Int, Int, Int})\n    charged(::Framework; ::Bool)\n    assign_charges\n    apply_symmetry_rules\n    is_symmetry_equal\n    write_cif\n    BondingRule\n    write_bond_information\n    infer_bonds!\n    remove_bonds!\n    compare_bonds_in_framework\n    default_bondingrules","category":"page"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.Framework","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.Framework","text":"framework = Framework(filename, check_charge_neutrality=true,\n                      net_charge_tol=0.001, check_atom_and_charge_overlap=true,\n                      remove_overlap=false, convert_to_p1=true,\n                      read_bonds_from_file=false, wrap_to_unit_cell=true,\n                      include_zero_charges=false)\nframework = Framework(name, box, atoms, charges; bonds=SimpleGraph(atoms.n_atoms),\n                      symmetry=[\"x\", \"y\", \"z\"], space_group=\"P1\", is_p1=true)\n\nRead a crystal structure file (.cif or .cssr) and populate a Framework data structure, or construct a Framework data structure directly.\n\nIf the framework is constructed using the Framework(name, box, atoms, charges) function it is assumed it is in P1 symmetry.\n\nArguments\n\nfilename::AbstractString: the name of the crystal structure file (include \".cif\" or \".cssr\") read from PATH_TO_CRYSTALS.\ncheck_charge_neutrality::Bool: check for charge neutrality\nnet_charge_tol::Float64: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.\ncheck_atom_and_charge_overlap::Bool: throw an error if overlapping atoms are detected.\nremove_overlap::Bool: remove identical atoms automatically. Identical atoms are the same element atoms which overlap.\nconvert_to_p1::Bool: If the structure is not in P1 it will be converted to   P1 symmetry using the symmetry rules from the _symmetry_equiv_pos_as_xyz list in the .cif file.    (We do not use the space groups name to look up symmetry rules).\nread_bonds_from_file::Bool: Whether or not to read bonding information from   cif file. If false, the bonds can be inferred later. note that, if the crystal is not in P1 symmetry, we cannot both read bonds and convert to P1 symmetry.\nwrap_to_unit_cell::Bool: if true, enforce that fractional coords of atoms/charges are in [0,1]³ by mod(x, 1)\ninclude_zero_charges::Bool: if false, do not include in framework.charges atoms which have zero charges, in order to speed up the electrostatic calculations.   If true, include the atoms in framework.charges that have zero charge, ensuring that the number of atoms is equal to the number of charges and that framework.charges.xf and framework.atoms.xf` are the same.\n\nReturns\n\nframework::Framework: A framework containing the crystal structure information\n\nAttributes\n\nname::AbstractString: name of crystal structure\nbox::Box: unit cell (Bravais Lattice)\natoms::Atoms: list of Atoms in crystal unit cell\ncharges::Charges: list of point charges in crystal unit cell\nbonds::SimpleGraph: Unweighted, undirected graph showing all of the atoms   that are bonded within the framework\nsymmetry::Array{Function, 2}: 2D array of anonymous functions that represent   the symmetry operations. If the structure is in P1 there will be one   symmetry operation.\nspace_group::AbstractString: The name of the space group. This is stored   so that it can be written out again in the write_cif function. The space   group is not used to verify the symmetry rules.\nis_p1::Bool: Stores whether the framework is currently in P1 symmetry. Prior   to GCMC and Widom insertion simulations this is checked.\nwrap_to_unit_cell::Bool: Whether the atom and charge positions will be   wrapped to the unit cell so their coordinates are in [0, 1]\n\n\n\n\n\n","category":"type"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.remove_overlapping_atoms_and_charges","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.remove_overlapping_atoms_and_charges","text":"new_framework = remove_overlapping_atoms_and_charges(framework, atom_overlap_tol=0.1, \n                                                    charge_overlap_tol=0.1, verbose=true)\n\nTakes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical.\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\natom_overlap_tol::Float64: The minimum distance between two atoms that is tolerated\ncharge_overlap_tol::Float64: The minimum distance between two charges that is tolerated\nverbose::Bool: Will print out information regarding the function call\n\nReturns\n\nnew_framework::Framework: A new framework where identical atoms have been removed.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.strip_numbers_from_atom_labels!","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.strip_numbers_from_atom_labels!","text":"strip_numbers_from_atom_labels!(framework)\n\nStrip numbers from labels for framework.atoms. Precisely, for atom in framework.atoms, find the first number that appears in atom. Remove this number and all following characters from atom. e.g. C12 –> C \t Ba12A_3 –> Ba\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.chemical_formula","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.chemical_formula","text":"formula = chemical_formula(framework, verbose=false)\n\nFind the irreducible chemical formula of a crystal structure.\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\nverbose::Bool: If true, will print the chemical formula as well\n\nReturns\n\nformula::Dict{Symbol, Int}: A dictionary with the irreducible chemical formula of a crystal structure\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.molecular_weight","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.molecular_weight","text":"mass_of_framework = molecular_weight(framework)\n\nCalculates the molecular weight of a unit cell of the framework in amu using information stored in data/atomicmasses.csv.\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\n\nReturns\n\nmass_of_framework::Float64: The molecular weight of a unit cell of the framework in amu\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.crystal_density","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.crystal_density","text":"ρ = crystal_density(framework) # kg/m²\n\nCompute the crystal density of a framework. Pulls atomic masses from read_atomic_masses.\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\n\nReturns\n\nρ::Float64: The crystal density of a framework in kg/m³\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.replicate-Tuple{Framework,Tuple{Int64,Int64,Int64}}","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.replicate","text":"replicated_frame = replicate(framework, repfactors)\n\nReplicates the atoms and charges in a Framework in positive directions to construct a new Framework. Note replicate(framework, (1, 1, 1)) returns the same Framework.\n\nArguments\n\nframework::Framework: The framework to replicate\nrepfactors::Tuple{Int, Int, Int}: The factors by which to replicate the crystal structure in each direction.\n\nReturns\n\nreplicated_frame::Framework: Replicated framework\n\n\n\n\n\n","category":"method"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.charged-Tuple{Framework}","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.charged","text":"charged_flag = charged(framework, verbose=false) # true or false\n\nDetermine if a framework has point charges\n\n\n\n\n\n","category":"method"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.assign_charges","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.assign_charges","text":"new_framework = assign_charges(framework, charges, net_charge_tol=1e-5)\n\nAssign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of framework.atoms.\n\nIf the framework already has charges, the charges are removed and new charges are added accordingly so that framework.atoms.n_atoms == framework.charges.n_charges.\n\nExamples\n\ncharges = Dict(:Ca => 2.0, :C => 1.0, :H => -1.0)\nnew_framework = assign_charges(framework, charges)\n\ncharges = [4.0, 2.0, -6.0] # framework.atoms is length 3\nnew_framework = assign_charges(framework, charges)\n\nArguments\n\nframework::Framework: the framework to which we should add charges (not modified in\n\nthis function)\n\ncharges::Union{Dict{Symbol, Float64}, Array{Float64, 1}}: a dictionary that returns the\n\ncharge assigned to the species of atom or an array of charges to assign, with order consistent with the order in framework.atoms (units: electrons).\n\nnet_charge_tol::Float64: the net charge tolerated when asserting charge neutrality of\n\nthe resulting framework\n\nReturns\n\nnew_framework::Framework: a new framework identical to the one passed except charges\n\nare assigned.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.apply_symmetry_rules","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.apply_symmetry_rules","text":"simulation_ready_framework = apply_symmetry_rules(non_p1_framework;\n                                            check_charge_neutrality=true,\n                                            net_charge_tol=0.001,\n                                            check_atom_and_charge_overlap=true,\n                                            remove_overlap=false,\n                                            wrap_to_unit_cell=true)\n\nConvert a framework to P1 symmetry based on internal symmetry rules. This will return the new framework.\n\nArguments\n\nf::Framework: The framework to be converted to P1 symmetry\ncheck_charge_neutrality::Bool: check for charge neutrality\nnet_charge_tol::Float64: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.\ncheck_atom_and_charge_overlap::Bool: throw an error if overlapping atoms are detected.\nremove_overlap::Bool: remove identical atoms automatically. Identical atoms are the same element atoms which overlap.\nwrap_to_unit_cell::Bool: if true, enforce that fractional coords of atoms/charges are in [0,1]³ by mod(x, 1)\n\nReturns\n\nP1_framework::Framework: The framework after it has been converted to P1   symmetry. The new symmetry rules will be the P1 symmetry rules\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.is_symmetry_equal","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.is_symmetry_equal","text":"symmetry_equal = is_symmetry_equal(framework1.symmetry, framework2.symmetry)\n\nReturns true if both symmetry rules can create the same set from the same set of coordinates. Returns false if they don't contain the same number of rules or if they create different sets of points.\n\nArguments\n\nsym1::Array{AbstractString, 2}: Array of strings that represent   symmetry operations\nsym2::Array{AbstractString, 2}: Array of strings that represent   symmetry operations\n\nReturns\n\nis_equal::Bool: True if they are the same set of symmetry rules   False if they are different\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.write_cif","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.write_cif","text":"write_cif(framework, filename; fractional=true)\n\nWrite a framework::Framework to a .cif file with filename::AbstractString. If filename does not include the .cif extension, it will automatically be added.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.BondingRule","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.BondingRule","text":"bonding_rule = BondingRule(:Ca, :O, 0.4, 2.0)\nbonding_rules = [BondingRule(:H, :*, 0.4, 1.2),\n                 BondingRule(:*, :*, 0.4, 1.9)]\n\nA rule for determining if two atoms within a framework are bonded. \n\nAttributes\n\n-species_i::Symbol: One of the atoms types for this bond rule -species_j::Symbol: The other atom type for this bond rule -min_dist: The minimum distance between the atoms for bonding to occur -max_dist: The maximum distance between the atoms for bonding to occur\n\n\n\n\n\n","category":"type"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.write_bond_information","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.write_bond_information","text":"write_bond_information(framework, filename)\nwrite_bond_information(framework)\n\nWrites the bond information from a framework to the selected filename.\n\nArguments\n\n-framework::Framework: The framework to have its bonds written to a vtk file -filename::AbstractString: The filename the bond information will be saved to. If left out, will default to framework name.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.infer_bonds!","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.infer_bonds!","text":"infer_bonds!(framework, include_bonds_across_periodic_boundaries, \n                bonding_rules=[BondingRule(:H, :*, 0.4, 1.2), BondingRule(:*, :*, 0.4, 1.9)])\n\nPopulate the bonds in the framework object based on the bonding rules. If a pair doesn't have a suitable rule then they will not be considered bonded. \n\n:* is considered a wildcard and can be substituted for any species. It is a good idea to include a bonding rule between two :* to allow any atoms to bond as long as they are close enough.\n\nThe bonding rules are hierarchical, i.e. the first bonding rule takes precedence over the latter ones.\n\nArguments\n\n-framework::Framework: The framework that bonds will be added to -include_bonds_across_periodic_boundaries::Bool: Whether to check across the     periodic boundary when calculating bonds -bonding_rules::Array{BondingRule, 1}: The array of bonding rules that will     be used to fill the bonding information. They are applied in the order that     they appear.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.remove_bonds!","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.remove_bonds!","text":"remove_bonds!(framework)\n\nRemove all bonds from a framework structure.\n\nArguments\n\n-framework::Framework: the framework that bonds wil be removed from\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.compare_bonds_in_framework","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.compare_bonds_in_framework","text":"bonds_equal = compare_bonds_in_framework(framework1, framework2, atol=0.0)\n\nReturns whether the bonds defined in framework1 are the same as the bonds defined in framework2. It checks whether the atoms in the same positions have the same bonds.\n\nArguments\n\n-framework1::Framework: The first framework -framework2::Framework: The second framework -atol::Float64: absolute tolerance for the comparison of coordinates in the framework\n\nReturns\n\n-bonds_equal::Bool: Wether the bonds in framework1 and framework2 are equal\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.default_bondingrules","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.default_bondingrules","text":"default_bondingrules = default_bondingrules()\n\nReturns the default bonding rules. Using append! and/or prepend! to add to the default bonding rules:\n\nExample\n\nbond_rules = default_bondingrules()\nprepend!(bond_rules, BondingRule(:Cu, :*, 0.1, 2.6))\n\nReturns\n\n-default_bondingrules::Array{BondingRule, 1}: The default bonding rules: [BondingRule(:H, :*, 0.4, 1.2), BondingRule(:*, :*, 0.4, 1.9)]\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#Grids-1","page":"Boxes, Crystals, and Grids","title":"Grids","text":"","category":"section"},{"location":"manual/boxes_crystals_grids/#","page":"Boxes, Crystals, and Grids","title":"Boxes, Crystals, and Grids","text":"    Grid\n    xf_to_id\n    update_density!\n    apply_periodic_boundary_condition!\n    write_cube\n    read_cube\n    energy_grid","category":"page"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.Grid","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.Grid","text":"Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (Box). Each grid point has data, data, associated with it, of type T, stored in a 3D array.\n\nAttributes\n\nbox::Box: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.\nn_pts::Tuple{Int, Int, Int}: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.\ndata::Array{T, 3}: three dimensional array conaining data associated with each grid point.\nunits::Symbol: the units associated with each data point.\norigin::Array{Float64, 1}: the origin of the grid.\n\n\n\n\n\n","category":"type"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.xf_to_id","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.xf_to_id","text":"voxel_id = xf_to_id(n_pts, xf)\n\nReturns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of n_pts[1] by n_pts[2] by n_pts[3] voxels. Periodic boundary conditions are applied.\n\nArguments\n\nn_pts::Tuple{Int, Int, Int}: The number of points for each axis in the Grid\nxf::Array{Float64, 1}: The fractional coordinates to be converted to an id\n\nReturns\n\nid::Array{Int, 1}: The array indices for storing this point in space\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.update_density!","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.update_density!","text":"update_density!(grid, molecule, species)\n\nupdates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a ./ = num_snapshots at the end of the GCMC simulation.\n\nArguments\n\ngrid::Grid: the grid to be updated\nmolecules::Array{Molecule, 1}: An array of molecules whose positions will  be added to the grid\nspecies::Symbol: The species of atom that can be added to this density grid\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.apply_periodic_boundary_condition!","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.apply_periodic_boundary_condition!","text":"apply_periodic_boundary_condition!(molecule)\n\nCheck if the center_of_mass of a Molecule is outside of a Box. If so, apply periodic boundary conditions and translate the center of mass of the Molecule (and its atoms and point charges) so that it is inside of the Box.\n\nArguments\n\nmolecule::Molecule: A molecule we're interested in seeing if its' center of mass falls within simulation_box\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.write_cube","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.write_cube","text":"write_cube(grid, filename, verbose=true)\n\nWrite grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.\n\nArguments\n\ngrid::Grid: grid with associated data at each grid point.\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS.\nverbose::Bool: print name of file after writing.\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.read_cube","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.read_cube","text":"grid = read_cube(filename)\n\nRead a .cube file and return a populated Grid data structure.\n\nArguments\n\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS\n\nReturns\n\ngrid::Grid: A grid data structure\n\n\n\n\n\n","category":"function"},{"location":"manual/boxes_crystals_grids/#PorousMaterials.energy_grid","page":"Boxes, Crystals, and Grids","title":"PorousMaterials.energy_grid","text":"grid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750)\n\nSuperimposes a regular grid of points (regularly spaced in fractional coordinates of the framework.box) over the unit cell of a crystal, with n_gridpts dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.\n\nThe ensemble average is a Boltzmann average over rotations:  - R T log ⟨e⁻ᵇᵁ⟩\n\nArguments\n\nframework::Framework: crystal in which we seek to compute an energy grid for a molecule. grid.box will be framework.box.\nmolecule::Molecule: molecule for which we seek an energy grid\nljforcefield::LJForceField: molecular model for computing molecule-framework interactions\nn_pts::Tuple{Int, Int, Int}=(50,50,50): number of grid points in each fractional coordinate dimension, including endpoints (0, 1)\nn_rotations::Int: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.\n\nThis is only relevant for molecules that are comprised of more than one Lennard Jones sphere.\n\ntemperature::Float64: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.\nunits::Symbol: either :K or :kJ_mol, the units in which the energy should be stored in the returned Grid.\ncenter::Bool: shift coords of grid so that the origin is the center of the unit cell framework.box.\nverbose::Bool=true: print some information.\n\nReturns\n\ngrid::Grid: A grid data structure containing the potential energy of the system\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#","page":"Other","title":"Other","text":"PorousMaterials relies on functions that fall outside of the sections discussed up to this point. They are useful, but operate on their own for the most part.","category":"page"},{"location":"manual/other/#Control-over-directories-for-input-and-output-files-1","page":"Other","title":"Control over directories for input and output files","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"Call print_file_paths() to show where input/output files are read from/written to.","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"To change the directory where certain files are read from/output to, for example:","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"@eval PorousMaterials PATH_TO_CRYSTALS = joinpath(pwd(), \"my_xtals\")\n@eval PorousMaterials PATH_TO_FORCEFIELDS = joinpath(pwd(), \"my_ffs\")\n@eval PorousMaterials PATH_TO_GRIDS = joinpath(pwd(), \"my_grids\")\n@eval PorousMaterials PATH_TO_MOLECULES = joinpath(pwd(), \"my_molecules\")\n@eval PorousMaterials PATH_TO_DATA = pwd()","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"To use absolute file paths when reading in e.g. crystals via the Framework constructor, you can simply:","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"@eval PorousMaterials PATH_TO_CRYSTALS = \"\"","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"Call set_default_file_paths() to set input/output file paths back to default.","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"The PATH_TO_DATA is crucial for loading in data files. These functions allow the user to control this after they have done using PorousMaterials. The set_tutorial_mode() function has been discussed before, and it allows you to recreate our example and try PorousMaterials before loading your data. The other functions allow the user to reset the PATH_TO_DATA to the data folder in their current directory or to another directory on their machine if their files are stored in many places.","category":"page"},{"location":"manual/other/#Reading-in-Atomic-Values-1","page":"Other","title":"Reading in Atomic Values","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"These functions are used to read in the atomicmasses.csv, atom_properties.csv, and cpk_atom_colors.csv files from the current PATH_TO_DATA directory. They contain information on the masses, radii, and cpk color scheme for atoms.","category":"page"},{"location":"manual/other/#Using-.xyz-files-1","page":"Other","title":"Using .xyz files","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"These functions allow the user to load and save .xyz files describing where molecules appear in a given space. This can be used to save the location of molecules in the middle of a simulation or to visualize what is happening.","category":"page"},{"location":"manual/other/#Fitting-data-to-adsorption-models-1","page":"Other","title":"Fitting data to adsorption models","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"PorousMaterials allows for a DataFrame to be read in and fitted to a single-site Langmuir model or to a Henry's law model.","category":"page"},{"location":"manual/other/#","page":"Other","title":"Other","text":"using PorousMaterials\nusing DataFrames\n\nadsorption_data = DataFrame(Dict(\"Pressure (bar)\" => [0.008045, 0.042218, 0.078772, 0.108018, 0.156741, 0.312670, 0.414986, 0.517303, 0.619628, \n                                                      0.719519, 0.821872, 0.863296, 0.912055, 0.960878, 0.982918, 0.990353, 0.995361, 0.998043,\n                                                      1.000610, 1.005600, 1.005720],\n                                 \"Adsorption (mmol/g)\" => [4.062603, 4.462196, 4.560714, 4.659598, 4.707321, 4.950402, 5.045670, 5.140938,\n                                                           5.286339, 5.431875, 5.727768, 5.826027, 6.074420, 6.673929, 7.324955, 8.026830,\n                                                           8.778973, 10.133170, 10.835313, 11.487143, 12.189375]))\n# We can fit the adsorption data to a Langmuir isotherm with the following call. Note that we need to enter the column names for the pressure and adsorption.\nresults = fit_adsorption_isotherm(adsorption_data, Symbol(\"Pressure (bar)\"), Symbol(\"Adsorption (mmol/g)\"), :langmuir)\nM, K = results[\"M\"], results[\"K\"]\n\n# We can also use the function to get the Henry Coefficient\nresults = fit_adsorption_isotherm(adsorption_data, Symbol(\"Pressure (bar)\"), Symbol(\"Adsorption (mmol/g)\"), :henry)\nH = results[\"H\"]","category":"page"},{"location":"manual/other/#PATH_TO_DATA-Control-1","page":"Other","title":"PATH_TO_DATA Control","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"    print_file_paths\n    set_default_file_paths\n    set_tutorial_mode","category":"page"},{"location":"manual/other/#PorousMaterials.print_file_paths","page":"Other","title":"PorousMaterials.print_file_paths","text":"print_file_paths()\n\nPrint off paths where PorousMaterials.jl looks for input files and writes output files.\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#PorousMaterials.set_default_file_paths","page":"Other","title":"PorousMaterials.set_default_file_paths","text":"set_default_file_paths(print_paths=true)\n\nSets the default paths for where input files and some output files are stored. To see current set up, call print_file_paths\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#PorousMaterials.set_tutorial_mode","page":"Other","title":"PorousMaterials.set_tutorial_mode","text":"set_tutorial_mode()\n\nPlaces PorousMaterials in \"Tutorial Mode\". It changes the PATH_TO_DATA variable to the directory where the PorousMaterials test data is stored. It can be used to follow examples shown in the README. It displays a warning so that the user knows They are no longer using their own data.\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#Reading-in-Atomic-Values-2","page":"Other","title":"Reading in Atomic Values","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"    read_atomic_radii\n    read_atomic_masses\n    read_cpk_colors","category":"page"},{"location":"manual/other/#PorousMaterials.read_atomic_radii","page":"Other","title":"PorousMaterials.read_atomic_radii","text":"atomic_radii = read_atomic_radii()\n\nReturn atomic_radii::Dict{Symbol, Float64}, where atom_masses[\":C\"] gives the atomic radii of carbon (10.87 Angstrom).\n\nReturns\n\natomic_radii::Dict{Symbol, Float64}: A dictionary linking an element symbol to its' corresponding atomic radius\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#PorousMaterials.read_atomic_masses","page":"Other","title":"PorousMaterials.read_atomic_masses","text":"atomic_masses = read_atomic_masses()\n\nRead the data/atomicmasses.csv file to construct a dictionary of atoms and their atomic masses in amu.\n\nReturns\n\natomic_masses::Dict{Symbol, Float64}: A dictionary containing the atomic masses of each atom stored in data/atomicmasses.csv\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#PorousMaterials.read_cpk_colors","page":"Other","title":"PorousMaterials.read_cpk_colors","text":"atom_colors = read_cpk_colors()\n\nRead in CPK color scheme for atoms. Return atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} such that atom_colors[\":C\"] gives RGB code for carbon as a tuple, (144, 144, 144). https://en.wikipedia.org/wiki/CPK_coloring\n\nReturns\n\natom_colors::Dict{Symbol, Tuple{Int, Int, Int}}: A dictionary linking an element symbol to its' corresponding CPK color in RGB\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#Using-.xyz-files-2","page":"Other","title":"Using .xyz files","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"    read_xyz\n    write_xyz","category":"page"},{"location":"manual/other/#PorousMaterials.read_xyz","page":"Other","title":"PorousMaterials.read_xyz","text":"atoms, x = read_xyz(filename)\n\nReturn the list of atoms (Array{Symbol, 1}) and their Cartesian coordinates x::Array{Float64, 2} as stored in the .xyz file. x[:, k] will return Cartesian coords of the kth atom.\n\nArguments\n\nfilename::AbstractString: The filename of the .xyz file\n\nReturns\n\natoms::Array{Symbol, 1}: An array of atoms stored as symbols e.g. [:H, :H, :O] read\n\nfrom the .xyz file.\n\nx::Array{Float64, 2}: The Cartesian coordinates of the atoms. x[:, k] will return cartesian coordinates of the k-th atom\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#PorousMaterials.write_xyz","page":"Other","title":"PorousMaterials.write_xyz","text":"write_xyz(atoms, x, filename; comment=\"\")\nwrite_xyz(molecules, box, filename; comment=\"\")\nwrite_xyz(framework, filename; comment=\"\", center=false)\n\nWrite a molecule, framework, or array of atoms & positions to an .xyz file.\n\nArguments\n\natoms::Array{Symbol, 1}: An array of atoms stored as symbols e.g. [:H, :H, :O]\nx::Array{Float64, 2}: The Cartesian coordinates of the atoms.\n\nx[:, k] contains Cartesian coordinates of the k-th atom\n\nmolecules::Array{Molecule, 1}: an array of molecules whose atoms to write to .xyz\nframework::Framework: a crystal structure whose atoms to write to .xyz\nfilename::AbstractString: The filename of the .xyz file. (\".xyz\" appended automatically\n\nif the extension is not provided.) (absolute path)\n\ncomment::AbstractString: comment if you'd like to write to the file.\ncenter::Bool: shift atoms so that origin is the center of the framework.box\n\n\n\n\n\nwrite_xyz(box, molecules, xyz_file)\n\nWrites the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end.\n\nThis writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion.\n\nArguments\n\nbox::Box: The box the molecules are in, to convert molecule positions      to cartesian coordinates\nmolecules::Array{Molecule, 1}: The array of molecules to be written to the file\nxyz_file::IOStream: The open 'write' file stream the data will be saved to\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#Generic-Rotations-1","page":"Other","title":"Generic Rotations","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"    rotation_matrix","category":"page"},{"location":"manual/other/#PorousMaterials.rotation_matrix","page":"Other","title":"PorousMaterials.rotation_matrix","text":"r = rotation_matrix()\n\nGenerate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x, this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x). See James Arvo. Fast Random Rotation Matrices.\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\nReturns\n\nr::Array{Float64, 2}: A 3x3 random rotation matrix\n\n\n\n\n\nR = rotation_matrix(θ, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle θ about vector u\nR = rotation_matrix(θ, dim) # 3 by 3 rotation matrix, angle θ about axis `dim`\n\nDetermine the 3D rotation matrix to rotate an angle θ (radians) about axis u.\n\nSee Wikipedia.\n\nArguments\n\nθ::Float64: angle to rotate about an axis, in radians\nu::Array{Float64, 1}: axis about which to rotate\ndim::Int: 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.\nassume_unit_vector::Bool: assume u is a unit vector; otherwise, u will be normalized\n\ninternal to this function.\n\nReturns\n\nR::Array{Float64, 2}: 3D rotation matrix. so R * x will rotate vector x as desired.\n\n\n\n\n\n","category":"function"},{"location":"manual/other/#Fitting-data-1","page":"Other","title":"Fitting data","text":"","category":"section"},{"location":"manual/other/#","page":"Other","title":"Other","text":"    fit_adsorption_isotherm","category":"page"},{"location":"manual/other/#PorousMaterials.fit_adsorption_isotherm","page":"Other","title":"PorousMaterials.fit_adsorption_isotherm","text":"params = fit_adsorption_isotherm(df, pressure_col_name, loading_col_name, model)\n\nTakes in a DataFrame df containing adsorption isotherm data and fits an analytical model  to the data to identify its parameters of best fit, returned as a dictionary. Available models are :henry and :langmuir\n\nThe Henry model takes the following form: N = HP The identified Henry coefficient is params[\"H\"].\n\nThe Langmuir model takes the following form: N = (MKP)/(1+KP) where N is the total adsorption, M is the maximum monolayer coverage, K is the Langmuir constant. and P is the pressure of the gas.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the pressure and adsorption data for the isotherm\npressure_col_name::Symbol: The header of the pressure column. Can be found with names(df)\nloading_col_name::Symbol: The header of the loading/adsorption column. Can be found with names(df)\nmodel::Symbol: The model chosen to fit to the adsorption isotherm data\n\nReturns\n\nparams::Dict{AbstractString, Float64}: A Dictionary with the parameters corresponding to each model along with the MSE of the fit. :langmuir contains \"M\" and \"K\". :henry contains \"H\".\n\n\n\n\n\n","category":"function"},{"location":"guides/input_files/#Input-files-to-describe-crystals,-molecules,-and-forcefields-1","page":"Loading Data","title":"Input files to describe crystals, molecules, and forcefields","text":"","category":"section"},{"location":"guides/input_files/#","page":"Loading Data","title":"Loading Data","text":"All input files are stored in the path PorousMaterials.PATH_TO_DATA (type into Julia). By default, this path is set to be in the present working directory (type pwd() into Julia) in a folder data/. Go inside PorousMaterials.jl/test/data to see example input files for each case below.","category":"page"},{"location":"guides/input_files/#","page":"Loading Data","title":"Loading Data","text":"There will be example code snippets through the documentation showing how to load in various files. To get a feel for this we have included a Tutorial Mode in PorousMaterials.jl that sets the PorousMaterial.PATH_TO_DATA to the data folder in our testing directory. To follow along with the examples without downloading your own data simply do the following:","category":"page"},{"location":"guides/input_files/#","page":"Loading Data","title":"Loading Data","text":"using PorousMaterials\r\n\r\nset_tutorial_mode()\r\n    ┌ Warning: PorousMaterials is now in Tutorial Mode. You have access to the testing data to experiment with PorousMaterials.\r\n    │ To get access to your own data use: reset_path_to_data()\r\n    └ @ PorousMaterials ~/git_files/PorousMaterials.jl/src/PorousMaterials.jl:75","category":"page"},{"location":"guides/input_files/#Atomic-masses-1","page":"Loading Data","title":"Atomic masses","text":"","category":"section"},{"location":"guides/input_files/#","page":"Loading Data","title":"Loading Data","text":"Add fancy pseudo-atoms to data/atomic_masses.csv.","category":"page"},{"location":"guides/input_files/#Peng-Robinson-gas-parameters-1","page":"Loading Data","title":"Peng-Robinson gas parameters","text":"","category":"section"},{"location":"guides/input_files/#","page":"Loading Data","title":"Loading Data","text":"Critical temperatures and pressures and acentric factors are stored in data/PengRobinsonGasProps.csv.","category":"page"},{"location":"manual/atomic_interactions/#Loading-in-Forcefield-Files-1","page":"Atomic Interactions","title":"Loading in Forcefield Files","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"Lennard-Jones forcefield parameters are stored in comma-separated-value format in PorousMaterials.PATH_TO_FORCEFIELDS.","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"Interaction of an adsorbate with the framework is modeled as pair-wise additive and with Lennard-Jones potentials of the form:","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"V(r) = 4 * epsilon * [ x ^ 12 - x ^ 6 ], where x = sigma / r","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"The Lennard Jones force field input files, e.g. UFF.csv contain a list of pure (i.e. X-X, where X is an atom) sigmas and epsilons in units Angstrom and Kelvin, respectively. Note that, e.g., in the UFF paper, the Lennard Jones potential is written in a different form and thus parameters need to be converted to correspond to the functional form used in PorousMaterials.jl.","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"using PorousMaterials\r\n\r\nljff = LJForceField(\"UFF.csv\")","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"PorousMaterials will the output information about the forcefield file you just loaded:","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    Force field: UFF.csv\r\n    Number of atoms included: 106\r\n    Cut-off radius (Å) = 14.0    ","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"This also prints all of the atoms included in the loaded forcefield with their given ϵ and σ. This was excluded because it would use too much space on this page.","category":"page"},{"location":"manual/atomic_interactions/#Building-Blocks-of-PorousMaterials:-Lennard-Jones-forcefields-1","page":"Atomic Interactions","title":"Building Blocks of PorousMaterials: Lennard-Jones forcefields","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"# read in Lennard-Jones force field parameters from the Universal Force Field\r\nforcefield = LJForceField(\"UFF.csv\", cutoffradius=14.0, mixing_rules=\"Lorentz-Berthelot\")\r\n\r\n# access the Lennard-Jones epsilon & sigma for Xe\r\nforcefield.pure_ϵ[:Xe] # K\r\nforcefield.pure_σ[:Xe] # Å\r\n\r\n# access the Lennard-Jones epsilon & sigma for Xe-C interactions\r\nforcefield.ϵ[:Xe][:C] # K                                                                 \r\nforcefield.σ²[:Xe][:C] # Å (store σ² for faster computation)","category":"page"},{"location":"manual/atomic_interactions/#Building-Blocks-of-PorousMaterials:-Potential-energies-1","page":"Atomic Interactions","title":"Building Blocks of PorousMaterials: Potential energies","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"First, set the fractional coordinates of the molecule in the context of some unit cell box.","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"# molecule in a framework\r\nset_fractional_coords!(molecule, framework.box)\r\n\r\n# molecule in a 10 by 10 by 10 cube\r\nbox = Box(10.0, 10.0, 10.0, π/2, π/2, π/2) # make a box\r\nset_fractional_coords!(molecule, box)","category":"page"},{"location":"manual/atomic_interactions/#Potential-Energies:-Van-der-Waals-1","page":"Atomic Interactions","title":"Potential Energies: Van der Waals","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at [0.0, 1.0, 3.0] Cartesian coordinates using the UFF as a molecular model?","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"using PorousMaterials\r\n\r\nframework = Framework(\"SBMOF-1.cif\")\r\n\r\nforcefield = LJForceField(\"UFF.csv\")\r\n\r\nmolecule = Molecule(\"Xe\")\r\nset_fractional_coords!(molecule, framework.box)\r\n\r\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\r\n\r\nenergy = vdw_energy(framework, molecule, forcefield) # K","category":"page"},{"location":"manual/atomic_interactions/#Potential-Energies:-Electrostatics-1","page":"Atomic Interactions","title":"Potential Energies: Electrostatics","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"What is the electrostatic potential energy of a CO<sub>2</sub> adsorbate inside CAXVII_clean at [0.0, 1.0, 0.0] Cartesian coordinate?","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"using PorousMaterials\r\n\r\nframework = Framework(\"CAXVII_clean.cif\") # has charges\r\n\r\nmolecule = Molecule(\"CO2\")\r\nset_fractional_coords!(molecule, framework.box)\r\n\r\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\r\n\r\nrotate!(molecule, framework.box) # let's give it a random orientation\r\n\r\n# this is for speed. pre-compute k-vectors and allocate memory\r\neparams, kvectors, eikar, eikbr, eikcr = setup_Ewald_sum(12.0, framework.box)\r\n\r\nenergy = electrostatic_potential_energy(framework, molecule, eparams, kvectors, eikar, eikbr, eikcr)","category":"page"},{"location":"manual/atomic_interactions/#Potential-Energies:-Equations-of-state-1","page":"Atomic Interactions","title":"Potential Energies: Equations of state","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"Calculate fugacity of methane at 298 K and 65 bar using the Peng-Robinson EOS:","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"fluid = PengRobinsonFluid(:CH4)\r\nprops = calculate_properties(fluid, 298.0, 65.0) # dictionary of PREOS properties\r\nprops[\"fugacity coefficient\"] # 0.8729","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"Calculate compressibility factor of hydrogen at 300 K and 50 bar using van der Waals EOS:","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"fluid = VdWFluid(:H2)\r\nprops = calculate_properties(fluid, 300.0, 50.0) # dictionary of VdW properties\r\nprops[\"compressibility factor\"] # 1.03511","category":"page"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"Pass eos=:PengRobinson to gcmc_simulation to automatically convert pressure to fugacity using the Peng-Robinson equation of state.","category":"page"},{"location":"manual/atomic_interactions/#Forcefields-1","page":"Atomic Interactions","title":"Forcefields","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    LJForceField\r\n    replication_factors\r\n    check_forcefield_coverage","category":"page"},{"location":"manual/atomic_interactions/#PorousMaterials.LJForceField","page":"Atomic Interactions","title":"PorousMaterials.LJForceField","text":"Data structure for a Lennard Jones forcefield.\n\nAttributes\n\nname::String: name of forcefield; correponds to filename\npure_σ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones σ of an X-X interaction, where X is an atom. (units: Angstrom)\npure_ϵ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones ϵ of an X-X interaction, where X is an atom. (units: K)\nσ²::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones σ² (units: Angstrom²) for cross-interactions. Example use is sigmas_squared[:He][:C]\nϵ::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones ϵ (units: K) for cross-interactions. Example use is epsilons[:He][:C]\ncutoffradius_squared::Float64: The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom²). We store σ² to speed up computations, which involve σ², not σ.\n\n\n\n\n\n","category":"type"},{"location":"manual/atomic_interactions/#PorousMaterials.replication_factors","page":"Atomic Interactions","title":"PorousMaterials.replication_factors","text":"repfactors = replication_factors(unitcell, cutoffradius)\n\nFind the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied.\n\nA non-replicated supercell has 1 as the replication factor in each dimension (repfactors = (1, 1, 1)).\n\nArguments\n\nunitcell::Box: The unit cell of the framework\ncutoff_radius::Float64: Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom)\n\nReturns\n\nrepfactors::Tuple{Int, Int, Int}: The replication factors in the a, b, c directions\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.check_forcefield_coverage","page":"Atomic Interactions","title":"PorousMaterials.check_forcefield_coverage","text":"check_forcefield_coverage(framework, ljforcefield)\ncheck_forcefield_coverage(molecule, ljforcefield)\n\nCheck that the force field contains parameters for every atom present in a framework or molecule. Will print out which atoms are missing.\n\nArguments\n\nframework::Framework: The framework containing the crystal structure information\nmolecule::Molecule: A molecule object\nljforcefield::LJForceField: A Lennard Jones forcefield object containing information on atom interactions\n\nReturns\n\nall_covered::Bool: Returns true if all atoms in the framework are also included in ljforcefield. False otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#Potential-Energy-1","page":"Atomic Interactions","title":"Potential Energy","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    PotentialEnergy\r\n    SystemPotentialEnergy","category":"page"},{"location":"manual/atomic_interactions/#PorousMaterials.PotentialEnergy","page":"Atomic Interactions","title":"PorousMaterials.PotentialEnergy","text":"pe = PotentialEnergy()\n\nData structure to store potential energy, partitioned into van der Waals (energy.vdw) and electrostatic (energy.coulomb) interactions, both Float64.\n\nThis returns a PotentialEnergy data type where the vdw and coulomb attributes are set to 0.0\n\nReturns\n\npe::PotentialEnergy: A structure containing van der Waals and electrostatic energies, initialized at 0.0\n\nAttributes\n\nvdw::Float64: The potential energy contributions from Van der Waals interactions\ncoulomb::Float64: The potential energy contributions from electrostatic interactions\n\n\n\n\n\n","category":"type"},{"location":"manual/atomic_interactions/#PorousMaterials.SystemPotentialEnergy","page":"Atomic Interactions","title":"PorousMaterials.SystemPotentialEnergy","text":"system_potential_energy = SystemPotentialEnergy()\n\nData structure to facilitate storing/partitioning potential energy of a system. It stores the potential energy from guest-host and guest-guest interactions separately.\n\nThis initializes guesthost and guestguest with PotentialEnergy(), so when it is created the total energy recorded is 0.0\n\nReturns\n\nsystem_potential_energy::SystemPotentialEnergy: A structure containing the potential energy of the system,   broken down into guest-guest and guest-host interactions\n\nAttributes\n\nguest_host::PotentialEnergy: The total potential energy from all guest-host   interactions in the system\nguest_guest::PotentialEnergy: The total potential energy from all guest-guest   interactions in the system\n\n\n\n\n\n","category":"type"},{"location":"manual/atomic_interactions/#Nearest-Image-Conventions-1","page":"Atomic Interactions","title":"Nearest Image Conventions","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    nearest_image!","category":"page"},{"location":"manual/atomic_interactions/#PorousMaterials.nearest_image!","page":"Atomic Interactions","title":"PorousMaterials.nearest_image!","text":"nearest_image!(dxf)\n\nApplies the nearest image convention on a vector dxf between two atoms in fractional space; modifies dxf for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space.\n\nWarning: this assumes the two molecules are in the box described by fractional coords [0, 1]³.\n\nArguments\n\ndxf::Array{Float64}: A vector between two atoms in fractional space\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#Electrostatics-Energy-1","page":"Atomic Interactions","title":"Electrostatics Energy","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    Eikr\r\n    electrostatic_potential_energy\r\n    precompute_kvec_wts\r\n    setup_Ewald_sum\r\n    total_electrostatic_potential_energy","category":"page"},{"location":"manual/atomic_interactions/#PorousMaterials.Eikr","page":"Atomic Interactions","title":"PorousMaterials.Eikr","text":"eikr = Eikr(eikar, eikbr, eikcr)\n\nmutable struct for holding the eikr vectors\n\nAttributes\n\neikar::OffsetArray{Complex{Float64}}: array for storing e^{i * ka ⋅ r}; has indices   0:kreps[1] and corresponds to recip. vectors in a-direction\neikbr::OffsetArray{Complex{Float64}}: array for storing e^{i * kb ⋅ r}; has indices   -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction\neikcr::OffsetArray{Complex{Float64}}: array for storing e^{i * kc ⋅ r}; has indices   -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction\n\n\n\n\n\n","category":"type"},{"location":"manual/atomic_interactions/#PorousMaterials.electrostatic_potential_energy","page":"Atomic Interactions","title":"PorousMaterials.electrostatic_potential_energy","text":"ϕ = electrostatic_potential_energy(framework, molecule, eparams, eikr)\n\nCompute the electrostatic potential energy of a molecule inside a framework.\n\nThe electrostatic potential is created by the point charges assigned to the framework atoms in framework.charges. Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at differences in energy in a Monte Carlo simulation.\n\nWarning: it is assumed that the framework is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in eparams.sr_cutoff_r.\n\nArguments\n\nframework::Framework: Crystal structure (see framework.charges for charges)\nmolecule::Molecule: The molecule being compared to the atoms in the framework.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\npot::EwaldSum: Electrostatic potential between framework and molecule (units: K)\n\n\n\n\n\nϕ = electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCompute the electrostatic potential energy of a system comprised of an array of Molecules.\n\nThe EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive.\n\nReturns an EwaldSum type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (ϕ.sr, ϕ.lr, ϕ.self, ϕ.intra).\n\nUnits of energy: Kelvin\n\nArguments\n\nmolecules::Array{Molecules, 1}: array of molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: the box the energy is being computed in\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.precompute_kvec_wts","page":"Atomic Interactions","title":"PorousMaterials.precompute_kvec_wts","text":"kvectors = precompute_kvec_wts(kreps, box, α, max_mag_k_sqrd=Inf)\n\nFor speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry:     cos(-k⋅(x-xᵢ)) + cos(k⋅(x-xᵢ)) = 2 cos(k⋅(x-xᵢ))\n\nIf max_mag_k_sqrd is passed, k-vectors with a magnitude greater than max_mag_k_sqrd are not included.\n\nArguments\n\nkreps::Tuple{Int, Int, Int}: number of k-vector replications required in a, b, c\nbox::Box: the simulation box containing the reciprocal lattice.\nα::Float64: Ewald sum convergence parameter (units: inverse Å)\nmax_mag_k_sqrd::Float64: cutoff for |k|² in Fourier sum; if passed, do not include\n\nk-vectors with magnitude squared greater than this.\n\nReturns\n\nkvectors::Array{Kvector, 1}: array of k-vectors to include in the Fourier sum and their\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.setup_Ewald_sum","page":"Atomic Interactions","title":"PorousMaterials.setup_Ewald_sum","text":"eparams = setup_Ewald_sum(box, sr_cutoff_r; ϵ=1e-6, verbose=false)\n\nGiven the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information.\n\nAlso, pre-compute weights on k-vector contributions to Ewald sum in Fourier space.\n\nAlso, allocate OffsetArrays for storing e^{i * k ⋅ r} where r = x - xⱼ and k is a reciprocal lattice vector.\n\nArguments\n\nbox::Box: the simulation box containing the reciprocal lattice.\nsr_cutoff_r::Float64: cutoff-radius (units: Å) for short-range contributions to Ewald\nϵ::Float64: desired level of precision. Typical value is 1e-6, but this does not\nverbose::Bool: If true will print results\n\nReturns\n\neparams::EwaldParams: data structure containing Ewald summation settings\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.total_electrostatic_potential_energy","page":"Atomic Interactions","title":"PorousMaterials.total_electrostatic_potential_energy","text":"total_ϕ = total_electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCalculates the total electrostatic potential energy of an array of Molecules using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this\n\nArguments\n\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: The box the energy is being computed in.\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\ntotal_ϕ = total_electrostatic_potential_energy(framework, molecules, eparams, eikr)\n\nExplanation of totalelectrostaticpotential_energy that uses framework\n\nArguments\n\nframework::Framework: Crystal structure (see framework.charges for charges)\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#Van-der-Waals-Energy-1","page":"Atomic Interactions","title":"Van der Waals Energy","text":"","category":"section"},{"location":"manual/atomic_interactions/#","page":"Atomic Interactions","title":"Atomic Interactions","text":"    lennard_jones\r\n    vdw_energy\r\n    vdw_energy_no_PBC","category":"page"},{"location":"manual/atomic_interactions/#PorousMaterials.lennard_jones","page":"Atomic Interactions","title":"PorousMaterials.lennard_jones","text":"energy = lennard_jones(r², σ², ϵ)  (units: Kelvin)\n\nCalculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. σ and ϵ are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of ϵ are).\n\nArguments\n\nr²::Float64: distance between two (pseudo)atoms in question squared (Angstrom²)\nσ²::Float64: sigma parameter in Lennard Jones potential squared (units: Angstrom²)\nϵ::Float64: epsilon parameter in Lennard Jones potential (units: Kelvin)\n\nReturns\n\nenergy::Float64: Lennard Jones potential energy\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.vdw_energy","page":"Atomic Interactions","title":"PorousMaterials.vdw_energy","text":"energy = vdw_energy(framework, molecule, ljforcefield)\n\nCalculates the van der Waals interaction energy between a molecule and a framework. Applies the nearest image convention to find the closest replicate of a specific atom.\n\nWARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See replicate.\n\nArguments\n\nframework::Framework: Crystal structure\nmolecule::Molecule: adsorbate (includes position/orientation/atoms)\nljforcefield::LJForceField: Lennard Jones force field\n\nReturns\n\nenergy::Float64: Van der Waals interaction energy\n\n\n\n\n\ngg_energy = vdw_energy(molecule_id, molecules, ljforcefield, simulation_box)\n\nCalculates van der Waals interaction energy of a single adsorbate molecules[molecule_id] with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention.\n\nArguments\n\nmolecule_id::Int: Molecule ID used to determine which molecule in molecules we wish to calculate the guest-guest interactions\nmolecules::Array{Molecule, 1}: An array of Molecule data structures\nljforcefield::LJForceField: A Lennard Jones forcefield data structure describing the interactions between different atoms\nsimulation_box::Box: The simulation box for the computation.\n\nReturns\n\ngg_energy::Float64: The guest-guest interaction energy of molecules[molecule_id] with the other molecules in molecules\n\n\n\n\n\n","category":"function"},{"location":"manual/atomic_interactions/#PorousMaterials.vdw_energy_no_PBC","page":"Atomic Interactions","title":"PorousMaterials.vdw_energy_no_PBC","text":"pot_energy = vdw_energy_no_PBC(atoms, molecule, ljff)\n\nAssumes unit cell box is a unit cube and no periodic boundary conditions are applied.\n\n\n\n\n\n","category":"function"},{"location":"guides/faq/#FAQ-1","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"How do I type out the math symbols? e.g. box.α?","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"Julia supports unicode input! Type box.\\alpha, then hit tab. Voilà. There is a vim extension for Julia here.","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"How do I run as a script in the command line?","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"It is instructive to first run an example in the Julia REPL so you can print out and interact with attributes of your forcefield, framework, and molecule to ensure they are correct. If you want to then run the Julia code in the command line, simply put the commands in a text file with a .jl extension and run in terminal as julia my_script.jl. For parallelization in adsorption_isotherm and henry_coefficient, call e.g. 4 cores with julia -p 4 my_script.jl.","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"Can I use PorousMaterials.jl in Jupyter Notebook/ Jupyter Lab?","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"Yes! See here.","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"How can I convert my .cif into P1 symmetry for PorousMaterials.jl?","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"PorousMaterials.jl will automatically do this for you! It looks for the _symmetry_equiv_pos_as_xyz tag in the .cif file and uses those symmetry operations to replicate the structure in a lower symmetry into P1 symmetry.","category":"page"},{"location":"guides/faq/#","page":"FAQ","title":"FAQ","text":"It is important to note that PorousMaterials.jl will read in the space group name, but it does NOT use this for converting your structure to P1.","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"(Image: PorousMaterials.jl) A pure-Julia package for classical molecular modeling of adsorption in porous crystals such as metal-organic frameworks (MOFs).","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the potential energy of a molecule at particular position and orientation inside of a porous crystal","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Write a potential energy grid of a molecule inside a porous material to visualize binding sites","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the Henry coefficient of a gas in a porous crystal","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Run grand-canonical Monte Carlo simulations of gas adsorption in a porous crystal","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"Designed for high-throughput computations to minimize input files and querying results from output files. User-friendly. Instructive error messages thrown when they should be. Well-documented. Easy to install.","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"In development, please contribute, post issues 🐛, and improve!","category":"page"},{"location":"#Installation-1","page":"PorousMaterials","title":"Installation","text":"","category":"section"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"Download and install the Julia programming language, v1.3 or higher.","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, open the package manager (using ]) and enter the following:","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"pkg> add PorousMaterials","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, load all functions in PorousMaterials.jl into the namespace:","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"julia> using PorousMaterials # that's it","category":"page"},{"location":"#Tests-1","page":"PorousMaterials","title":"Tests","text":"","category":"section"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"Run the tests in the script tests/runtests.jl manually or type Pkg.test(\"PorousMaterials\") into Julia.","category":"page"},{"location":"#","page":"PorousMaterials","title":"PorousMaterials","text":"Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and must be run separately; they are found in tests/henry_test.jl and tests/gcmc_test.jl.","category":"page"},{"location":"manual/mof_simulations/#Demo-of-Henry-coefficients-Calculation-1","page":"Molecular Simulations","title":"Demo of Henry coefficients Calculation","text":"","category":"section"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"Compute the Henry coefficient of CO<sub>2</sub> in CAXVII_clean (Fe<sub>2</sub>(dobdc)) at 298 K using the Dreiding force field:","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"using PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework(\"CAXVII_clean.cif\")                                               \n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField(\"Dreiding.csv\", cutoffradius=12.5)                                  \n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule(\"CO2\")                                                              \n\ntemperature = 298.0 # K\n\n# conduct Widom insertions and compute Henry coefficient, heat of adsorption\nresults = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[\"Qst (kJ/mol)\"] # -21.0\nresults[\"henry coefficient [mol/(kg-Pa)]\"] # 2.88e-05","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"The simulation is parallelized across a maximum of 5 cores.","category":"page"},{"location":"manual/mof_simulations/#Demo-of-Grand-canonical-Monte-Carlo-Simulations-1","page":"Molecular Simulations","title":"Demo of Grand-canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"Simulate the adsorption of CO<sub>2</sub> in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"using PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework(\"FIQCEN_clean_min_charges.cif\")\n# remove annoying numbers from atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField(\"UFF.csv\", cutoffradius=12.8)\n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule(\"CO2\")\n\ntemperature = 298.0 # K\npressure = 1.0 # bar\n\n# conduct grand-canonical Monte Carlo simulation\nresults, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[\"⟨N⟩ (molecules/unit cell)\"]\nresults[\"Q_st (K)\"]","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"Or, compute the entire adsorption isotherm at once, parallelized across many cores:","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"pressures = [0.2, 0.6, 0.8, 1.0] # bar\n\n# loop over all pressures and compute entire adsorption isotherm in parallel\nresults = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:","category":"page"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"# loop over all pressures and run GCMC simulations in series.\n# load in the configurations of the molecules from the previous pressure.\nresults = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=1000, n_sample_cycles=5000)","category":"page"},{"location":"manual/mof_simulations/#Henry-Coefficient-Calculations-1","page":"Molecular Simulations","title":"Henry Coefficient Calculations","text":"","category":"section"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"    henry_coefficient\n    henry_result_savename","category":"page"},{"location":"manual/mof_simulations/#PorousMaterials.henry_coefficient","page":"Molecular Simulations","title":"PorousMaterials.henry_coefficient","text":"result = henry_coefficient(framework, molecule, temperature, ljforcefield,\n                            nb_insertions=1e6, verbose=true, ewald_precision=1e-6,\n                            autosave=true)\n\nConduct particle insertions to compute the Henry coefficient Kₕ of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): ⟨N⟩ = Kₕ P, where P is pressure and Kₕ is the Henry coefficient.\n\nKₕ = β ⟨e^{-β U}⟩, where the average is over positions and orientations of the molecule in the framework.\n\nArguments\n\nframework::Framework: the porous crystal in which we seek to simulate adsorption\nmolecule::Molecule: the adsorbate molecule\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\nljforcefield::LJForceField: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\ninsertions_per_volume::Int: number of Widom insertions to perform for computing the\n\naverage, per unit cell volume (Å³)\n\nverbose::Bool: whether or not to print off information during the simulation.\newald_precision::Float64: desired precision for Ewald summations; used to determine\n\nthe replication factors in reciprocal space.\n\nautosave::Bool: save results file as a .jld in PATHTODATA * sims\nfilename_comment::AbstractString: An optional comment that will be appended to the name of the saved file.\nwrite_checkpoint::Bool: Will periodically save checkpoints to start the job from a previous state.\nload_checkpoint::Bool: Instructs the program to look for a checkpoint file in data/henry_checkpoints\n\nand start the simulation from that point.\n\ncheckpoint_frequency::Int: The frequency at which we will save a checkpoint file. Is only used if write_checkpoint=true\n\nReturns\n\nresult::Dict{String, Float64}: A dictionary containing all the results from the Henry coefficient simulation\n\n\n\n\n\n","category":"function"},{"location":"manual/mof_simulations/#PorousMaterials.henry_result_savename","page":"Molecular Simulations","title":"PorousMaterials.henry_result_savename","text":"save_name = henry_result_savename(framework, molecule, temperature,\n                               ljforcefield, insertions_per_volume;\n                               comment=\"\")\n\nDetermine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\nArguments\n\nframework::Framework: The porous crystal being tested\nmolecule::Molecule: The molecule being tested inside the crystal\ntemperature::Float64: The temperature used in the simulation units: Kelvin (K)\nljforcefield::LJForceField: The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces\ninsertions_per_volume::Union{Int, Float64}: The number of widom insertions per unit volume.   Will be scaled according to the framework we're working with\ncomment::AbstractString: An optional comment that will be appended to the filename\n\n\n\n\n\n","category":"function"},{"location":"manual/mof_simulations/#Grand-Canonical-Monte-Carlo-Simulations-1","page":"Molecular Simulations","title":"Grand-Canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"manual/mof_simulations/#","page":"Molecular Simulations","title":"Molecular Simulations","text":"    gcmc_simulation\n    adsorption_isotherm\n    stepwise_adsorption_isotherm\n    gcmc_result_savename","category":"page"},{"location":"manual/mof_simulations/#PorousMaterials.gcmc_simulation","page":"Molecular Simulations","title":"PorousMaterials.gcmc_simulation","text":"results, molecules = gcmc_simulation(framework, molecule, temperature, pressure,\n                                     ljforcefield; n_sample_cycles=5000,\n                                     n_burn_cycles=5000, sample_frequency=1,\n                                     verbose=false, molecules=Molecule[],\n                                     eos=:ideal, ewald_precision=1e-6,\n                                     load_checkpoint_file=false,\n                                     show_progress_bar=false, checkpoint=Dict(),\n                                     write_checkpoints=false, checkpoint_frequency=100,\n                                     write_adsorbate_snapshots=false,\n                                     snapshot_frequency=1, calculate_density_grid=false,\n                                     density_grid_dx=1.0, density_grid_species=nothing,\n                                     filename_comment=\"\")\n\nRuns a grand-canonical (μVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field.\n\nA cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation.\n\nArguments\n\nframework::Framework: the porous crystal in which we seek to simulate adsorption\nmolecule::Molecule: a template of the adsorbate molecule of which we seek to simulate\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\npressure::Float64: pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material. units: bar   the adsorption\nljforcefield::LJForceField: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\nn_burn_cycles::Int: number of cycles to allow the system to reach equilibrium before   sampling.\nn_sample_cycles::Int: number of cycles used for sampling\nsample_frequency::Int: during the sampling cycles, sample e.g. the number of adsorbed   gas molecules every this number of Markov proposals.\nverbose::Bool: whether or not to print off information during the simulation.\nmolecules::Array{Molecule, 1}: a starting configuration of molecules in the framework.\n\nNote that we assume these coordinates are Cartesian, i.e. corresponding to a unit box.\n\newald_precision::Float64: The desired precision for the long range Ewald summation\neos::Symbol: equation of state to use for calculation of fugacity from pressure. Default\n\nis ideal gas, where fugacity = pressure.\n\nload_checkpoint_file::Bool: Will find a checkpoint file corresponding to the gcmc_result_savename if true.   If that file is not found, function will throw an error.\ncheckpoint::Dict: A checkpoint dictionary that will work as a starting configuration for the run.   The dictionary has to have the following keys: outer_cycle, molecules, system_energy, current_block, gcmc_stats, markov_counts, markov_chain_time and time. If this argument is used, keep load_checkpoint_file=false.\nwrite_checkpoints::Bool: Will save checkpoints in data/gcmc_checkpoints if this is true.\ncheckpoint_frequency::Int: Will save checkpoint files every checkpoint_frequency cycles.\nwrite_adsorbate_snapshots::Bool: Whether the simulation will create and save a snapshot file\nsnapshot_frequency::Int: The number of cycles taken between each snapshot (after burn cycle completion)\ncalculate_density_grid::Bool: Whether the simulation will keep track of a density grid for adsorbates\ndensity_grid_dx::Float64: The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by required_n_pts.\ndensity_grid_species::Symbol: The atomic species within the molecule for which we will compute the density grid.\nfilename_comment::AbstractString: An optional comment that will be appended to the name of the saved file (if autosaved)\n\n\n\n\n\n","category":"function"},{"location":"manual/mof_simulations/#PorousMaterials.adsorption_isotherm","page":"Molecular Simulations","title":"PorousMaterials.adsorption_isotherm","text":"results = adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal, \n                              load_checkpoint_file=false, checkpoint=Dict(), \n                              write_checkpoints=false, checkpoint_frequency=50,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in parallel. Arguments are the same as gcmc_simulation, as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as julia -p 4 mysim.jl to allocate e.g. four cores. See Parallel Computing.\n\n\n\n\n\n","category":"function"},{"location":"manual/mof_simulations/#PorousMaterials.stepwise_adsorption_isotherm","page":"Molecular Simulations","title":"PorousMaterials.stepwise_adsorption_isotherm","text":"results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              load_checkpoint_file=false, checkpoint=Dict(),\n                              write_checkpoints=false, checkpoint_frequency=50,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in series. Arguments are the same as gcmc_simulation, as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of pressures is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see adsorption_isotherm which runs the μVT simulation at each pressure in parallel.\n\n\n\n\n\n","category":"function"},{"location":"manual/mof_simulations/#PorousMaterials.gcmc_result_savename","page":"Molecular Simulations","title":"PorousMaterials.gcmc_result_savename","text":"file_save_name = gcmc_result_savename(framework_name, molecule_species,\n                                    ljforcefield_name, temperature, pressure,\n                                    n_burn_cycles, n_sample_cycles; comment=\"\",\n                                    extension=\"\")\n\nDetermine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\nArguments\n\nframework_name::AbstractString: The porous crystal being tested\nmolecule_species::Symbol: The molecule being tested inside the porous crystal\nljforcefield_name::AbstractString: The molecular model being used in this   simulation to describe intermolecular Van der Waals interactions\ntemperature::Float64: The temperature used in the simulation units: Kelvin (K)\npressure::Float64: The pressure used in the simulation units: bar\nn_burn_cycles::Int: The number of burn cycles used in this simulation\nn_sample_cycles::Int: The number of sample cycles used in this simulation\ncomment::AbstractString: An optional comment that will be appended to the end of the filename\nextension::AbstractString: The extension for the file being created\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#Loading-in-Molecule-Files-1","page":"Molecules","title":"Loading in Molecule Files","text":"","category":"section"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"Molecule input files are stored in PorousMaterials.PATH_TO_MOLECULES. Each molecule possesses its own directory and contains two files: point_charges.csv and lennard_jones_spheres.csv, comma-separated-value files describing the point charges and Lennard Jones spheres, respectively, comprising the molecule. Only rigid molecules are currently supported. Units of length are in Angstrom; units of charges are electrons.","category":"page"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"using PorousMaterials\n\nm = Molecule(\"CO2\")","category":"page"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"PorousMaterials will then output information about the molecule you just loaded:","category":"page"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"Molecule species: CO2\nCenter of mass (fractional coords): [0.0, 0.0, 0.0]\nAtoms:\n\n        atom = C_CO2, xf = [0.000, 0.000, 0.000]\n        atom = O_CO2, xf = [-1.160, 0.000, 0.000]\n        atom = O_CO2, xf = [1.160, 0.000, 0.000]\nPoint charges:\n        charge = 0.700000, xf = [0.000, 0.000, 0.000]\n        charge = -0.350000, xf = [-1.160, 0.000, 0.000]\n        charge = -0.350000, xf = [1.160, 0.000, 0.000]","category":"page"},{"location":"manual/molecules/#Building-Blocks-of-PorousMaterials:-Molecules-1","page":"Molecules","title":"Building Blocks of PorousMaterials: Molecules","text":"","category":"section"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"molecule = Molecule(\"CO2\") # fractional coords in terms of unit cube box\n\n# access Lennard-Jones spheres & point charges that comprise molecule\nmolecule.atoms\nmolecule.charges\n\n# translate to [1.0, 2.0, 3.0] fractional coordinates\ntranslate_to!(molecule, [1.0, 2.0, 3.0])\n\n# translate by [0.1, 0.0, 0.0] fractional coordinates\ntranslate_by!(molecule, [0.1, 0.0, 0.0])\n\n# conduct a uniform random rotation\nrotate!(molecule, UnitCube()) # b/c now fractional coords defined in context of a unit cube","category":"page"},{"location":"manual/molecules/#Molecules-1","page":"Molecules","title":"Molecules","text":"","category":"section"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"    Molecule\n    n_atoms\n    translate_to!\n    rotate!\n    rotation_matrix()\n    rotation_matrix(::Float64, ::Array{Float64, 1}; ::Bool)\n    rand_point_on_unit_sphere\n    charged(::Molecule; ::Bool)","category":"page"},{"location":"manual/molecules/#PorousMaterials.Molecule","page":"Molecules","title":"PorousMaterials.Molecule","text":"Data structure for a molecule/adsorbate.\n\nAttributes\n\nspecies::Symbol: Species of molecule, e.g. :CO2\natoms::Atoms: array of Lennard-Jones spheres comprising the molecule\ncharges::Charges: array of point charges comprising the molecule\nxf_com::Array{Float64, 1}: center of mass of the molecule in fractional coordinates\n\n\n\n\n\n","category":"type"},{"location":"manual/molecules/#PorousMaterials.n_atoms","page":"Molecules","title":"PorousMaterials.n_atoms","text":"num_atoms = n_atoms(molecules)\n\ncalculates the total number of atoms in an array of molecules\n\nArguments\n\nmolecule::Array{Molecule, 1}: The molecules to count the number of atoms in\n\nReturns\n\nThe total number of atoms in the molecules passed in\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.translate_to!","page":"Molecules","title":"PorousMaterials.translate_to!","text":"translate_to!(molecule, xf)\ntranslate_to!(molecule, x, box)\n\nTranslate a molecule a molecule to point xf in fractional coordinate space or to x in Cartesian coordinate space. For the latter, a unit cell box is required for context. The molecule is translated such that its center of mass is at xf/x`.\n\nArguments\n\nmolecule::Molecule: The molecule which will be translated to xf\nxf::Array{Float64, 1}: A vector containing the coordinates of the final destination of the molecule\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.rotate!","page":"Molecules","title":"PorousMaterials.rotate!","text":"rotate!(molecule, box)\n\nConduct a random rotation of the molecule about its center of mass. The box is needed because the molecule contains only its fractional coordinates.\n\nArguments\n\nmolecule::Molecule: The molecule which will be subject to a random rotation\nbox::Box: The molecule only contains fractional coordinates, so the box is needed for a correct rotation\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.rotation_matrix-Tuple{}","page":"Molecules","title":"PorousMaterials.rotation_matrix","text":"r = rotation_matrix()\n\nGenerate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x, this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x). See James Arvo. Fast Random Rotation Matrices.\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\nReturns\n\nr::Array{Float64, 2}: A 3x3 random rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/molecules/#PorousMaterials.rotation_matrix-Tuple{Float64,Array{Float64,1}}","page":"Molecules","title":"PorousMaterials.rotation_matrix","text":"R = rotation_matrix(θ, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle θ about vector u\nR = rotation_matrix(θ, dim) # 3 by 3 rotation matrix, angle θ about axis `dim`\n\nDetermine the 3D rotation matrix to rotate an angle θ (radians) about axis u.\n\nSee Wikipedia.\n\nArguments\n\nθ::Float64: angle to rotate about an axis, in radians\nu::Array{Float64, 1}: axis about which to rotate\ndim::Int: 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.\nassume_unit_vector::Bool: assume u is a unit vector; otherwise, u will be normalized\n\ninternal to this function.\n\nReturns\n\nR::Array{Float64, 2}: 3D rotation matrix. so R * x will rotate vector x as desired.\n\n\n\n\n\n","category":"method"},{"location":"manual/molecules/#PorousMaterials.rand_point_on_unit_sphere","page":"Molecules","title":"PorousMaterials.rand_point_on_unit_sphere","text":"u = rand_point_on_unit_sphere()\n\nGenerate a unit vector with a random orientation.\n\nReturns\n\nu::Array{Float64, 1}: A unit vector with a random orientation\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.charged-Tuple{Molecule}","page":"Molecules","title":"PorousMaterials.charged","text":"charged_flag = charged(molecule, verbose=false)\n\nDetermine if a molecule has point charges\n\nArguments\n\nmolecule::Molecule: The molecule which will be checked for charges\nverbose::Bool: Will print result if true\n\nReturns\n\ncharged_flag::Bool: true if molecule is charged, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"manual/molecules/#Molecular-Movement-1","page":"Molecules","title":"Molecular Movement","text":"","category":"section"},{"location":"manual/molecules/#","page":"Molecules","title":"Molecules","text":"    insert_molecule!\n    delete_molecule!\n    translate_molecule!\n    reinsert_molecule!\n    rotatable","category":"page"},{"location":"manual/molecules/#PorousMaterials.insert_molecule!","page":"Molecules","title":"PorousMaterials.insert_molecule!","text":"insert_molecule!(molecules, box, template)\n\nInserts an additional adsorbate molecule into the simulation box using the template provided. The center of mass of the molecule is chosen at a uniform random position in the simulation box. A uniformly random orientation of the molecule is chosen by rotating about the center of mass.\n\nArguments\n\nmolecules::Array{Molecule, 1}: An array of Molecule objects\nbox::Box: The simulation box\ntemplate::Molecule: A template molecule used as reference when inserting molecules\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.delete_molecule!","page":"Molecules","title":"PorousMaterials.delete_molecule!","text":"delete_molecule!(molecule_id, molecules)\n\nRemoves a random molecule from the current molecules in the framework. molecule_id decides which molecule will be deleted, for a simulation, it must be a randomly generated value\n\nArguments\n\nmolecule_id::Int: The molecule ID is used to determine which molecule in molecules should be removed\nmolecules::Array{Molecule, 1}: An array of Molecule objects\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.translate_molecule!","page":"Molecules","title":"PorousMaterials.translate_molecule!","text":"translate_molecule!(molecule, box)\n\nPerturbs the Cartesian coordinates of a molecule about its center of mass by a random vector of max length δ. Applies periodic boundary conditions to keep the molecule inside the simulation box. Returns a deep copy of the old molecule in case it needs replaced if the Monte Carlo proposal is rejected.\n\nArguments\n\nmolecule::Molecule: The molecule we want to perturb\nbox::Box: The simulation box\n\nReturns\n\nold_molecule::Molecule: The old molecule in case the MC proposal is rejected\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.reinsert_molecule!","page":"Molecules","title":"PorousMaterials.reinsert_molecule!","text":"reinsert_molecule(molecule, box)\n\nMove molecule to a new center of mass randomly distrubted in the unit cell and choose a random orientation for it. Return a deep copy of the starting molecule for possible restoration. This MC move can be viewed as a more aggressive translate_molecule!.\n\nArguments\n\nmolecule::Molecule: The molecule we want to perturb\nbox::Box: The simulation box\n\n\n\n\n\n","category":"function"},{"location":"manual/molecules/#PorousMaterials.rotatable","page":"Molecules","title":"PorousMaterials.rotatable","text":"need_to_rotate = rotatable(molecule)\n\nDetermines whether or not a given molecule needs to be rotated. For example, rotating a single atom isn't necessary.\n\nArguments\n\nmolecule::Molecule: The molecule being tested. This function determines if a   rotation of this molecule will do anything.\n\nReturns\n\nis_rotatable::Bool: A boolean describing whether or not rotating the molecule   will alter its interactions with other molecules \n\n\n\n\n\n","category":"function"}]
}
