var documenterSearchIndex = {"docs":
[{"location":"distance/#Distances","page":"computing distances","title":"Distances","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The distance between two Atoms in a Crystal is central to many operations within PorousMaterials.jl.  The distance function calculates the Cartesian displacement between the Coords (Cart or Frac) of two points, i and j, within a given box.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"xtal = Crystal(\"Co-MOF-74.cif\")\ndistance(xtal.atoms.coords, xtal.box, 1, 2, false) # 23.2 Å","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The apply_pbc argument allows for calculation of distances across the periodic boundaries of the box.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms.coords, xtal.box, 1, 2, true) # 3.34 Å","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance also works on Atoms and Charges.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms, xtal.box, 3, 5, true)","category":"page"},{"location":"distance/#docs","page":"computing distances","title":"docs","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"    distance","category":"page"},{"location":"distance/#PorousMaterials.distance","page":"computing distances","title":"PorousMaterials.distance","text":"r = distance(coords, box, i, j, apply_pbc)\nr = distance(atoms, box, i, j, apply_pbc) # atoms i and j\nr = distance(charges, box, i, j, apply_pbc) # atoms i and j\n\ncalculate the (Cartesian) distance between particles i and j.\n\napply periodic boundary conditions if and only if apply_pbc is true.\n\narguments\n\ncoords::Coords: the coordinates (Frac>:Coords or Cart>:Coords)\natoms::Atoms: atoms\ncharges::charges: atoms\nbox::Box: unit cell information\ni::Int: index of the first particle\nj::Int: Index of the second particle\napply_pbc::Bool: true if we wish to apply periodic boundary conditions, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"energy_min/#Find-Potential-Energy-Minimum","page":"energy minimum","title":"Find Potential Energy Minimum","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"Here we show how to find the minimum energy (acc. to a force field) position of a molecule in a crystal.","category":"page"},{"location":"energy_min/#Example","page":"energy minimum","title":"Example","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"for example, we wish to find the minimum energy (acc. to the UFF) position of a xenon adsorbate in SBMOF-1. ","category":"page"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"xtal = Crystal(\"SBMOF-1.cif\")\nmolecule  = Molecule(\"Xe\")\nljff = LJForceField(\"UFF\")\n\n# grid search to find min energy position.\n#  gives good starting guess for optimization algorithm to fine tune.\nn_pts = (15, 15, 15) # resolution of grid points\nminimized_molecule, min_E = find_energy_minimum_gridsearch(xtal, molecule, ljff, n_pts=n_pts)\n# minimized_molecule: xenon at its min energy position\n# min_E: associated minimum energy of xenon (kJ/mol)\n\n# fine tune the minimum energy position according to the grid search.\nminimized_molecule, min_E = find_energy_minimum(xtal, minimized_molecule, ljff)","category":"page"},{"location":"energy_min/#detailed-docs","page":"energy minimum","title":"detailed docs","text":"","category":"section"},{"location":"energy_min/","page":"energy minimum","title":"energy minimum","text":"    find_energy_minimum\n    find_energy_minimum_gridsearch","category":"page"},{"location":"energy_min/#PorousMaterials.find_energy_minimum","page":"energy minimum","title":"PorousMaterials.find_energy_minimum","text":"minimized_molecule, min_energy  = find_energy_minimum(xtal, molecule, ljff) # molecule set at initial guess\n\nfind the minimum energy position, and associated minimum energy, of a molecule in a crystal. n.b. if molecule has more than one atom, it will not minimize over the orientation (rotations). the optimizer needs an initial estimate of the minimum energy position.  pass molecule with good initial position. if you don't have a good initial position, use find_energy_minimum_gridsearch.\n\nArguments\n\nxtal::Crystal: the crystal\nmolecule::Molecule: the molecule, whose position we seek to tune until we reach a local minimum. must start at a good initial position close to the minimum.\nljff::LJForceField: the force field used to calculate crystal-molecule interaction energies\n\nReturns\n\nminimized_molecule::Molecule{Frac}: the molecule at its minimum energy position\nmin_energy::Float64: the associated minimum molecule-crystal interaciton energy (kJ/mol)\n\n\n\n\n\n","category":"function"},{"location":"energy_min/#PorousMaterials.find_energy_minimum_gridsearch","page":"energy minimum","title":"PorousMaterials.find_energy_minimum_gridsearch","text":"xf₀ = find_energy_minimum_gridsearch(xtal, molecule, ljff; n_pts=(50, 50, 50))\n\nperform an energy_grid calculation and, via a grid search, find the minimum energy position of a molecule.\n\nArguments\n\nxtal::Crystal: The crystal being investigated\nmolecule::Molecule{Cart}: The molecule used to probe energy surface\nljff::LJForceField: The force field used to calculate interaction energies\nn_pts::Tuple{Int, Int, Int}=(50,50,50): Number of grid points in each fractional coordinate dimension, including endpoints (0, 1)\n\nReturns\n\nminimized_molecule::Molecule{Frac}: the molecule at its minimum energy position\nmin_energy::Float64: the associated minimum molecule-crystal interaciton energy (kJ/mol)\n\n\n\n\n\n","category":"function"},{"location":"henry/#Henry-Coefficient","page":"Henry coefficients","title":"Henry Coefficient","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"PorousMaterials.jl allows for Henry coefficient calculations using Widom insertions.","category":"page"},{"location":"henry/#Preparing-the-Henry-coefficient-simulation","page":"Henry coefficients","title":"Preparing the Henry coefficient simulation","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The simulation requires the following PorousMaterials.jl objects:","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"Crystal structure\nMolecule adsorbate\nLJForceField forcefield","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"In addition the the list above, one has to specify the temperature (in K) and the number of Widom insertions per unit volume (in Angstrom).","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"xtal = Crystal(\"IRMOF-1.cif\")           # The crystal structure we are interested in\nstrip_numbers_from_atom_labels!(xtal)   # We have to make sure the atom species have no numbers appended to them\nmethane = Molecule(\"CH4\")               # Here we choose to use methane as the adsorbate\nljff = LJForceField(\"UFF\")              # We will use the Universal Force Field (UFF) to calculate the interatomic interactions\ntemp = 298.0\nwidom_insertions = 200\n\nresults = henry_coefficient(xtal, methane, temp, ljff, insertions_per_volume=widom_insertions)","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The results are also saved to ./data/simulations as a .jld2 file that can be read using the JLD2.jl package.","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The output (and saved file) is a dictionary containing the following keys","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"results[\"henry coefficient[mmol/(g-bar)]\"]          # The Henry coefficient in mmol/(g-bar)\nresults[\"err henry coefficient[mmol/(g-bar)]\"]      # The error associated with the Henry coefficient in mmol/(g-bar)\nresults[\"$\\langle$U$\\rangle$ (kJ/mol)\"]             # The ensemble average energy of adsorption in kJ/mol\nresults[\"err $\\langle$U$\\rangle$ (kJ/mol)\"]         # The error associated with the ensemble average energy of adsorption in kJ/mol\nresults[\"Qst (kJ/mol)\"\"]                            # The heat of adsorption in kJ/mol\nresults[\"err Qst (kJ/mol)\"\"]                        # The error associated with the heat of adsorption in kJ/mol","category":"page"},{"location":"henry/#locating-the-saved-results","page":"Henry coefficients","title":"locating the saved results","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"The name of the result filenames follow a convention outlined in henry_result_savename.","category":"page"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"using JLD2\nresult_filename = henry_result_savename(xtal, methane, temp, ljff, widom_insertions)    # This find the name of the file\n@load \"./data/simulations/\" * result_filename results                                   # This loads the `results` dictionary","category":"page"},{"location":"henry/#detailed-docs","page":"Henry coefficients","title":"detailed docs","text":"","category":"section"},{"location":"henry/","page":"Henry coefficients","title":"Henry coefficients","text":"    henry_coefficient\n    henry_result_savename","category":"page"},{"location":"henry/#PorousMaterials.henry_coefficient","page":"Henry coefficients","title":"PorousMaterials.henry_coefficient","text":"result = henry_coefficient(crystal, molecule, temperature, ljforcefield,\n                            nb_insertions=1e6, verbose=true, ewald_precision=1e-6,\n                            autosave=true)\n\nConduct particle insertions to compute the Henry coefficient Kₕ of a molecule in a crystal. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): ⟨N⟩ = Kₕ P, where P is pressure and Kₕ is the Henry coefficient.\n\nKₕ = β ⟨e^{-β U}⟩, where the average is over positions and orientations of the molecule in the crystal.\n\nArguments\n\ncrystal::Crystal: the porous crystal in which we seek to simulate adsorption\nmolecule::Molecule: the adsorbate molecule\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\nljforcefield::LJForceField: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\ninsertions_per_volume::Int: number of Widom insertions to perform for computing the\n\naverage, per unit cell volume (Å³)\n\nverbose::Bool: whether or not to print off information during the simulation.\newald_precision::Float64: desired precision for Ewald summations; used to determine\n\nthe replication factors in reciprocal space.\n\nautosave::Bool: save results file as a .jld in PATHTODATA * sims\nfilename_comment::AbstractString: An optional comment that will be appended to the name of the saved file.\n\nReturns\n\nresult::Dict{String, Float64}: A dictionary containing all the results from the Henry coefficient simulation\n\n\n\n\n\n","category":"function"},{"location":"henry/#PorousMaterials.henry_result_savename","page":"Henry coefficients","title":"PorousMaterials.henry_result_savename","text":"save_name = henry_result_savename(crystal, molecule, temperature,\n                               ljforcefield, insertions_per_volume;\n                               comment=\"\")\n\nDetermine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\nArguments\n\ncrystal::Crystal: The porous crystal being tested\nmolecule::Molecule: The molecule being tested inside the crystal\ntemperature::Float64: The temperature used in the simulation units: Kelvin (K)\nljforcefield::LJForceField: The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces\ninsertions_per_volume::Union{Int, Float64}: The number of widom insertions per unit volume.   Will be scaled according to the crystal we're working with\ncomment::AbstractString: An optional comment that will be appended to the filename\n\n\n\n\n\n","category":"function"},{"location":"matter/#Matter-and-Coordinates","page":"matter","title":"Matter and Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Atoms and Charges are the building blocks of Crystals and Molecules in PorousMaterials.jl. Each have coordinates in both Cartesian and Fractional space (associated with unit cell information, i.e., a Box).","category":"page"},{"location":"matter/#Coordinates","page":"matter","title":"Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"we store coordinates as an abstract Coords type that has two subtypes: Cart and Frac for Cartesian and Fractional, respectively. see the Wikipedia page on fractional coordinates, which are defined in the context of a periodic system, e.g. within a crystal.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"construct coordinates of n particles by passing a n by 3 array ","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coord = Cart([1.0, 2.0, 5.0])  # construct cartesian coordinate of a particle\ncoord.x                        # 3 x 1 array, [1, 2, 3]\n\ncoord = Frac([0.1, 0.2, 0.5])  # construct fractional coordinate of a particle\ncoord.xf                       # 3 x 1 array, [0.1, 0.2, 0.3]","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"the coordinates of multiple particles are stored column-wise:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords = Cart(rand(3, 5))      # five particles at uniform random coordinates","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"many Array operations work on Coords, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords[2]                      # coordinate of 2nd particle\ncoords[2:3]                    # (slicing by index) coords of particles 2 and 3\ncoords[[1, 2, 5]]              # (slicing by index) coords of particles 1, 2, and 5\ncoords[rand(Bool, 5)]          # (boolean slicing) coords, selected at random\nlength(coords)                 # number of particles, (5)","category":"page"},{"location":"matter/#manipulating-coordinates","page":"matter","title":"manipulating coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Coords are immutable:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x = rand(3, 3)          # fails! coordinates are immutable","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"but we can manipulate the values of Array{Float64, 2} where coordinates (through coords.x or coords.xf) are stored:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x[2, 3] = 100.0         # successful!\ncoords.x[:] = rand(3, 3)       # successful! (achieves the above, but need the [:] to say \"overwrite all of the elements\"","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"fractional coordinates can be wrapped to be inside the unit cell box:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords = Frac([1.2, -0.3, 0.9])\nwrap!(coords)\ncoords.xf                      # [0.2, 0.7, 0.9]","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can translate coordinates by a vector dx:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Cart([1.0, 2.0, 3.0])\ncoords = Cart([1.0, 0.0, 0.0])  \ntranslate_by!(coords, dx)\ncoords.x                        # [2.0, 2.0, 3.0]","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"if dx::Frac and coords::Cart, translate_by! requires a Box to convert between fractional and cartesian, as the last argument:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Frac([0.1, 0.2, 0.3])\nbox = unit_cube()\ncoords = Cart([1.0, 0.0, 0.0])\ntranslate_by!(coords, dx)       # fails! need to know Box...\ntranslate_by!(coords, dx, box)\ncoords.x                        # [1.1, 0.2, 0.3]","category":"page"},{"location":"matter/#Atoms","page":"matter","title":"Atoms","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"an atom is specified by its coordinates and atomic species. we can construct a set of atoms (perhaps, comprising a molecule or crystal) as follows.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"species = [:O, :H, :H]            # atomic species are represnted with Symbols\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of each\n               0.0 0.586  0.586; \n               0.0 0.0    0.0   ]\n             )\natoms = Atoms(species, coords)    # 3 atoms comprising water\natoms.n                           # number of atoms, 3\natoms.coords                      # coordinates; atoms.coords.x gives the array of coords\natoms.species                     # array of species\natoms::Atoms{Cart}                # successful type assertion, as opposed to atoms::Atoms{Frac}","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"the last line illustrates the two subtypes of Atoms, depending on whether the Coords are stored as Fractional or Cartesian.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can slice atoms, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms[1]                         # 1st atom\natoms[2:3]                       # 2nd and 3rd atom","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"and combine them:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms_combined = atoms[1] + atoms[2:3]   # combine atoms 1, 2, and 3\nisapprox(atoms, atoms_combined)          # true","category":"page"},{"location":"matter/#Charges","page":"matter","title":"Charges","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Charges, well, point charges, work analogously to atoms, except instead of species, the values of the point charges are stored in an array, q.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"q = [-1.0, 0.5, 0.5]              # values of point charges, units: electrons\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of the point charges\n               0.0 0.586  0.586; \n               0.0 0.0    0.0   ]\n             )\ncharges = Charges(q, coords)      # 3 point charges\ncharges.n                         # number of charges, 3\ncharges.coords                    # retreive coords\ncharges.q                         # retreive q\ncharges::Charges{Cart}            # successful type assertion, as opposed to charges::Charges{Frac}","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"we can determine if the set of point charges comprise a charge-neutral system by:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"net_charge(charges)                 # 0.0\nneutral(charges)                    # true","category":"page"},{"location":"matter/#detailed-docs","page":"matter","title":"detailed docs","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"    Coords\n    Frac\n    Cart\n    Atoms\n    Charges\n    net_charge\n    neutral\n    translate_by!","category":"page"},{"location":"matter/#PorousMaterials.Coords","page":"matter","title":"PorousMaterials.Coords","text":"abstract type for coordinates.\n\n\n\n\n\n","category":"type"},{"location":"matter/#PorousMaterials.Cart","page":"matter","title":"PorousMaterials.Cart","text":"cartesian coordinates, a subtype of Coords.\n\nconstruct by passing an Array{Float64, 2} whose columns are the coordinates.\n\ne.g.\n\nc_coords = Cart(rand(3, 2))  # 2 particles\nc_coords.x                   # retreive cartesian coords\n\n\n\n\n\n","category":"type"},{"location":"matter/#PorousMaterials.Atoms","page":"matter","title":"PorousMaterials.Atoms","text":"used to represent a set of atoms in space (their atomic species and coordinates).\n\nstruct Atoms{T<:Coords} # enforce that the type specified is `Coords`\n    n::Int # how many atoms?\n    species::Array{Symbol, 1} # list of species\n    coords::T # coordinates\nend\n\nhere, T is Frac or Cart.\n\nhelper constructor (infers n):\n\nspecies = [:H, :H]\ncoords = Cart(rand(3, 2))\natoms = Atoms(species, coords)\n\n\n\n\n\n","category":"type"},{"location":"matter/#PorousMaterials.Charges","page":"matter","title":"PorousMaterials.Charges","text":"used to represent a set of partial point charges in space (their charges and coordinates).\n\nstruct Charges{T<:Coords} # enforce that the type specified is `Coords`\n    n::Int\n    q::Array{Float64, 1}\n    coords::T\nend\n\nhere, T is Frac or Cart.\n\nhelper constructor (infers n):\n\nq = [0.1, -0.1]\ncoords = Cart(rand(3, 2))\ncharges = Charges(q, coords)\n\n\n\n\n\n","category":"type"},{"location":"matter/#PorousMaterials.net_charge","page":"matter","title":"PorousMaterials.net_charge","text":"nc = net_charge(charges)\nnc = net_charge(crystal)\nnc = net_charge(molecule)\n\nfind the sum of charges in charges::Charges or charges in crystal::Crystal or molecule::Molecule. (if there are no charges, the net charge is zero.)\n\n\n\n\n\n","category":"function"},{"location":"matter/#PorousMaterials.neutral","page":"matter","title":"PorousMaterials.neutral","text":"neutral(charges, tol) # true or false. default tol = 1e-5\nneutral(crystal, tol) # true or false. default tol = 1e-5\n\ndetermine if a set of charges::Charges (charges.q) sum to an absolute value less than tol::Float64. if crystal::Crystal is passed, the function looks at the crystal.charges. i.e. determine the absolute value of the net charge is less than tol.\n\n\n\n\n\n","category":"function"},{"location":"matter/#PorousMaterials.translate_by!","page":"matter","title":"PorousMaterials.translate_by!","text":"translate_by!(coords, dx)\ntranslate_by!(coords, dx, box)\ntranslate_by!(molecule, dx)\ntranslate_by!(molecule, dx, box)\n\ntranslate coords by the vector dx. that is, add the vector dx.\n\nthis works for any combination of Frac and Cart coords.\n\nmodifies coordinates in place.\n\nbox is needed when mixing Frac and Cart coords.\n\nnote that periodic boundary conditions are not subsequently applied here.\n\nif applied to a molecule::Molecule, the coords of atoms, charges, and center of mass are all translated.\n\n\n\n\n\n","category":"function"},{"location":"molecule/#Molecules","page":"molecules","title":"Molecules","text":"","category":"section"},{"location":"molecule/#Loading-Molecule-Files","page":"molecules","title":"Loading Molecule Files","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"Molecule input files are stored in PorousMaterials.PATH_TO_MOLECULES. Each molecule possesses its own directory containing two files: charges.csv and atoms.csv, comma-separated-value files, which describe the point charges and Lennard Jones spheres, respectively, that compose the molecule. Only rigid molecules are currently supported. Units of length are in Angstroms (AA); units of charges are electrons.","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"using PorousMaterials\n\nmolecule = Molecule(\"CO2\")","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"PorousMaterials will then output information about the molecule you just loaded:","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"Molecule species: CO2\nCenter of mass (fractional coords): Cart([0.0; 0.0; 0.0])\nAtoms:\n\n\tatom = C_CO2, x = [0.000, 0.000, 0.000]\n\tatom = O_CO2, x = [-1.160, 0.000, 0.000]\n\tatom = O_CO2, x = [1.160, 0.000, 0.000]\nPoint charges: \n\tcharge = 0.700000, x = [0.000, 0.000, 0.000]\n\tcharge = -0.350000, x = [-1.160, 0.000, 0.000]\n\tcharge = -0.350000, x = [1.160, 0.000, 0.000]","category":"page"},{"location":"molecule/#Building-Blocks-of-PorousMaterials:-Molecules","page":"molecules","title":"Building Blocks of PorousMaterials: Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"molecule = Molecule(\"CO2\") # fractional coords in terms of unit cube box\n\n# access the attributes that comprise the molecule object\nmolecule.species   # molecule species\nmolecule.com       # center-of-mass\nmolecule.atoms     # Lennard-Jones spheres\nmolecule.charges   # point charges ","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"To see specific information about the atoms and charges attributes of the molecule see Atoms and Charges.","category":"page"},{"location":"molecule/#Moving-Molecules","page":"molecules","title":"Moving Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"We can translate and roatate a molecule:","category":"page"},{"location":"molecule/","page":"molecules","title":"molecules","text":"using PorousMaterials\n\n# load a molecule and convert it to Molecule{Frac}\nmolecule = Molecule(\"CO2\")\nmolecule = Frac(molecule, unit_cube())\n\n# translate center-of-mass to [1.0, 2.0, 3.0] in fractional coordinates\nx = Cart([1.0, 2.0, 3.0])\ntranslate_to!(molecule, x, unit_cube())\n\n# translate by [0.1, 0.0, 0.0] in fractional coordinates\ndx = Cart([0.1, 0.0, 0.0])\ntranslate_by!(molecule, dx, unit_cube())\n\n# conduct a uniform random rotation about the center-of-mass\nrandom_rotation!(molecule, unit_cube()) ","category":"page"},{"location":"molecule/#detailed-docs","page":"molecules","title":"detailed docs","text":"","category":"section"},{"location":"molecule/#Molecules-2","page":"molecules","title":"Molecules","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"    Molecule\n    translate_to!\n    random_rotation!\n    random_rotation_matrix()\n    ion\n    distortion","category":"page"},{"location":"molecule/#PorousMaterials.Molecule","page":"molecules","title":"PorousMaterials.Molecule","text":"Data structure for a molecule/adsorbate.\n\nAttributes\n\nspecies::Symbol: Species of molecule, e.g. :CO2\natoms::Atoms: array of Lennard-Jones spheres comprising the molecule\ncharges::Charges: array of point charges comprising the molecule\ncom::Coords: center of mass\n\n\n\n\n\n","category":"type"},{"location":"molecule/#PorousMaterials.translate_to!","page":"molecules","title":"PorousMaterials.translate_to!","text":"translate_to!(molecule, xf)\ntranslate_to!(molecule, x)\ntranslate_to!(molecule, xf, box)\ntranslate_to!(molecule, x, box)\n\nTranslate a molecule so that its center of masss is at a point xf in fractional coordinate space or at x in Cartesian coordinate space. For the latter, a unit cell box is required for context.\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_rotation!","page":"molecules","title":"PorousMaterials.random_rotation!","text":"random_rotation!(molecule{Frac}, box)\nrandom_rotation!(molecule{Cart})\n\nrandomly rotate a molecule about its center of mass.\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_rotation_matrix-Tuple{}","page":"molecules","title":"PorousMaterials.random_rotation_matrix","text":"r = random_rotation_matrix() # rotation matrix in cartesian coords\n\nGenerate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x,  this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x). the point x is in Cartesian coordinates here. See James Arvo. Fast Random Rotation Matrices.\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\nReturns\n\nr::Array{Float64, 2}: A 3x3 random rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"molecule/#PorousMaterials.ion","page":"molecules","title":"PorousMaterials.ion","text":"molecule = ion(q, coords)\n\nFacilitate constructing a point charge by constructing a molecule: Molecule(:ion, Atoms{Frac}(0), Charges(q, coords), coords)\n\nArguments\n\nq::Float64: value of point charge, units: electrons\ncoords::Frac: fractional coordinates of the charge\n\nReturns\n\nmolecule::Molecule{Frac}: the ion as a molecule with Fractional coordinates\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.distortion","page":"molecules","title":"PorousMaterials.distortion","text":"is_distorted = distortion(molecule, ref_molecule, box; \n                          atol=1e-12, throw_warning=true)\n\nDetermine whether a molecule has distortion w.r.t. a reference molecule via pairwise distance comparison of the atoms and charges coordinates.\n\nArguments\n\nmolecule::Molecule{Frac}: molecule you want to compare\nref_molecule::Molecule{Frac}: reference molecule\nbox::Box: box used for the fractional coordinates\natol::Float64=1e-12: absolute tolerance for distance comparison\nthrow_warning::Bool=true: issue a warning if there is distortion\n\nReturns\n\nis_distorted::Bool: true if there is distortion w.r.t. reference molecule \n\n\n\n\n\n","category":"function"},{"location":"molecule/#Molecular-Movement","page":"molecules","title":"Molecular Movement","text":"","category":"section"},{"location":"molecule/","page":"molecules","title":"molecules","text":"    apply_periodic_boundary_condition!\n    random_insertion!\n    remove_molecule!\n    random_translation!\n    random_reinsertion!\n    needs_rotations","category":"page"},{"location":"molecule/#PorousMaterials.apply_periodic_boundary_condition!","page":"molecules","title":"PorousMaterials.apply_periodic_boundary_condition!","text":"apply_periodic_boundary_condition!(molecule::Molecule{Frac})\n\nCheck if each of a molecule's center-of-mass coordinates is within the bounds (0.0, 1.0) in fractional coordinates, and translate if needed.  \n\nArguments\n\nmolecule::Molecule{Frac}: the molecule to be checked\n\nReturns\n\nnothing, if the molecule is within the boundary; ohterwise, the coordinates of the input molecule will be modified\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_insertion!","page":"molecules","title":"PorousMaterials.random_insertion!","text":"random_insertion!(molecules::Array{Molecule{Frac}, 1}, box::Box, template::Molecule{Cart})\n\nInsert a molecule into the simulation box and perform a random rotation if needed.\n\nArguments\n\nmolecules::Array{Molecule{Frac}, 1}: array containing the molecules in the simulation\nbox::Box: the box  used for fractional coordinats\ntemplate::Molecule{Cart}: reference molecule of the type inserted\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.remove_molecule!","page":"molecules","title":"PorousMaterials.remove_molecule!","text":"remove_molecule!(molecule_id, molecules)\n\nRemove a molecule from the array of molecules.\n\nArguments\n\nmolecule_id::Int: the ID of the molecule to be removed\nmolecules::Array{<:Molecule, 1}: array of molecules to be modified\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_translation!","page":"molecules","title":"PorousMaterials.random_translation!","text":"random_reinsertion!(molecule, box)\n\nPerform a translational perturbation in Cartesian coordinates on a molecule, apply the periodic boundry conditions, and keep a copy of the original in case it needs to be restored.\n\nArguements\n\nmolecule::Molecule{Frac}: molecule to be translated\nbox::Box: the box used in rotation\n\nReturns\n\nold_molecule::Molecule{Frac}: a copy of the original molecule\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.random_reinsertion!","page":"molecules","title":"PorousMaterials.random_reinsertion!","text":"random_reinsertion!(molecule, box)\n\nPerform a translation and rotated (if needed) on a molecule, and keep a copy of the original in case it needs to be restored.\n\nArguements\n\nmolecule::Molecule{Frac}: molecule to be translated and rotated (if needed)\nbox::Box: the box used in rotation\n\nReturns\n\nold_molecule::Molecule{Frac}: a copy of the original molecule\n\n\n\n\n\n","category":"function"},{"location":"molecule/#PorousMaterials.needs_rotations","page":"molecules","title":"PorousMaterials.needs_rotations","text":"needs_rotations(molecule) # true or false\n\nDetermine whether a molecule needs to undergo rotation.\n\n`true` if molecule.atoms.n + molecule.charges.n > 1\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Lennard-Jones-Force-Fields-and-Potential-Energy","page":"forcefields","title":"Lennard-Jones Force Fields and Potential Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Lennard-Jones force field parameters are stored in comma-separated-value format in PorousMaterials.PATH_TO_FORCEFIELDS.","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Interaction of an adsorbate with the crystal is modeled as pair-wise additive and with Lennard-Jones potentials of the form:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"V(r) = 4 * ϵ * [ x ^ 12 - x ^ 6 ], where x = σ / r","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"The Lennard-Jones force field input files, e.g. UFF.csv contain a list of pure (i.e. X-X, where X is an atom) sigmas (σ) and epsilons (ϵ) with units Angstrom (Å) and Kelvin (K), respectively. Note that, e.g., in the UFF paper, the Lennard-Jones potential is written in a different form; thus, parameters need to be converted to correspond to the functional form used in PorousMaterials.jl.","category":"page"},{"location":"force_field/#Building-Blocks-of-PorousMaterials:-Lennard-Jones-Force-Fields","page":"forcefields","title":"Building Blocks of PorousMaterials: Lennard-Jones Force Fields","text":"","category":"section"},{"location":"force_field/#Loading-Force-Field-Files-and-Accessing-Attributes","page":"forcefields","title":"Loading Force Field Files and Accessing Attributes","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Reading in Lennard-Jones force field parameters is made easy with the LJForceField function. Let's load in the parameters from the Universal Force Field file (UFF.csv):","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"using PorousMaterials\n\n# read in Lennard-Jones force field parameters from the Universal Force Field\nljforcefield = LJForceField(\"UFF\", r_cutoff=14.0, mixing_rules=\"Lorentz-Berthelot\")","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"PorousMaterials will then output information about the force field file you just loaded:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    Force field: UFF\n    Number of atoms included: 106\n    Cut-off radius (Å) = 14.0","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"This also prints all of the atoms included in the loaded forcefield with their given ϵ and σ. This was excluded because it would use too much space on this page. ","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"We can access attributes LJForceField such as pure_σ, pure_ϵ, and interaction values:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"# access the Lennard-Jones epsilon & sigma for Xe \nljforcefield.pure_ϵ[:Xe] # K\nljforcefield.pure_σ[:Xe] # Å\n\n# access the Lennard-Jones epsilon & sigma for Xe-C interactions\nljforcefield.ϵ[:Xe][:C]  # K\nljforcefield.σ²[:Xe][:C] # Å (store σ² for faster computation)","category":"page"},{"location":"force_field/#Checking-Force-Field-Coverage","page":"forcefields","title":"Checking Force Field Coverage","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"When running simulations, it is necessary to have the force field terms for all of the atoms. This can be checked using forcefield_coverage:","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"using PorousMaterials\n\nljforcefield = LJForceField(\"UFF\")\n\nxtal = Crystal(\"SBMOF-1.cif\")\nstrip_numbers_from_atom_labels!(xtal)\n\n# check is the atoms in the crystal are covered\nforcefield_coverage(xtal, ljforcefield)\n\nmolecule = Molecule(\"CO2\")\n\n# check if the atoms in the molecule are covered\nforcefield_coverage(molecule, ljforcefield)","category":"page"},{"location":"force_field/#Simulation-Box-and-the-Cutoff-Radius","page":"forcefields","title":"Simulation Box and the Cutoff Radius","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"Find the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius.In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop.The replication_factors function ensures enough replication factors such that the nearest image convention can be applied.","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"using PorousMaterials\n\nljforcefield = LJForceField(\"UFF\")\n\nxtal = Crystal(\"SBMOF-1.cif\")\n\nr_cutoff = 14.0 # Å\nrepfactors = replication_factors(xtal.box, r_cutoff) ","category":"page"},{"location":"force_field/#Potential-Energies:-Van-der-Waals","page":"forcefields","title":"Potential Energies: Van der Waals","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at Cartesian coordinates [0.0, 1.0, 3.0] using the UFF as a molecular model?","category":"page"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"using PorousMaterials\n\nxtal = Crystal(\"SBMOF-1.cif\")\nstrip_numbers_from_atom_labels!(xtal)\n\nljforcefield = LJForceField(\"UFF\")\n\n# load molecule and convert it to fractional\nmolecule = Molecule(\"Xe\")\nmolecule = Frac(molecule, xtal.box) \n\ntranslate_to!(molecule, Cart([0.0, 1.0, 3.0]), xtal.box) # need box b/c we're in Cartesian\n\nenergy = vdw_energy(xtal, molecule, ljforcefield) # K","category":"page"},{"location":"force_field/#detailed-docs","page":"forcefields","title":"detailed docs","text":"","category":"section"},{"location":"force_field/#Forcefields","page":"forcefields","title":"Forcefields","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    LJForceField\n    replication_factors\n    forcefield_coverage","category":"page"},{"location":"force_field/#PorousMaterials.LJForceField","page":"forcefields","title":"PorousMaterials.LJForceField","text":"Data structure for a Lennard Jones forcefield.\n\nAttributes\n\nname::String: name of forcefield; correponds to filename\npure_σ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones σ of an X-X interaction, where X is an atom. (units: Angstrom)\npure_ϵ::Dict{Symbol, Float64}: Dictionary that returns Lennard-Jones ϵ of an X-X interaction, where X is an atom. (units: K)\nσ²::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones σ² (units: Angstrom²) for cross-interactions. Example use is sigmas_squared[:He][:C]\nϵ::Dict{Symbol, Dict{Symbol, Float64}}: Lennard Jones ϵ (units: K) for cross-interactions. Example use is epsilons[:He][:C]\nr²_cutoff::Float64: The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom²). We store σ² to speed up computations, which involve σ², not σ.\n\n\n\n\n\n","category":"type"},{"location":"force_field/#PorousMaterials.replication_factors","page":"forcefields","title":"PorousMaterials.replication_factors","text":"repfactors = replication_factors(unitcell, r_cutoff)\n\nFind the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied.\n\nA non-replicated supercell has 1 as the replication factor in each dimension (repfactors = (1, 1, 1)).\n\nArguments\n\nunitcell::Box: The unit cell of the crystal\nr_cutoff::Float64: Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom)\n\nReturns\n\nrepfactors::Tuple{Int, Int, Int}: The replication factors in the a, b, c directions\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.forcefield_coverage","page":"forcefields","title":"PorousMaterials.forcefield_coverage","text":"forcefield_coverage(atoms, ljforcefield)\nforcefield_coverage(molecule, ljforcefield)\nforcefield_coverage(crystal, ljforcefield)\n\nCheck that the force field contains parameters for every species in atoms::Atoms. Will print out which atoms are missing.\n\nArguments\n\natoms::Atoms: a set of atoms\nljforcefield::LJForceField: A Lennard Jones forcefield object containing information on atom interactions\n\nReturns\n\nall_covered::Bool: returns true if all species in the atoms are covered by the force field.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Potential-Energy","page":"forcefields","title":"Potential Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    PotentialEnergy\n    SystemPotentialEnergy","category":"page"},{"location":"force_field/#Nearest-Image-Conventions","page":"forcefields","title":"Nearest Image Conventions","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    nearest_image!","category":"page"},{"location":"force_field/#PorousMaterials.nearest_image!","page":"forcefields","title":"PorousMaterials.nearest_image!","text":"nearest_image!(dxf)\n\nApplies the nearest image convention on a vector dxf between two atoms in fractional space; modifies dxf for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space.\n\nWarning: this assumes the two molecules are in the box described by fractional coords [0, 1]³.\n\nArguments\n\ndxf::Array{Float64}: A vector between two atoms in fractional space\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Electrostatics-Energy","page":"forcefields","title":"Electrostatics Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    Eikr\n    total\n    electrostatic_potential\n    electrostatic_potential_energy\n    precompute_kvec_wts\n    setup_Ewald_sum\n    total_electrostatic_potential_energy","category":"page"},{"location":"force_field/#PorousMaterials.Eikr","page":"forcefields","title":"PorousMaterials.Eikr","text":"eikr = Eikr(eikar, eikbr, eikcr)\n\nmutable struct for holding the eikr vectors\n\nAttributes\n\neikar::OffsetArray{Complex{Float64}}: array for storing e^{i * ka ⋅ r}; has indices   0:kreps[1] and corresponds to recip. vectors in a-direction\neikbr::OffsetArray{Complex{Float64}}: array for storing e^{i * kb ⋅ r}; has indices   -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction\neikcr::OffsetArray{Complex{Float64}}: array for storing e^{i * kc ⋅ r}; has indices   -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction\n\n\n\n\n\n","category":"type"},{"location":"force_field/#PorousMaterials.electrostatic_potential_energy","page":"forcefields","title":"PorousMaterials.electrostatic_potential_energy","text":"ϕ = electrostatic_potential_energy(crystal, molecule, eparams, eikr)\n\nCompute the electrostatic potential energy of a molecule inside a crystal.\n\nThe electrostatic potential is created by the point charges assigned to the crystal atoms in crystal.charges. Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at differences in energy in a Monte Carlo simulation.\n\nWarning: it is assumed that the crystal is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in eparams.sr_cutoff_r.\n\nArguments\n\ncrystal::Crystal: Crystal structure (see crystal.charges for charges)\nmolecule::Molecule: The molecule being compared to the atoms in the crystal.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\npot::EwaldSum: Electrostatic potential between crystal and molecule (units: K)\n\n\n\n\n\nϕ = electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCompute the electrostatic potential energy of a system comprised of an array of Molecules.\n\nThe EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive.\n\nReturns an EwaldSum type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (ϕ.sr, ϕ.lr, ϕ.self, ϕ.intra).\n\nUnits of energy: Kelvin\n\nArguments\n\nmolecules::Array{Molecules, 1}: array of molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: the box the energy is being computed in\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.precompute_kvec_wts","page":"forcefields","title":"PorousMaterials.precompute_kvec_wts","text":"kvectors = precompute_kvec_wts(kreps, box, α, max_mag_k_sqrd=Inf)\n\nFor speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry:     cos(-k⋅(x-xᵢ)) + cos(k⋅(x-xᵢ)) = 2 cos(k⋅(x-xᵢ))\n\nIf max_mag_k_sqrd is passed, k-vectors with a magnitude greater than max_mag_k_sqrd are not included.\n\nArguments\n\nkreps::Tuple{Int, Int, Int}: number of k-vector replications required in a, b, c\nbox::Box: the simulation box containing the reciprocal lattice.\nα::Float64: Ewald sum convergence parameter (units: inverse Å)\nmax_mag_k_sqrd::Float64: cutoff for |k|² in Fourier sum; if passed, do not include\n\nk-vectors with magnitude squared greater than this.\n\nReturns\n\nkvectors::Array{Kvector, 1}: array of k-vectors to include in the Fourier sum and their\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.setup_Ewald_sum","page":"forcefields","title":"PorousMaterials.setup_Ewald_sum","text":"eparams = setup_Ewald_sum(box, sr_cutoff_r; ϵ=1e-6, verbose=false)\n\nGiven the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information.\n\nAlso, pre-compute weights on k-vector contributions to Ewald sum in Fourier space.\n\nAlso, allocate OffsetArrays for storing e^{i * k ⋅ r} where r = x - xⱼ and k is a reciprocal lattice vector.\n\nArguments\n\nbox::Box: the simulation box containing the reciprocal lattice.\nsr_cutoff_r::Float64: cutoff-radius (units: Å) for short-range contributions to Ewald\nϵ::Float64: desired level of precision. Typical value is 1e-6, but this does not\nverbose::Bool: If true will print results\n\nReturns\n\neparams::EwaldParams: data structure containing Ewald summation settings\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.total_electrostatic_potential_energy","page":"forcefields","title":"PorousMaterials.total_electrostatic_potential_energy","text":"total_ϕ = total_electrostatic_potential_energy(molecules, eparams, box, eikr)\n\nCalculates the total electrostatic potential energy of an array of Molecules using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this\n\nArguments\n\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\nbox::Box: The box the energy is being computed in.\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\nReturns\n\nϕ::GGEwaldSum: The total electrostatic potential energy\n\n\n\n\n\ntotal_ϕ = total_electrostatic_potential_energy(crystal, molecules, eparams, eikr)\n\nExplanation of totalelectrostaticpotential_energy that uses crystal\n\nArguments\n\ncrystal::Crystal: Crystal structure (see crystal.charges for charges)\nmolecules::Array{Molecule, 1}: The molecules comprising the system.\neparams::EwaldParams: data structure containing Ewald summation settings\neikr::Eikr: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\n\n","category":"function"},{"location":"force_field/#Van-der-Waals-Energy","page":"forcefields","title":"Van der Waals Energy","text":"","category":"section"},{"location":"force_field/","page":"forcefields","title":"forcefields","text":"    lennard_jones\n    vdw_energy\n    vdw_energy_no_PBC","category":"page"},{"location":"force_field/#PorousMaterials.lennard_jones","page":"forcefields","title":"PorousMaterials.lennard_jones","text":"energy = lennard_jones(r², σ², ϵ)  (units: Kelvin)\n\nCalculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. σ and ϵ are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of ϵ are).\n\nArguments\n\nr²::Float64: distance between two (pseudo)atoms in question squared (Angstrom²)\nσ²::Float64: sigma parameter in Lennard Jones potential squared (units: Angstrom²)\nϵ::Float64: epsilon parameter in Lennard Jones potential (units: Kelvin)\n\nReturns\n\nenergy::Float64: Lennard Jones potential energy\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.vdw_energy","page":"forcefields","title":"PorousMaterials.vdw_energy","text":"energy = vdw_energy(crystal, molecule, ljforcefield)\n\nCalculates the van der Waals interaction energy between a molecule and a crystal. Applies the nearest image convention to find the closest replicate of a specific atom.\n\nWARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See replicate and replication_factors.\n\n\n\n\n\nggenergy = vdwenergy(moleculeid, molecules, ljforcefield, simulationbox)\n\nCalculates van der Waals interaction energy of a single adsorbate molecules[molecule_id] with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention.\n\nArguments\n\nmolecule_id::Int: Molecule ID used to determine which molecule in molecules we wish to calculate the guest-guest interactions\nmolecules::Array{Molecule, 1}: An array of Molecule data structures\nljforcefield::LJForceField: A Lennard Jones forcefield data structure describing the interactions between different atoms\nsimulation_box::Box: The simulation box for the computation.\n\nReturns\n\ngg_energy::Float64: The guest-guest interaction energy of molecules[molecule_id] with the other molecules in molecules\n\n\n\n\n\n","category":"function"},{"location":"force_field/#PorousMaterials.vdw_energy_no_PBC","page":"forcefields","title":"PorousMaterials.vdw_energy_no_PBC","text":"potenergy = vdwenergynoPBC(atomsi, atomsj , ljff)\n\ncompute vdw potential energy without periodic boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"eos/#Equation-of-State","page":"equations of state","title":"Equation of State","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"PorousMaterials.jl provides Peng-Robinson and van der Waals equation of state calculations to find the properties of a real fluid.","category":"page"},{"location":"eos/#Peng-Robinson-equation-of-state","page":"equations of state","title":"Peng-Robinson equation of state","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The Peng-Robinson equation of state can be written as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where V_m is the molar volume, R is the gas constant, and T is temperature.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"Variables a and b can be calculated using the critical temperature, T_c and pressure, P_c, of the fluid:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_a)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_b)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"and alpha can be calculated using acentric factor omega and critical temperature:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_alpha)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_kappa)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"and","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: PREOS_Tr)","category":"page"},{"location":"eos/#Van-der-Waals-equation-of-state","page":"equations of state","title":"Van der Waals equation of state","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The van der Waals equation can be written as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"(Image: VDWEOS)","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"where a and b are the van der Waals constants. a and b can be calculated from fluid critical propertis, but PorousMaterials.jl reads them in as experimentally determined values.","category":"page"},{"location":"eos/#reading-in-fluid-characteristics","page":"equations of state","title":"reading in fluid characteristics","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"PengRobinsonFluid and VdWFluid are structs defining the characteristics of a fluid of interest, depending on which equation of state is used.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For Peng-Robinson fluids, PorousMaterials.jl reads in the critical temperature, critical pressure, and acentric factor of fluid::Symbol from the properties .csv file PorousMaterials.PATH_TO_DATA, \"PengRobinson_fluid_props.csv\").","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For van der Waals fluids, van der Waals constants of fluid::Symbol are read in from the properties .csv file joinpath(PorousMaterials.PATH_TO_DATA, \"VdW_fluid_props.csv\").","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"*** NOTE: DO NOT DELETE LAST THREE COMMENT LINES IN PengRobinson_fluid_props.csv AND VdW_fluid_props.csv","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The characteristics can be read as:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For Peng-Robinson fluids","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"fluid = PengRobinsonFluid(:Xe)       # Input fluid as a symbol. The fluids reader stores the information in fluid as a struct\nfluid.fluid                          # The name of the fluid\nfluid.Pc                             # The critical pressure of the fluid\nfluid.Tc                             # The critical temperature of the fluid\nfluid.ω                              # The acentric factor of the fluid","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"For van der Waals fluids","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"fluid = VdWFluid(:Xe)                # Input fluid as a symbol. The fluids reader stores the information in fluid as a struct\nfluid.fluid                          # The name of the fluid\nfluid.a                              # The van der Waals constant a of the fluid\nfluid.b                              # The van der Waals constant b of the fluid","category":"page"},{"location":"eos/#calculating-density,-fugacity,-and-molar-volume","page":"equations of state","title":"calculating density, fugacity, and molar volume","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"Using a given temperature and pressure, PorousMaterials.jl the equation of state can be used to calculate the dnesity, fugacity, and molar volume of a real fluid, stored as a dictionary.","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"T = 298.0 # K                        # The temperature in Kelvin of interest type Float64.\nP = 1.0 # bar                        # The pressure in bar of interest type Float64.\nprops = calculate_properties(fluid, T, P, verbose=true) # verbose::Bool will print results if `true`","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"The output is a dictionary containing the following keys:","category":"page"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"props[\"compressibility factor\"]      # the compressibility factor\nprops[\"density [mol/$m^{3}$]\"]       # fluid density in mol/$m^{3}$\nprops[\"fugacity [bar]\"]              # the fugacity in bar\nprops[\"fugacity coefficient\"]        # the fugacity coefficient\nprops[\"molar volume [L/mol]\"]        # the molar volume in L/mol","category":"page"},{"location":"eos/#details","page":"equations of state","title":"details","text":"","category":"section"},{"location":"eos/","page":"equations of state","title":"equations of state","text":"    PengRobinsonFluid\n    VdWFluid\n    calculate_properties","category":"page"},{"location":"eos/#PorousMaterials.PengRobinsonFluid","page":"equations of state","title":"PorousMaterials.PengRobinsonFluid","text":"fluid = PengRobinsonFluid(fluid)\n\nReads in critical temperature, critical pressure, and acentric factor of the fluid::Symbol from the properties .csv file joinpath(PorousMaterials.PATH_TO_DATA, \"PengRobinson_fluid_props.csv\") and returns a complete PengRobinsonFluid data structure. **NOTE: Do not delete the last three comment lines in PengRobinsonfluidprops.csv\n\nArguments\n\nfluid::Symbol: The fluid molecule you wish to construct a PengRobinsonFluid struct for\n\nReturns\n\nPengRobinsonFluid::struct: Data structure containing Peng-Robinson fluid parameters.\n\n\n\n\n\n","category":"type"},{"location":"eos/#PorousMaterials.VdWFluid","page":"equations of state","title":"PorousMaterials.VdWFluid","text":"fluid = VdWFluid(fluid)\n\nReads in van der Waals constants of the fluid::Symbol from the properties .csv file joinpath(PorousMaterials.PATH_TO_DATA, \"VdW_fluid_props.csv\") and returns a complete VdWFluid data structure. ***NOTE: Do not delete the last three comment lines in VdWfluidprops.csv\n\nArguments\n\nfluid::Symbol: The fluid you wish to construct a VdWFluid struct for\n\nReturns\n\nVdWFluid::struct: Data structure containing van der Waals constants\n\n\n\n\n\n","category":"type"},{"location":"eos/#PorousMaterials.calculate_properties","page":"equations of state","title":"PorousMaterials.calculate_properties","text":"props = calculate_properties(fluid, T, P, verbose=true)\n\nUse equation of state to calculate density, fugacity, and molar volume of a real fluid at a given temperature and pressure.\n\nArguments\n\nfluid::Union{PengRobinsonFluid, VdWFluid}: Peng-Robinson/ van der Waals fluid data structure\nT::Float64: Temperature (units: Kelvin)\nP::Float64: Pressure (units: bar)\nverbose::Bool: will print results if true\n\nReturns\n\nprop_dict::Dict: Dictionary of Peng-Robinson/ van der Waals fluid properties\n\n\n\n\n\n","category":"function"},{"location":"box/#The-Spatial-Box","page":"boxes","title":"The Spatial Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Within PorousMaterials.jl, the 3D space in which all Coords are located is the Box.  Each Crystal has its own Box, equivalent to the unit cell of a material, containing as attributes the unit cell edge lengths (a b c), crystallographic dihedral angles (α β γ), volume, conversion factors for translating between Fractional and Cartesian coordinates, and the reciprocal (Fourier transform) vectors for the Bravais lattice.","category":"page"},{"location":"box/#defining-a-box","page":"boxes","title":"defining a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box is most conveniently constructed from its basic spatial data (a b c α β γ).  For example, given the unit cell of Co-MOF-74, we can define its Box:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"a = 26.13173 # Å\nb = 26.13173\nc = 6.722028\nα = π/2 # radians\nβ = π/2\nγ = 2*π/3\nbox = Box(a, b, c, α, β, γ)","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box may also be defined by providing only the Fractional-to-Cartesian conversion matrix:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"box = Box([26.1317 -13.0659 0; 0 22.6307 0; 0 0 6.72203])","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"To quickly get a simple unit-cubic Box, use the unit_cube function.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"@info unit_cube()\n#┌ Info: Bravais unit cell of a crystal.\n#│       Unit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 90.000000 deg.\n#│       Unit cell dimensions a = 1.000000 Å. b = 1.000000 Å, c = 1.000000 Å\n#└       Volume of unit cell: 1.000000 Å³","category":"page"},{"location":"box/#transforming-coordinates","page":"boxes","title":"transforming coordinates","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Conversions are provided for switching between Fractional and Cartesian Coords using the Box (works for Atoms and Charges, too)","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"xtal = Crystal(\"Co-MOF-74.cif\")\nCart(xtal.atoms.coords, xtal.box)\n#Cart([-5.496156112249995 7.181391379950001 … 15.131970232450003 2.4686645331000063;\n# 22.270234304380295 2.8331425940892103 … 0.7607701110682343 22.13256395706254;\n# 1.231811631 0.32198514120000005 … 6.2082409932000004 2.2119953472])","category":"page"},{"location":"box/#replicating-a-box","page":"boxes","title":"replicating a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For simulations in larger volumes than a single crystallograhic unit cell, the Box may be replicated along each or any of the three crystallographic axes.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"replicated_box = replicate(box, (2,2,2))","category":"page"},{"location":"box/#exporting-a-box","page":"boxes","title":"exporting a box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For visualization of the unit cell boundaries, the Box may be written out to a .vtk file for use in Visit","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"write_vtk(box, \"box.vtk\")","category":"page"},{"location":"box/#detailed-docs","page":"boxes","title":"detailed docs","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"    Box\n    unit_cube\n    replicate\n    write_vtk\n    Frac","category":"page"},{"location":"box/#PorousMaterials.Box","page":"boxes","title":"PorousMaterials.Box","text":"box = Box(a, b, c, α, β, γ, volume, f_to_c, c_to_f, reciprocal_lattice)\nbox = Box(a, b, c, α, β, γ)\nbox = Box(a, b, c) # α=β=γ=π/2 assumed.\nbox = Box(f_to_c)\n\nData structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.\n\nAttributes\n\na,b,c::Float64: unit cell dimensions (units: Angstroms)\nα,β,γ::Float64: unit cell angles (units: radians)\nΩ::Float64: volume of the unit cell (units: cubic Angtroms)\nf_to_c::Array{Float64,2}: the 3x3 transformation matrix used to map fractional\n\ncoordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom\n\nc_to_f::Array{Float64,2}: the 3x3 transformation matrix used to map Cartesian\n\ncoordinates to fractional coordinates. units: inverse Angstrom\n\nreciprocal_lattice::Array{Float64, 2}: the rows are the reciprocal lattice vectors.\n\nThis choice was made (instead of columns) for speed of Ewald Sums.\n\n\n\n\n\n","category":"type"},{"location":"box/#PorousMaterials.unit_cube","page":"boxes","title":"PorousMaterials.unit_cube","text":"uc = unit_cube()\n\nThis function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.\n\n\n\n\n\n","category":"function"},{"location":"box/#PorousMaterials.replicate","page":"boxes","title":"PorousMaterials.replicate","text":"new_box = replicate(original_box, repfactors)\n\nReplicates a Box in positive directions to construct a new Box representing a supercell. The original_box is replicated according to the factors in repfactors. Note replicate(original_box, repfactors=(1, 1, 1)) returns same Box. The new fractional coordinates as described by f_to_c and c_to_f still ∈ [0, 1].\n\nArguments\n\noriginal_box::Box: The box that you want to replicate\nrepfactors::Tuple{Int, Int, Int}: The factor you want to replicate the box by\n\nReturns\n\nbox::Box: Fully formed Box object\n\n\n\n\n\nreplicated_crystal = replicate(crystal, repfactors)\n\nreplicate the atoms and charges in a Crystal in positive directions to construct a new Crystal. Note replicate(crystal, (1, 1, 1)) returns the same Crystal. the fractional coordinates will be rescaled to be in [0, 1].\n\narguments\n\ncrystal::Crystal: The crystal to replicate\nrepfactors::Tuple{Int, Int, Int}: The factors by which to replicate the crystal structure in each crystallographic direction (a, b, c).\n\nreturns\n\nreplicated_frame::Crystal: replicated crystal\n\n\n\n\n\n","category":"function"},{"location":"box/#PorousMaterials.write_vtk","page":"boxes","title":"PorousMaterials.write_vtk","text":"write_vtk(box, filename; verbose=true, center_at_origin=false)\nwrite_vtk(framework)\n\nWrite a Box to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a Framework is passed, the Box of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.\n\nAppends \".vtk\" extension to filename automatically if not passed.\n\nArguments\n\nbox::Box: a Bravais lattice\nfilename::AbstractString: filename of the .vtk file output (absolute path)\nframework::Framework: A framework containing the crystal structure information\ncenter_at_origin::Bool: center box at origin if true. if false, the origin is the corner of the box.\nverbose::Bool: Optional argument. If true (default), the output filename is printed to the console.\n\n\n\n\n\n","category":"function"},{"location":"box/#PorousMaterials.Frac","page":"boxes","title":"PorousMaterials.Frac","text":"fractional coordinates, a subtype of Coords.\n\nconstruct by passing an Array{Float64, 2} whose columns are the coordinates.\n\ngenerally, fractional coordinates should be in [0, 1] and are implicitly associated with a Box to represent a periodic coordinate system.\n\ne.g.\n\nf_coords = Frac(rand(3, 2))  # 2 particles\nf_coords.xf                  # retreive fractional coords\n\n\n\n\n\n","category":"type"},{"location":"gcmc/#Grand-canonical-Monte-Carlo-Simulations","page":"grand-canonical Monte Carlo simulations","title":"Grand-canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Simulate the adsorption of CO_2 in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"using PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nxtal = Crystal(\"FIQCEN_clean_min_charges.cif\")\n# remove numbers from atom labels\nstrip_numbers_from_atom_labels!(xtal)\n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nljforcefield = LJForceField(\"UFF\", r_cutoff=12.8)\n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule(\"CO2\")\n\ntemperature = 298.0 # K\npressure = 1.0 # bar\n\n# conduct Grand-Canonical Monte Carlo simulation\nresults, molecules = μVT_sim(xtal, molecule, temperature, pressure, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)\n\n# ... prints stuff\n# results automatically saved to .jld2 load later in one line of code\n\n# returns dictionary for easy querying\nresults[\"⟨N⟩ (molecules/unit cell)\"]   \nresults[\"err ⟨N⟩ (molecules)\"]         \nresults[\"Q_st (K)\"]                     ","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Or, compute the entire adsorption isotherm at once, parallelized across many cores (this works by cleverly queuing a μVT_sim for each pressue across the specified number of cores for optimal efficiency):","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"pressures = [0.2, 0.6, 0.8, 1.0] # bar\n\n# loop over all pressures and compute entire adsorption isotherm in parallel\nresults = adsorption_isotherm(xtal, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:","category":"page"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"# loop over all pressures and run GCMC simulations in series.\n# load in the configurations of the molecules from the previous pressure.\nresults = stepwise_adsorption_isotherm(xtal, molecule, temperature, pressures, forcefield,\n               n_burn_cycles=1000, n_sample_cycles=5000)","category":"page"},{"location":"gcmc/#detailed-docs","page":"grand-canonical Monte Carlo simulations","title":"detailed docs","text":"","category":"section"},{"location":"gcmc/#Grand-Canonical-Monte-Carlo-Simulations","page":"grand-canonical Monte Carlo simulations","title":"Grand-Canonical Monte Carlo Simulations","text":"","category":"section"},{"location":"gcmc/","page":"grand-canonical Monte Carlo simulations","title":"grand-canonical Monte Carlo simulations","text":"    μVT_sim\n    adsorption_isotherm\n    stepwise_adsorption_isotherm\n    μVT_output_filename\n    isotherm_sim_results_to_dataframe","category":"page"},{"location":"gcmc/#PorousMaterials.μVT_sim","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.μVT_sim","text":"results, molecules = μVT_sim(xtal, molecule, temperature, pressure,\n                             ljff; molecules=Molecule[], settings=settings)\n\nRuns a grand-canonical (μVT) Monte Carlo simulation of the adsorption of a molecule in a xtal at a particular temperature and pressure using a Lennard Jones force field.\n\nA cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation.\n\nArguments\n\nxtal::Crystal: the porous xtal in which we seek to simulate adsorption\nmolecule::Molecule: a template of the adsorbate molecule of which we seek to simulate\ntemperature::Float64: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\npressure::Float64: pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material. units: bar   the adsorption\nljff::LJForceField: the molecular model used to describe the\nmolecules::Array{Molecule, 1}: a starting configuration of molecules in the xtal.\nn_burn_cycles::Int: number of cycles to allow the system to reach   equilibrium before sampling.\nn_sample_cycles::Int: number of cycles used for sampling\nsample_frequency::Int: during the sampling cycles, sample e.g. the number of\n\nadsorbed gas molecules every this number of Markov proposals\n\nverbose::Bool: whether or not to print off information during the simulation\newald_precision::Float64: desired precision for the long range Ewald summation\neos::Symbol: equation of state to use for calculation of fugacity from pressure\nwrite_adsorbate_snapshots::Bool: whether the simulation will create and save a snapshot file\nsnapshot_frequency::Int: the number of cycles taken between each snapshot (after burn cycle completion)\ncalculate_density_grid::Bool: whether the simulation will keep track of a density grid for adsorbates\ndensity_grid_dx::Float64: The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by required_n_pts.\ndensity_grid_species::Symbol: The atomic species within the molecule for which we will compute the density grid.\ndensity_grid_sim_box::Bool: true if we wish for the density grid to be over the \n\nentire simulation box as opposed to the box of the crystal passed in. false if we wish the density grid to be over the original xtal.box, before replication, passed in.\n\nresults_filename_comment::AbstractString: An optional comment that will be appended to the name of the saved file (if autosaved)\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.adsorption_isotherm","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.adsorption_isotherm","text":"results = adsorption_isotherm(xtal, molecule, temperature, pressures,\n                              ljff; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              density_grid_sim_box=true,\n                              results_filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in parallel. Arguments are the same as μVT_sim, as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as julia -p 4 mysim.jl to allocate e.g. four cores. See Parallel Computing.\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.stepwise_adsorption_isotherm","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.stepwise_adsorption_isotherm","text":"results = stepwise_adsorption_isotherm(xtal, molecule, temperature, pressures,\n                              ljff; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              write_adsorbate_snapshots=false,\n                              snapshot_frequency=1, calculate_density_grid=false,\n                              density_grid_dx=1.0, density_grid_species=nothing,\n                              density_grid_sim_box::Bool=true,\n                              results_filename_comment=\"\", show_progress_bar=false)\n\nRun a set of grand-canonical (μVT) Monte Carlo simulations in series. Arguments are the same as μVT_sim, as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of pressures is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see adsorption_isotherm which runs the μVT simulation at each pressure in parallel.\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.μVT_output_filename","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.μVT_output_filename","text":"filename = μVT_output_filename(xtal, molecule, temperature, \n                               pressure, ljff, n_burn_cycles, \n                               n_sample_cycles; comment=\"\", extension=\".jld2\")\n\nThis is the function that establishes the file naming convention used by μVT_sim.\n\nArguments\n\nxtal::Crystal: porous xtal used in adsorption simulation\nmolecule::Molecule: a template of the adsorbate molecule used in adsorption simulation\ntemperature::Float64:temperature of bulk gas phase in equilibrium with adsorbed phase in       the porous material. units: Kelvin (K) \npressure::Float64:pressure of bulk gas phase in equilibrium with adsorbed phase in the       porous material. units: bar\nljff::LJForceField: the molecular model used in adsorption simulation\nn_burn_cycles::Int: number of cycles to allow the system to reach equilibrium before sampling.    \nn_sample_cycles::Int: number of cycles used for sampling\ncomment::String=\"\": remarks to be included in the filename\nextension::String=\".jld2\": the file extension\n\nReturns\n\nfilename::String: the name of the specific .jld2 simulation file\n\n\n\n\n\n","category":"function"},{"location":"gcmc/#PorousMaterials.isotherm_sim_results_to_dataframe","page":"grand-canonical Monte Carlo simulations","title":"PorousMaterials.isotherm_sim_results_to_dataframe","text":"dataframe = isotherm_sim_results_to_dataframe(desired_props, xtal,\n                                              molecule, temperature,\n                                              pressures, ljff,\n                                              n_burn_cycles, n_sample_cycles;\n                                              where_are_jld_files=nothing)`\n\nconvert the .jld2 results output files auto-saved from μVT_sim into a DataFrame. each row of the DataFrame corresponds to a pressure in the adsorption isotherm. desired_props is an array of desired properties from the results.  to locate the requested output files, this function calls μVT_output_filename to retrieve the file names.\n\nArguments\n\ndesired_props::Array{String, 1}: An array containing names of properties to be retrieved from the .jld2 file\nxtal::Crystal: The porous crystal\nmolecule::Molecule{Cart}: The adsorbate molecule\ntemperature::Float64: The temperature in the simulation, units: Kelvin (K)\npressures::Array{Float64}: The pressures in the adsorption isotherm simulation(s), units: bar\nljff::LJForceField: The molecular model being used in the simulation to describe intermolecular Van       der Waals interactions\nn_burn_cycles::Int64: The number of burn cycles used in this simulation\nn_sample_cycles::Int64: The number of sample cycles used in the simulations\nwhere_are_jld_files::Union{String, Nothing}=nothing: The location to the simulation files. defaults to   PorousMaterials.PATH_TO_SIMS.\ncomment::String=\"\": comment appended to outputfilename\n\nReturns\n\ndataframe::DataFrame: A DataFrame containing the simulated data along the adsorption isotherm, whose   columns are for the specified properties\n\nNote\n\nA range of pressures can be used to select a batch of simulation files to be included in the DataFrame.\n\nExample\n\nxtal = Crystal(\"SBMOF-1.cif\")\nmolecule = Molecule(\"Xe\")\nljff = LJForceField(\"UFF\", mixing_rules=\"Lorentz-Berthelot\")\ntemperature = 298.0 # K\npressures = 10 .^ range(-2, stop=2, length=15)\n\ndataframe = isotherm_sim_results_to_dataframe([\"pressure (bar)\", \"⟨N⟩ (mmol/g)\"], \n                                              xtal, molecule, temperature,\n                                              pressures, ljff, 10000, 10000)\ndataframe[Symbol(\"pressure (bar)\")] # pressures\ndataframe[Symbol(\"⟨N⟩ (mmol/g)\")] # adsorption at corresponding pressures\n\n\n\n\n\n","category":"function"},{"location":"grid/#Potential-Energy-Grid","page":"grids","title":"Potential Energy Grid","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"PorousMaterials.jl allows us to calculate and store the ensemble average potential energy of a molecule inside a crystal. This is done by using the molecule as a probe to measure the potential energy on a grid of points superimposed on the unit cell of the crystal.","category":"page"},{"location":"grid/#Calculating-Potential-Energy-Grids","page":"grids","title":"Calculating Potential Energy Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"Superimpose a grid of points about the unit cell of SBMOF-1, compute the potential energy of xenon at each point, and store the data in a Grid object using energy_grid.","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"using PorousMaterials\n\nxtal = Crystal(\"SBMOF-1.cif\")\nstrip_numbers_from_atom_labels!(xtal)\nmolecule = Molecule(\"Xe\")\nljforcefield = LJForceField(\"UFF\")\n\n# Grid data structure\ngrid = energy_grid(xtal, molecule, ljforcefield, \n                   n_pts=(50, 50, 50), units=:kJ_mol) ","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"The Grid object has the following attributes:","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"grid.box      # Bravais lattice over which a grid of points is superimposed\ngrid.data     # 3 dim array containing data for each point\ngrid.n_pts    # number of grid points in x, y, z\ngrid.origin   # the origin of the grid\ngrid.units    # units associated with each data point","category":"page"},{"location":"grid/#Saving-and-Retrieving-Grids","page":"grids","title":"Saving and Retrieving Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"Write to a .cube volume file to visualize the potential energy contours. The output file location is determined by PorousMaterials.PATH_TO_GRIDS.","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"write_cube(grid, \"CH4_in_SBMOF1.cube\")","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"Likewise, we can read a .cube file to populate a Grid object:","category":"page"},{"location":"grid/","page":"grids","title":"grids","text":"filename = joinpath(PorousMaterials.PATH_TO_GRIDS, \"CH4_in_SBMOF1.cube\")\ngrid = read_cube(filename)","category":"page"},{"location":"grid/#detailed-docs","page":"grids","title":"detailed docs","text":"","category":"section"},{"location":"grid/#Grids","page":"grids","title":"Grids","text":"","category":"section"},{"location":"grid/","page":"grids","title":"grids","text":"    Grid\n    energy_grid\n    write_cube\n    read_cube\n    required_n_pts\n    xf_to_id\n    id_to_xf\n    update_density!\n    compute_accessibility_grid\n    accessible","category":"page"},{"location":"grid/#PorousMaterials.Grid","page":"grids","title":"PorousMaterials.Grid","text":"Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (Box). Each grid point has data, data, associated with it, of type T, stored in a 3D array.\n\nAttributes\n\nbox::Box: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.\nn_pts::Tuple{Int, Int, Int}: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.\ndata::Array{T, 3}: three dimensional array conaining data associated with each grid point.\nunits::Symbol: the units associated with each data point.\norigin::Array{Float64, 1}: the origin of the grid.\n\n\n\n\n\n","category":"type"},{"location":"grid/#PorousMaterials.energy_grid","page":"grids","title":"PorousMaterials.energy_grid","text":"grid = energy_grid(crystal, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750)\n\nSuperimposes a regular grid of points (regularly spaced in fractional coordinates of the crystal.box) over the unit cell of a crystal, with n_gridpts dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.\n\nThe ensemble average is a Boltzmann average over rotations:  - R T log ⟨e⁻ᵇᵁ⟩\n\nArguments\n\ncrystal::Crystal: crystal in which we seek to compute an energy grid for a molecule. grid.box will be framework.box.\nmolecule::Molecule: molecule for which we seek an energy grid\nljforcefield::LJForceField: molecular model for computing molecule-crystal interactions\nn_pts::Tuple{Int, Int, Int}=(50,50,50): number of grid points in each fractional coordinate dimension, including endpoints (0, 1)\nn_rotations::Int: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.\n\nThis is only relevant for molecules that are comprised of more than one Lennard Jones sphere.\n\ntemperature::Float64: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.\nunits::Symbol: either :K or :kJ_mol, the units in which the energy should be stored in the returned Grid.\ncenter::Bool: shift coords of grid so that the origin is the center of the unit cell crystal.box.\nverbose::Bool=true: print some information.\n\nReturns\n\ngrid::Grid: A grid data structure containing the potential energy of the system\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.write_cube","page":"grids","title":"PorousMaterials.write_cube","text":"write_cube(grid, filename, verbose=true)\n\nWrite grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.\n\nArguments\n\ngrid::Grid: grid with associated data at each grid point.\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS.\nverbose::Bool: print name of file after writing.\nlength_units::String: units for length. Bohr or Angstrom.\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.read_cube","page":"grids","title":"PorousMaterials.read_cube","text":"grid = read_cube(filename)\n\nRead a .cube file and return a populated Grid data structure.\n\nArguments\n\nfilename::AbstractString: name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS\n\nReturns\n\ngrid::Grid: A grid data structure\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.required_n_pts","page":"grids","title":"PorousMaterials.required_n_pts","text":"n_pts = required_n_pts(box, dx)\n\nCalculate the required number of grid pts in a, b, c unit cell directions required to keep distances between grid points less than dx apart, where dx is in units of Angstrom.\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.xf_to_id","page":"grids","title":"PorousMaterials.xf_to_id","text":"voxel_id = xf_to_id(n_pts, xf)\n\nReturns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of n_pts[1] by n_pts[2] by n_pts[3] voxels. Periodic boundary conditions are applied.\n\nArguments\n\nn_pts::Tuple{Int, Int, Int}: The number of points for each axis in the Grid\nxf::Array{Float64, 1}: The fractional coordinates to be converted to an id\n\nReturns\n\nid::Array{Int, 1}: The array indices for storing this point in space\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.id_to_xf","page":"grids","title":"PorousMaterials.id_to_xf","text":"xf = id_to_xf(voxel_id, n_pts)\n\nGiven a voxel_id in a Grid, return the fractional coordinates to which this voxel corresponds.\n\nArguments\n\nn_pts::Tuple{Int, Int, Int}: The number of voxels along each axis in the Grid\nvoxel_id::Array{Int, 1}: the voxel coordinates in grid.data\n\nReturns\n\nxf::Array{Float64, 1}: The fractional coordinates corresponding to the grid voxel\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.update_density!","page":"grids","title":"PorousMaterials.update_density!","text":"update_density!(grid, molecule, species)\n\nupdates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a ./ = num_snapshots at the end of the GCMC simulation.\n\nArguments\n\ngrid::Grid: the grid to be updated\nmolecules::Array{Molecule, 1}: An array of molecules whose positions will  be added to the grid\nspecies::Symbol: The species of atom that can be added to this density grid\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.compute_accessibility_grid","page":"grids","title":"PorousMaterials.compute_accessibility_grid","text":"accessibility_grid, nb_segments_blocked, porosity = compute_accessibility_grid(crystal,\nprobe_molecule, ljforcefield; n_pts=(20, 20, 20), energy_tol=10.0, energy_unit=:kJ_mol,\nverbose=true, write_b4_after_grids=true, block_inaccessible_pockets=true)\n\nOverlay a grid of points about the unit cell. Compute the potential energy of a probe molecule at each point. If the potential energy is less than energy_tol, the grid point is declared as accessible to an adsorbate; otherwise inaccessible.\n\nIf block_pockets is true: Then perform a flood fill algorithm to label disparate (unconnected) segments in the grid.\n\nThen build a graph whose vertices are the unconnected segments in the flood-filled grid and whose edges are the connections between the segments across the periodic boundary.\n\nThen find any simple cycles in the grid. Any vertex that is involved in a simple cycle is considered accessible since a molecule can travel from that segment in the home unit cell to the same segment but in a different unit cell. If any vertex is not involved in a cycle, the segment is declared as inaccessible and all grid points in this segment are re-labeled as inaccessible.\n\nReturns accessibility_grid::Grid{Bool} and nb_segments_blocked, the latter the number of segments that were blocked because they were determined to be inaccessible.\n\nArguments\n\ncrystal::Crystal: the crystal for which we seek to compute an accessibility grid.\nprobe_molecule::Molecule a molecule serving as a probe to determine whether a given\n\npoint can be occupied and accessed.\n\nLJForceField::LJForceField: the force field used to compute the potential energy of\n\nthe probe molecule\n\nn_pts::Tuple{Int, Int, Int}: number of grid points in a, b, c directions\nenergy_tol::Float64: if the computed potential energy is less than this, we declare the\n\ngrid point to be occupiable. Also this is the energy barrier beyond which we assume the probe adsorbate cannot pass. Units given by energy_units argument\n\nenergy_units::Symbol: units of energy (:kJ_mol or :K) to be used in determining\n\nthreshold for occupiability and whether molecule can percolate over barrier in channel. (see energy_tol)\n\nwrite_b4_after_grids::Bool: write a .cube file of occupiability for visualization both\n\nbefore and after flood fill/blocking inaccessible pockets\n\n\n\n\n\n","category":"function"},{"location":"grid/#PorousMaterials.accessible","page":"grids","title":"PorousMaterials.accessible","text":"accessible(accessibility_grid, xf)\naccessible(accessibility_grid, xf, repfactors)\n\nUsing accessibility_grid, determine if fractional coordinate xf (relative to accessibility_grid.box is accessible or not. Here, we search for the nearest grid point. We then look at the accessibility of this nearest grid point and all surroudning 9 other grid points. The point xf is declared inaccessible if and only if all 10 of these grid points are inaccessible. We take this approach because, if the grid is coarse, we can allow energy computations to automatically determine accessibility at the boundary of accessibility e.g. during a molecular simulation where inaccessible pockets are blocked.\n\nIf a tuple of replication factors are also passed, it is assumed that the passed xf is relative to a replicated accessibility_grid.box so that xf is scaled by these rep. factors. So xf = [0.5, 0.25, 0.1] with repfactors=(1, 2, 4) actually is, relative to accessibility_grid.box, fractional coordinate [0.5, 0.5, 0.4].\n\n\n\n\n\n","category":"function"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"(Image: PorousMaterials.jl) A pure-Julia package for classical molecular modeling of adsorption in porous crystals such as metal-organic frameworks (MOFs).","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the potential energy of a molecule at particular position and orientation inside of a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Write a potential energy grid of a molecule inside a porous material to visualize binding sites","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Compute the Henry coefficient of a gas in a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"🔨 Run grand-canonical Monte Carlo simulations of gas adsorption in a porous crystal","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Designed for high-throughput computations to minimize input files and querying results from output files. User-friendly. Instructive error messages thrown when they should be. Well-documented. Easy to install.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In development, please contribute, post issues 🐛, and improve!","category":"page"},{"location":"#Installation","page":"PorousMaterials","title":"Installation","text":"","category":"section"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Download and install the Julia programming language, v1.5 or higher.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, open the package manager (using ]) and enter the following:","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"pkg> add PorousMaterials","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"In Julia, load all functions in PorousMaterials.jl into the namespace:","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"julia> using PorousMaterials # that's it","category":"page"},{"location":"#Tests","page":"PorousMaterials","title":"Tests","text":"","category":"section"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Run the tests in the script tests/runtests.jl manually or by ] test PorousMaterials in the Julia REPL.","category":"page"},{"location":"","page":"PorousMaterials","title":"PorousMaterials","text":"Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and must be run separately; they are found in tests/henry.jl and tests/gcmc_long.jl.","category":"page"},{"location":"crystal/#Crystals","page":"crystals","title":"Crystals","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"PorousMaterials.jl maintains a data structure Crystal that stores information about a crystal structure file.","category":"page"},{"location":"crystal/#reading-in-a-crystal-structure-file","page":"crystals","title":"reading in a crystal structure file","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Currently, the crystal structure file reader accepts .cif and .cssr file formats. PorousMaterials.jl looks for the crystal structure files in PorousMaterials.PATH_TO_CRYSTALS which is by default ./data/crystals. By typing @eval PorousMaterials PATH_TO_CRYSTALS = \"my_crystal_dir\", PorousMaterials.jl now looks for the crystal structure file in my_crystal_dir. The files can be read as:","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal = Crystal(\"IRMOF-1.cif\")       # The crystal reader stores the information in xtal\nxtal.name                           # The name of the crystal structure file\nxtal.box                            # The unit cell information\nxtal.atoms                          # The atom coordinates (in fractional space) and the atom identities\nxtal.charges                        # The charge magnitude and coordinates (in fractional space)\nxtal.bonds                          # Bonding information in the structure. By default this is an empty graph,\n                                    #  but use `read_bonds_from_file=true` argument in `Crystal` to read from crystal structure file\nxtal.symmetry                       # Symmetry information of the crystal. By default converts the symmetry to P1 symmetry.\n                                    #  Use `convert_to_p1=false` argument in `Crystal` to keep original symmetry","category":"page"},{"location":"crystal/#fixing-atom-species","page":"crystals","title":"fixing atom species","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Often, the atoms species are appended by numbers. This messes with the internal workings of PorousMaterials.jl. To circumvent this problem, the function strip_numbers_from_atom_labels!(xtal) removes the appending numbers. It is important to use this function prior to GCMC or Henry coefficient calculations.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal.atoms.species              # [:C1, :C2, :O1, ...]\nstrip_numbers_from_atom_labels!(xtal)\nxtal.atoms.species              # [:C, :C, :O, ...]","category":"page"},{"location":"crystal/#converting-the-coordinates-to-cartesian-space","page":"crystals","title":"converting the coordinates to cartesian space","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"The coordinates of the crystals are stored in fractional coordinates. If one needs to analyze the cartesian coordinates of the crystal, that can be done by using the unit cell information of the crystal.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal.atoms.coords.xf                                    # array of fractional coordinates\ncart_coords = xtal.box.f_to_c * xtal.atoms.coords.xf    # array of cartesian coordinates","category":"page"},{"location":"crystal/#creating-a-super-cell","page":"crystals","title":"creating a super cell","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"For many simulations, one needs to replicate the unit cell multiple times to create a bigger super cell.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"super_xtal = replicate(xtal, (2,2,2))       # Replicates the original unit cell once in each dimension","category":"page"},{"location":"crystal/#finding-other-properties","page":"crystals","title":"finding other properties","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"rho = crystal_density(xtal)         # Crystal density of the crystal in kg/m^2\nmw = molecular_weight(xtal)         # The molecular weight of the unit cell in amu\nformula = chemical_formula(xtal)    # The irreducible chemical formula of the crystal","category":"page"},{"location":"crystal/#assigning-new-charges","page":"crystals","title":"assigning new charges","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"If the crystal structure file does not contains partial charges, we provide methods to assign new charges to the crystal","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"species_to_charges = Dict(:Ca => 2.0, :C => 1.0, :H => -1.0)                # This method assigns a static charge to atom species\ncharged_xtal = assign_charges(xtal, species_to_charge, 1e-5)                # This function creates a new charged `Crystal` object.\n                                                                            #   The function checks for charge neutrality with a tolerance of 1e-5\nnew_charges = Charges([2.0, 1.0, -1.0, -1.0, ...], xtal.atoms.coords)\nother_charged_xtal = Crystal(xtal.name, xtal.box, xtal.atoms,               # Here we create a new `Charges` object using an array of new charges.\n                             new_charges, xtal.bonds, xtal.symmetry)        #   The number of charges in the array has to be equal to the number of atoms\n                                                                            #   and finally a new `Crystal` object is manually created","category":"page"},{"location":"crystal/#writing-crystal-files","page":"crystals","title":"writing crystal files","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"We provide methods to write both .xyz and .cif files","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"write_cif(xtal, \"my_new_cif_file.cif\")      # Stored in the current directory\nwrite_xyz(xtal, \"my_new_xyz_file.xyz\")      # stored in the current directory","category":"page"},{"location":"crystal/#detailed-docs","page":"crystals","title":"detailed docs","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"    Crystal\n    SymmetryInfo\n    replicate\n    molecular_weight\n    crystal_density\n    chemical_formula\n    assign_charges\n    write_cif\n    write_xyz","category":"page"},{"location":"crystal/#PorousMaterials.Crystal","page":"crystals","title":"PorousMaterials.Crystal","text":"crystal = Crystal(filename;\n    check_neutrality=true, net_charge_tol=1e-4,\n    check_overlap=true, overlap_tol=0.1,\n    convert_to_p1=true, read_bonds_from_file=false, wrap_coords=true,\n    include_zero_charges=false,\n    remove_duplicates=false,\n    species_col=[\"_atom_site_label\", \"_atom_site_type_symbol\"]\n    ) # read from file\n\ncrystal = Crystal(name, box, atoms, charges) # construct from matter, no bonds, P1-symmetry assumed\n\nRead a crystal structure file (.cif or .cssr) and populate a Crystal data structure, or construct a Crystal data structure directly.\n\nArguments\n\nfilename::String: the name of the crystal structure file (include \".cif\" or \".cssr\") read from PATH_TO_CRYSTALS.\ncheck_neutrality::Bool: check for charge neutrality\nnet_charge_tol::Float64: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.\ncheck_overlap::Bool: throw an error if overlapping atoms are detected.\nconvert_to_p1::Bool: If the structure is not in P1 it will be converted to   P1 symmetry using the symmetry rules from the _symmetry_equiv_pos_as_xyz list in the .cif file.   (We do not use the space groups name to look up symmetry rules).\nread_bonds_from_file::Bool: Whether or not to read bonding information from   cif file. If false, the bonds can be inferred later. note that, if the crystal is not in P1 symmetry, we cannot both read bonds and convert to P1 symmetry.\nwrap_coords::Bool: if true, enforce that fractional coords of atoms and charges are in [0,1]³ by mod(x, 1)\ninclude_zero_charges::Bool: if false, do not include in crystal.charges atoms which have zero charges, in order to speed up the electrostatic calculations.   If true, include the atoms in crystal.charges that have zero charge, ensuring that the number of atoms is equal to the number of charges and that crystal.charges.coords.xf and crystal.atoms.coords.xf are the same.\nremove_duplicates::Bool: remove duplicate atoms and charges. an atom is duplicate only if it is the same species.\n\nReturns\n\ncrystal::Crystal: A crystal containing the crystal structure information\n\nAttributes\n\nname::AbstractString: name of crystal structure\nbox::Box: unit cell (Bravais Lattice)\natoms::Atoms: list of Atoms in crystal unit cell\ncharges::Charges: list of point charges in crystal unit cell\nbonds::SimpleGraph: Unweighted, undirected graph showing all of the atoms   that are bonded within the crystal\nsymmetry::SymmetryInfo: symmetry inforomation\nspecies_col::Array{String}: which column to use for species identification for crystal.atoms.species. we use a priority list:   we check for the first entry of species_col in the .cif file; if not present, we then use the second entry, and so on.\n\n\n\n\n\n","category":"type"},{"location":"crystal/#PorousMaterials.molecular_weight","page":"crystals","title":"PorousMaterials.molecular_weight","text":"mass_of_crystal = molecular_weight(crystal)\n\nCalculates the molecular weight of a unit cell of the crystal in amu using information stored in data/atomicmasses.csv.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\n\nReturns\n\nmass_of_crystal::Float64: The molecular weight of a unit cell of the crystal in amu\n\n\n\n\n\n","category":"function"},{"location":"crystal/#PorousMaterials.crystal_density","page":"crystals","title":"PorousMaterials.crystal_density","text":"ρ = crystal_density(crystal) # kg/m³\n\nCompute the crystal density of a crystal. Pulls atomic masses from read_atomic_masses.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\n\nReturns\n\nρ::Float64: The crystal density of a crystal in kg/m³\n\n\n\n\n\n","category":"function"},{"location":"crystal/#PorousMaterials.chemical_formula","page":"crystals","title":"PorousMaterials.chemical_formula","text":"formula = chemical_formula(crystal, verbose=false)\n\nFind the irreducible chemical formula of a crystal structure.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\nverbose::Bool: If true, will print the chemical formula as well\n\nReturns\n\nformula::Dict{Symbol, Int}: A dictionary with the irreducible chemical formula of a crystal structure\n\n\n\n\n\n","category":"function"},{"location":"crystal/#PorousMaterials.assign_charges","page":"crystals","title":"PorousMaterials.assign_charges","text":"crystal_with_charges = assign_charges(crystal, species_to_charge, net_charge_tol=1e-5)\n\nassign charges to the atoms present in the crystal based on atom type. pass a dictionary species_to_charge that maps atomic species to a charge.\n\nif the crystal already has charges, the charges are removed and new charges are added. a warning is thrown if this is the case.\n\nchecks for charge neutrality in the end.\n\nreturns a new crystal.\n\nExamples\n\nspecies_to_charge = Dict(:Ca => 2.0, :C => 1.0, :H => -1.0)\ncrystal_with_charges = assign_charges(crystal, species_to_charge, 1e-7)\ncrystal_with_charges = assign_charges(crystal, species_to_charge) # tol 1e-5 default\n\nArguments\n\ncrystal::Crystal: the crystal\nspecies_to_charge::Dict{Symbol, Float64}: a dictionary that maps atomic species to charge\nnet_charge_tol::Float64: the net charge tolerated when asserting charge neutrality of\n\nthe resulting crystal\n\n\n\n\n\n","category":"function"},{"location":"crystal/#PorousMaterials.write_cif","page":"crystals","title":"PorousMaterials.write_cif","text":"write_cif(crystal, filename; fractional_coords=true, number_atoms=true)\n\nWrite a crystal::Crystal to a .cif file with filename::AbstractString. If filename does not include the .cif extension, it will automatically be added. the fractional_coords flag allows us to write either fractional or Cartesian coordinates.\n\n\n\n\n\n","category":"function"},{"location":"crystal/#PorousMaterials.write_xyz","page":"crystals","title":"PorousMaterials.write_xyz","text":"write_xyz(atoms, filename; comment=\"\")\nwrite_xyz(crystal; comment=\"\", center_at_origin=false)\nwrite_xyz(molecules, box, filename; comment=\"\") # fractional\nwrite_xyz(molecules, box, filename; comment=\"\") # Cartesian\n\nwrite atoms to an .xyz file.\n\nArguments\n\natoms::Atoms: the set of atoms.\nfilename::AbstractString: the filename (absolute path) of the .xyz file. (\".xyz\" appended automatically\n\nif the extension is not provided.)\n\ncomment::AbstractString: comment if you'd like to write to the file.\ncenter_at_origin::Bool: (for crystal only) if true, translate all coords such that the origin is the center of the unit cell.\n\n\n\n\n\nwritexyz(box, molecules, xyzfile)\n\nWrites the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end.\n\nThis writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion.\n\nArguments\n\nbox::Box: The box the molecules are in, to convert molecule positions     to cartesian coordinates\nmolecules::Array{Molecule{Frac}, 1}: The array of molecules to be written to the file\nxyz_file::IOStream: The open 'write' file stream the data will be saved to\n\n\n\n\n\n","category":"function"}]
}
