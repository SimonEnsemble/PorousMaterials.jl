<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boxes, Crystals, and Grids · PorousMaterials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PorousMaterials.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PorousMaterials</a></li><li><a class="tocitem" href="../../guides/input_files/">Loading Data</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../matter/">Matter</a></li><li class="is-active"><a class="tocitem" href>Boxes, Crystals, and Grids</a><ul class="internal"><li><a class="tocitem" href="#Loading-in-Crystal-Structure-Files-1"><span>Loading in Crystal Structure Files</span></a></li><li><a class="tocitem" href="#Generating-Bond-Information-for-Frameworks-1"><span>Generating Bond Information for Frameworks</span></a></li><li><a class="tocitem" href="#Building-Blocks-of-PorousMaterials:-Bravais-lattice-1"><span>Building Blocks of PorousMaterials: Bravais lattice</span></a></li><li><a class="tocitem" href="#Building-Blocks-of-PorousMaterials:-Porous-Crystals-1"><span>Building Blocks of PorousMaterials: Porous Crystals</span></a></li><li><a class="tocitem" href="#Demo-of-Potential-Energy-Grid-1"><span>Demo of Potential Energy Grid</span></a></li><li><a class="tocitem" href="#Boxes-1"><span>Boxes</span></a></li><li><a class="tocitem" href="#Crystals-1"><span>Crystals</span></a></li><li><a class="tocitem" href="#Grids-1"><span>Grids</span></a></li></ul></li><li><a class="tocitem" href="../molecules/">Molecules</a></li><li><a class="tocitem" href="../atomic_interactions/">Atomic Interactions</a></li><li><a class="tocitem" href="../mof_simulations/">Molecular Simulations</a></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><a class="tocitem" href="../../guides/faq/">FAQ</a></li><li><a class="tocitem" href="../../guides/help_wanted/">Help Wanted</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Boxes, Crystals, and Grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boxes, Crystals, and Grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/master/docs/src/manual/boxes_crystals_grids.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Loading-in-Crystal-Structure-Files-1"><a class="docs-heading-anchor" href="#Loading-in-Crystal-Structure-Files-1">Loading in Crystal Structure Files</a><a class="docs-heading-anchor-permalink" href="#Loading-in-Crystal-Structure-Files-1" title="Permalink"></a></h2><p>Place <code>.cif</code> and <code>.cssr</code> crystal structure files in <code>PorousMaterials.PATH_To_CRYSTALS</code>. <code>PorousMaterials.jl</code> can load in <code>.cif</code> files of any symmetry as long as the symmetry operations are included. From here you can start julia and do the following to load a framework and start working with it.</p><pre><code class="language-julia">using PorousMaterials

f = Framework(&quot;SBMOF-1.cif&quot;)</code></pre><p>PorousMaterials will then output information about the framework you just loaded:</p><pre><code class="language-julia">Name: SBMOF-1.cif
Bravais unit cell of a crystal.
        Unit cell angles α = 90.000000 deg. β = 100.897000 deg. γ = 90.000000 deg.
        Unit cell dimensions a = 11.619300 Å. b = 5.566700 Å, c = 22.931200 Å
        Volume of unit cell: 1456.472102 Å³

Number of atoms = 120
Number of charges = 0
Chemical formula: Dict(:H=&gt;8,:S=&gt;1,:Ca=&gt;1,:O=&gt;6,:C=&gt;14)</code></pre><p>If the file is not in P1 symmetry, it will be converted within the framework reader and this message will be displayed.</p><pre><code class="language-julia">┌ Warning: Name_of_file.cif is not in P1 symmetry. It is being converted to P1 for use in PorousMaterials.jl.
└ @ PorousMaterials ~/osu_undergrad/simon_ensemble/PorousMaterials.jl/src/Crystal.jl:284</code></pre><p>PorousMaterials also gives the option to read in structures in the lower level symmetries and convert them to P1 before simulation.</p><pre><code class="language-julia">framework = Framework(&quot;ORIVOC_clean.cif&quot;; remove_overlap=true, convert_to_p1=false)
# the remove_overlap argument is specific to this structure, not all frameworks need it

###
    Perform any operation on the structure while it is not in P1
###

framework = apply_symmetry_rules(framework)
# the framework is now in P1 and it can be used in simulations</code></pre><h2 id="Generating-Bond-Information-for-Frameworks-1"><a class="docs-heading-anchor" href="#Generating-Bond-Information-for-Frameworks-1">Generating Bond Information for Frameworks</a><a class="docs-heading-anchor-permalink" href="#Generating-Bond-Information-for-Frameworks-1" title="Permalink"></a></h2><p>The bonds are stored in a <code>SimpleGraph</code> from the <code>LightGraphs.jl</code> package, and can be accessed through the <code>bonds</code> attribute.  </p><h3 id="Reading-from-a-file-1"><a class="docs-heading-anchor" href="#Reading-from-a-file-1">Reading from a file</a><a class="docs-heading-anchor-permalink" href="#Reading-from-a-file-1" title="Permalink"></a></h3><p><code>PorousMaterials</code> can read in bonds from <code>.cif</code> files if they have the tags <code>_geom_bond_atom_site_label_1</code> and <code>_geom_bond_atom_site_label_2</code>. To choose to read bonds from a file, pass <code>read_bonds_from_file=true</code> to the <code>Framework</code> constructor.</p><pre><code class="language-julia">using PorousMaterials

f = Framework(&quot;KAXQIL_clean.cif&quot;; read_bonds_from_file=true, convert_to_p1=false)

f.bonds</code></pre><p>This example uses a structure that is not in P1 symmetry. <code>PorousMaterials</code> cannot replicate a structure or apply symmetry rules if it currently has bonds. However, this structure can be converted to P1 without bonds, and then bonds can be inferred for the full P1 structure.</p><h3 id="Inferring-bonds-using-BondingRules-1"><a class="docs-heading-anchor" href="#Inferring-bonds-using-BondingRules-1">Inferring bonds using <code>BondingRule</code>s</a><a class="docs-heading-anchor-permalink" href="#Inferring-bonds-using-BondingRules-1" title="Permalink"></a></h3><p><code>PorousMaterials</code> can infer bonds for a structure and populate the bond graph by using <code>BondingRule</code>s. Each <code>BondingRule</code> has two species of atoms that it works for. It also has a minimum and maximum distance that a bond can be defined for the two atoms.</p><pre><code class="language-julia">using PorousMaterials

f = Framework(&quot;SBMOF-1.cif&quot;)

# define an array of BondingRule&#39;s that will be used to define bonds in the
#   framework. These need to be in the order that they are applied
bonding_rules = [BondingRule(:H, :*, 0.4, 1.2),
                 BondingRule(:*, :*, 0.4, 1.9)]

# Alternatively, you could get the above bonding rules with the following command
bonding_rules = default_bondingrules()

# infer the bonds for the framework f with bonds across periodic boundaries
infer_bonds!(f, true, bonding_rules)

# redefine bonding_rules to account for edge cases between Ca and O atoms. `pushfirst!` adds the newly
#   defined Bondingrule to the front of `bonding_rules`
pushfirst!(BondingRule(:Ca, :O, 0.4, 2.5), bonding_rules)

# remove old bonds from framework before inferring bonds with new rules
remove_bonds!(f)

# re-infer bonds
infer_bonds!(f, true, bonding_rules)

# output the bond information to visualize it and double check
write_bond_information(f, &quot;SBMOF-1_bonds.vtk&quot;)

# run sanity checks
bond_sanity_check(framework)</code></pre><h2 id="Building-Blocks-of-PorousMaterials:-Bravais-lattice-1"><a class="docs-heading-anchor" href="#Building-Blocks-of-PorousMaterials:-Bravais-lattice-1">Building Blocks of PorousMaterials: Bravais lattice</a><a class="docs-heading-anchor-permalink" href="#Building-Blocks-of-PorousMaterials:-Bravais-lattice-1" title="Permalink"></a></h2><p>We later apply periodic boundary conditions to mimic a crystal of infinite extent. A <code>Box</code> describes a <a href="https://en.wikipedia.org/wiki/Bravais_lattice">Bravais lattice</a>.</p><p>To make a 10 by 10 by 10 Å Bravais lattice with right angles:</p><pre><code class="language-julia">box = Box(10.0, 10.0, 10.0, π/2, π/2, π/2)

box.a, box.b, box.c # unit cell dimensions (10.0 Å)
box.α, box.β, box.γ # unit cell angles (1.57... radians)
box.Ω # volume (1000.0 Å³)
box.f_to_c # fractional to Cartesian coordinate transformation matrix
box.c_to_f # Cartesian to fractional coordinate transformation matrix
box.reciprocal_lattice # rows are reciprocal lattice vectors</code></pre><p>Replicate a box as follows:</p><pre><code class="language-julia">box = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2
box.a # 20 Å</code></pre><h2 id="Building-Blocks-of-PorousMaterials:-Porous-Crystals-1"><a class="docs-heading-anchor" href="#Building-Blocks-of-PorousMaterials:-Porous-Crystals-1">Building Blocks of PorousMaterials: Porous Crystals</a><a class="docs-heading-anchor-permalink" href="#Building-Blocks-of-PorousMaterials:-Porous-Crystals-1" title="Permalink"></a></h2><pre><code class="language-julia">using PorousMaterials

# read in xtal structure file
framework = Framework(&quot;SBMOF-1.cif&quot;)

# access unit cell box
framework.box

# access Lennard-Jones spheres and point charges comprising the crystal
framework.atoms
framework.charges

# remove annoying numbers on the atom labels
strip_numbers_from_atom_labels!(framework)

# compute crystal density
ρ = crystal_density(framework) # kg/m3

# compute the chemical formula
cf = chemical_formula(framework)

# assign charges according to atom type
charges = Dict(:Ca =&gt; 3.0, :O =&gt; 2.0, :C =&gt; -1.0, :S =&gt; 7.0, :H =&gt; -1.0)
charged_framework = assign_charges(framework, charges)

# replicate &amp; visualize
framework = replicate(framework, (3, 3, 3))
write_to_xyz(framework, &quot;SBMOF-1.xyz&quot;)</code></pre><h2 id="Demo-of-Potential-Energy-Grid-1"><a class="docs-heading-anchor" href="#Demo-of-Potential-Energy-Grid-1">Demo of Potential Energy Grid</a><a class="docs-heading-anchor-permalink" href="#Demo-of-Potential-Energy-Grid-1" title="Permalink"></a></h2><p>Superimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid.</p><pre><code class="language-julia">using PorousMaterials

framework = Framework(&quot;SBMOF-1.cif&quot;)
molecule = Molecule(&quot;Xe&quot;)
forcefield = LJForceField(&quot;UFF.csv&quot;)

grid = energy_grid(framework, molecule, forcefield,
    n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure</code></pre><p>Write to a .cube volume file to visualize the potential energy contours.</p><pre><code class="language-julia">write_cube(grid, &quot;CH4_in_SBMOF1.cube&quot;)</code></pre><h2 id="Boxes-1"><a class="docs-heading-anchor" href="#Boxes-1">Boxes</a><a class="docs-heading-anchor-permalink" href="#Boxes-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.Box" href="#PorousMaterials.Box"><code>PorousMaterials.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">box = Box(a, b, c, α, β, γ, volume, f_to_c, c_to_f, reciprocal_lattice)
box = Box(a, b, c, α, β, γ)
box = Box(a, b, c) # α=β=γ=π/2 assumed.
box = Box(f_to_c)</code></pre><p>Data structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.</p><p><strong>Attributes</strong></p><ul><li><code>a,b,c::Float64</code>: unit cell dimensions (units: Angstroms)</li><li><code>α,β,γ::Float64</code>: unit cell angles (units: radians)</li><li><code>Ω::Float64</code>: volume of the unit cell (units: cubic Angtroms)</li><li><code>f_to_c::Array{Float64,2}</code>: the 3x3 transformation matrix used to map fractional</li></ul><p>coordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom</p><ul><li><code>c_to_f::Array{Float64,2}</code>: the 3x3 transformation matrix used to map Cartesian</li></ul><p>coordinates to fractional coordinates. units: inverse Angstrom</p><ul><li><code>reciprocal_lattice::Array{Float64, 2}</code>: the <em>rows</em> are the reciprocal lattice vectors.</li></ul><p>This choice was made (instead of columns) for speed of Ewald Sums.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Box.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.replicate" href="#PorousMaterials.replicate"><code>PorousMaterials.replicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">new_box = replicate(original_box, repfactors)</code></pre><p>Replicates a <code>Box</code> in positive directions to construct a new <code>Box</code> representing a supercell. The <code>original_box</code> is replicated according to the factors in <code>repfactors</code>. Note <code>replicate(original_box, repfactors=(1, 1, 1))</code> returns same <code>Box</code>. The new fractional coordinates as described by <code>f_to_c</code> and <code>c_to_f</code> still ∈ [0, 1].</p><p><strong>Arguments</strong></p><ul><li><code>original_box::Box</code>: The box that you want to replicate</li><li><code>repfactors::Tuple{Int, Int, Int}</code>: The factor you want to replicate the box by</li></ul><p><strong>Returns</strong></p><ul><li><code>box::Box</code>: Fully formed Box object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Box.jl#L120-L134">source</a></section><section><div><pre><code class="language-julia">replicated_frame = replicate(framework, repfactors)</code></pre><p>Replicates the atoms and charges in a <code>Framework</code> in positive directions to construct a new <code>Framework</code>. Note <code>replicate(framework, (1, 1, 1))</code> returns the same <code>Framework</code>.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework to replicate</li><li><code>repfactors::Tuple{Int, Int, Int}</code>: The factors by which to replicate the crystal structure in each direction.</li></ul><p><strong>Returns</strong></p><ul><li><code>replicated_frame::Framework</code>: Replicated framework</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L475-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.UnitCube" href="#PorousMaterials.UnitCube"><code>PorousMaterials.UnitCube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unit_cube = UnitCube()</code></pre><p>This function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Box.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.write_vtk" href="#PorousMaterials.write_vtk"><code>PorousMaterials.write_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_vtk(box, filename; verbose=true, center_at_origin=false)
write_vtk(framework)</code></pre><p>Write a <code>Box</code> to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a <code>Framework</code> is passed, the <code>Box</code> of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.</p><p>Appends &quot;.vtk&quot; extension to <code>filename</code> automatically if not passed.</p><p><strong>Arguments</strong></p><ul><li><code>box::Box</code>: a Bravais lattice</li><li><code>filename::AbstractString</code>: filename of the .vtk file output (absolute path)</li><li><code>framework::Framework</code>: A framework containing the crystal structure information</li><li><code>center_at_origin::Bool</code>: center box at origin if true. if false, the origin is the corner of the box.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Box.jl#L140-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.inside" href="#PorousMaterials.inside"><code>PorousMaterials.inside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inside_box = inside(x, box) # true or false</code></pre><p>Determine whether a Cartesian vector <code>x</code> lays inside a <code>Box</code>. This works by computing the  fractional coordinates of vector <code>x</code> and ensuring each lie within the interval <code>[0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Box.jl#L191-L196">source</a></section></article><h2 id="Crystals-1"><a class="docs-heading-anchor" href="#Crystals-1">Crystals</a><a class="docs-heading-anchor-permalink" href="#Crystals-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.Framework" href="#PorousMaterials.Framework"><code>PorousMaterials.Framework</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">framework = Framework(filename, check_charge_neutrality=true,
                      net_charge_tol=0.001, check_atom_and_charge_overlap=true,
                      remove_overlap=false, convert_to_p1=true,
                      read_bonds_from_file=false, wrap_to_unit_cell=true)
framework = Framework(name, box, atoms, charges; bonds=SimpleGraph(atoms.n_atoms),
                      symmetry=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], space_group=&quot;P1&quot;, is_p1=true)</code></pre><p>Read a crystal structure file (.cif or .cssr) and populate a <code>Framework</code> data structure, or construct a <code>Framework</code> data structure directly.</p><p>If the framework is constructed using the <code>Framework(name, box, atoms, charges)</code> function it is assumed it is in P1 symmetry.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: the name of the crystal structure file (include &quot;.cif&quot; or &quot;.cssr&quot;) read from <code>PATH_TO_CRYSTALS</code>.</li><li><code>check_charge_neutrality::Bool</code>: check for charge neutrality</li><li><code>net_charge_tol::Float64</code>: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.</li><li><code>check_atom_and_charge_overlap::Bool</code>: throw an error if overlapping atoms are detected.</li><li><code>remove_overlap::Bool</code>: remove identical atoms automatically. Identical atoms are the same element atoms which overlap.</li><li><code>convert_to_p1::Bool</code>: If the structure is not in P1 it will be converted to   P1 symmetry using the symmetry rules from the <code>_symmetry_equiv_pos_as_xyz</code> list in the .cif file.    (We do not use the space groups name to look up symmetry rules).</li><li><code>read_bonds_from_file::Bool</code>: Whether or not to read bonding information from   cif file. If false, the bonds can be inferred later. note that, if the crystal is not in P1 symmetry, we cannot <em>both</em> read bonds and convert to P1 symmetry.</li><li><code>wrap_to_unit_cell::Bool</code>: if true, enforce that fractional coords of atoms/charges are in [0,1]³ by mod(x, 1)</li></ul><p><strong>Returns</strong></p><ul><li><code>framework::Framework</code>: A framework containing the crystal structure information</li></ul><p><strong>Attributes</strong></p><ul><li><code>name::AbstractString</code>: name of crystal structure</li><li><code>box::Box</code>: unit cell (Bravais Lattice)</li><li><code>atoms::Atoms</code>: list of Atoms in crystal unit cell</li><li><code>charges::Charges</code>: list of point charges in crystal unit cell</li><li><code>bonds::SimpleGraph</code>: Unweighted, undirected graph showing all of the atoms   that are bonded within the framework</li><li><code>symmetry::Array{Function, 2}</code>: 2D array of anonymous functions that represent   the symmetry operations. If the structure is in P1 there will be one   symmetry operation.</li><li><code>space_group::AbstractString</code>: The name of the space group. This is stored   so that it can be written out again in the write_cif function. The space   group is not used to verify the symmetry rules.</li><li><code>is_p1::Bool</code>: Stores whether the framework is currently in P1 symmetry. Prior   to GCMC and Widom insertion simulations this is checked.</li><li><code>wrap_to_unit_cell::Bool</code>: Whether the atom and charge positions will be   wrapped to the unit cell so their coordinates are in [0, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L59-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.remove_overlapping_atoms_and_charges" href="#PorousMaterials.remove_overlapping_atoms_and_charges"><code>PorousMaterials.remove_overlapping_atoms_and_charges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">new_framework = remove_overlapping_atoms_and_charges(framework, atom_overlap_tol=0.1, 
                                                    charge_overlap_tol=0.1, verbose=true)</code></pre><p>Takes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework containing the crystal structure information</li><li><code>atom_overlap_tol::Float64</code>: The minimum distance between two atoms that is tolerated</li><li><code>charge_overlap_tol::Float64</code>: The minimum distance between two charges that is tolerated</li><li><code>verbose::Bool</code>: Will print out information regarding the function call</li></ul><p><strong>Returns</strong></p><ul><li><code>new_framework::Framework</code>: A new framework where identical atoms have been removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L622-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.strip_numbers_from_atom_labels!" href="#PorousMaterials.strip_numbers_from_atom_labels!"><code>PorousMaterials.strip_numbers_from_atom_labels!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">strip_numbers_from_atom_labels!(framework)</code></pre><p>Strip numbers from labels for <code>framework.atoms</code>. Precisely, for <code>atom</code> in <code>framework.atoms</code>, find the first number that appears in <code>atom</code>. Remove this number and all following characters from <code>atom</code>. e.g. C12 –&gt; C 	 Ba12A_3 –&gt; Ba</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework containing the crystal structure information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L739-L750">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>wrap_atoms_to_unit_cell</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.chemical_formula" href="#PorousMaterials.chemical_formula"><code>PorousMaterials.chemical_formula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">formula = chemical_formula(framework, verbose=false)</code></pre><p>Find the irreducible chemical formula of a crystal structure.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework containing the crystal structure information</li><li><code>verbose::Bool</code>: If <code>true</code>, will print the chemical formula as well</li></ul><p><strong>Returns</strong></p><ul><li><code>formula::Dict{Symbol, Int}</code>: A dictionary with the irreducible chemical formula of a crystal structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L767-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.molecular_weight" href="#PorousMaterials.molecular_weight"><code>PorousMaterials.molecular_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mass_of_framework = molecular_weight(framework)</code></pre><p>Calculates the molecular weight of a unit cell of the framework in amu using information stored in <code>data/atomicmasses.csv</code>.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework containing the crystal structure information</li></ul><p><strong>Returns</strong></p><ul><li><code>mass_of_framework::Float64</code>: The molecular weight of a unit cell of the framework in amu</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L807-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.crystal_density" href="#PorousMaterials.crystal_density"><code>PorousMaterials.crystal_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ρ = crystal_density(framework) # kg/m²</code></pre><p>Compute the crystal density of a framework. Pulls atomic masses from <a href="../other/#PorousMaterials.read_atomic_masses"><code>read_atomic_masses</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework containing the crystal structure information</li></ul><p><strong>Returns</strong></p><ul><li><code>ρ::Float64</code>: The crystal density of a framework in kg/m³</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L830-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.replicate-Tuple{Framework,Tuple{Int64,Int64,Int64}}" href="#PorousMaterials.replicate-Tuple{Framework,Tuple{Int64,Int64,Int64}}"><code>PorousMaterials.replicate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replicated_frame = replicate(framework, repfactors)</code></pre><p>Replicates the atoms and charges in a <code>Framework</code> in positive directions to construct a new <code>Framework</code>. Note <code>replicate(framework, (1, 1, 1))</code> returns the same <code>Framework</code>.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The framework to replicate</li><li><code>repfactors::Tuple{Int, Int, Int}</code>: The factors by which to replicate the crystal structure in each direction.</li></ul><p><strong>Returns</strong></p><ul><li><code>replicated_frame::Framework</code>: Replicated framework</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L475-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.charged-Tuple{Framework}" href="#PorousMaterials.charged-Tuple{Framework}"><code>PorousMaterials.charged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">charged_flag = charged(framework, verbose=false) # true or false</code></pre><p>Determine if a framework has point charges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L726-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.assign_charges" href="#PorousMaterials.assign_charges"><code>PorousMaterials.assign_charges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">new_framework = assign_charges(framework, charges, net_charge_tol=1e-5)</code></pre><p>Assign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of <code>framework.atoms</code>.</p><p>If the framework already has charges, the charges are removed and new charges are added accordingly so that <code>framework.atoms.n_atoms == framework.charges.n_charges</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">charges = Dict(:Ca =&gt; 2.0, :C =&gt; 1.0, :H =&gt; -1.0)
new_framework = assign_charges(framework, charges)</code></pre><pre><code class="language-none">charges = [4.0, 2.0, -6.0] # framework.atoms is length 3
new_framework = assign_charges(framework, charges)</code></pre><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: the framework to which we should add charges (not modified in</li></ul><p>this function)</p><ul><li><code>charges::Union{Dict{Symbol, Float64}, Array{Float64, 1}}</code>: a dictionary that returns the</li></ul><p>charge assigned to the species of atom or an array of charges to assign, with order consistent with the order in <code>framework.atoms</code> (units: electrons).</p><ul><li><code>net_charge_tol::Float64</code>: the net charge tolerated when asserting charge neutrality of</li></ul><p>the resulting framework</p><p><strong>Returns</strong></p><ul><li><code>new_framework::Framework</code>: a new framework identical to the one passed except charges</li></ul><p>are assigned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1260-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.apply_symmetry_rules" href="#PorousMaterials.apply_symmetry_rules"><code>PorousMaterials.apply_symmetry_rules</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulation_ready_framework = apply_symmetry_rules(non_p1_framework;
                                            check_charge_neutrality=true,
                                            net_charge_tol=0.001,
                                            check_atom_and_charge_overlap=true,
                                            remove_overlap=false,
                                            wrap_to_unit_cell=true)</code></pre><p>Convert a framework to P1 symmetry based on internal symmetry rules. This will return the new framework.</p><p><strong>Arguments</strong></p><ul><li><code>f::Framework</code>: The framework to be converted to P1 symmetry</li><li><code>check_charge_neutrality::Bool</code>: check for charge neutrality</li><li><code>net_charge_tol::Float64</code>: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.</li><li><code>check_atom_and_charge_overlap::Bool</code>: throw an error if overlapping atoms are detected.</li><li><code>remove_overlap::Bool</code>: remove identical atoms automatically. Identical atoms are the same element atoms which overlap.</li><li><code>wrap_to_unit_cell::Bool</code>: if true, enforce that fractional coords of atoms/charges are in [0,1]³ by mod(x, 1)</li></ul><p><strong>Returns</strong></p><ul><li><code>P1_framework::Framework</code>: The framework after it has been converted to P1   symmetry. The new symmetry rules will be the P1 symmetry rules</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L846-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.is_symmetry_equal" href="#PorousMaterials.is_symmetry_equal"><code>PorousMaterials.is_symmetry_equal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetry_equal = is_symmetry_equal(framework1.symmetry, framework2.symmetry)</code></pre><p>Returns true if both symmetry rules can create the same set from the same set of coordinates. Returns false if they don&#39;t contain the same number of rules or if they create different sets of points.</p><p><strong>Arguments</strong></p><ul><li><code>sym1::Array{AbstractString, 2}</code>: Array of strings that represent   symmetry operations</li><li><code>sym2::Array{AbstractString, 2}</code>: Array of strings that represent   symmetry operations</li></ul><p><strong>Returns</strong></p><ul><li><code>is_equal::Bool</code>: True if they are the same set of symmetry rules   False if they are different</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L933-L949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.write_cif" href="#PorousMaterials.write_cif"><code>PorousMaterials.write_cif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_cif(framework, filename; fractional=true)</code></pre><p>Write a <code>framework::Framework</code> to a .cif file with <code>filename::AbstractString</code>. If <code>filename</code> does not include the .cif extension, it will automatically be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1127-L1132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.BondingRule" href="#PorousMaterials.BondingRule"><code>PorousMaterials.BondingRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">bonding_rule = BondingRule(:Ca, :O, 0.4, 2.0)
bonding_rules = [BondingRule(:H, :*, 0.4, 1.2),
                 BondingRule(:*, :*, 0.4, 1.9)]</code></pre><p>A rule for determining if two atoms within a framework are bonded. </p><p><strong>Attributes</strong></p><p>-<code>species_i::Symbol</code>: One of the atoms types for this bond rule -<code>species_j::Symbol</code>: The other atom type for this bond rule -<code>min_dist</code>: The minimum distance between the atoms for bonding to occur -<code>max_dist</code>: The maximum distance between the atoms for bonding to occur</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.write_bond_information" href="#PorousMaterials.write_bond_information"><code>PorousMaterials.write_bond_information</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_bond_information(framework, filename)
write_bond_information(framework)</code></pre><p>Writes the bond information from a framework to the selected filename.</p><p><strong>Arguments</strong></p><p>-<code>framework::Framework</code>: The framework to have its bonds written to a vtk file -<code>filename::AbstractString</code>: The filename the bond information will be saved to. If left out, will default to framework name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1225-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.infer_bonds!" href="#PorousMaterials.infer_bonds!"><code>PorousMaterials.infer_bonds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">infer_bonds!(framework, include_bonds_across_periodic_boundaries, 
                bonding_rules=[BondingRule(:H, :*, 0.4, 1.2), BondingRule(:*, :*, 0.4, 1.9)])</code></pre><p>Populate the bonds in the framework object based on the bonding rules. If a pair doesn&#39;t have a suitable rule then they will not be considered bonded. </p><p><code>:*</code> is considered a wildcard and can be substituted for any species. It is a good idea to include a bonding rule between two <code>:*</code> to allow any atoms to bond as long as they are close enough.</p><p>The bonding rules are hierarchical, i.e. the first bonding rule takes precedence over the latter ones.</p><p><strong>Arguments</strong></p><p>-<code>framework::Framework</code>: The framework that bonds will be added to -<code>include_bonds_across_periodic_boundaries::Bool</code>: Whether to check across the     periodic boundary when calculating bonds -<code>bonding_rules::Array{BondingRule, 1}</code>: The array of bonding rules that will     be used to fill the bonding information. They are applied in the order that     they appear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1015-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.remove_bonds!" href="#PorousMaterials.remove_bonds!"><code>PorousMaterials.remove_bonds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_bonds!(framework)</code></pre><p>Remove all bonds from a framework structure.</p><p><strong>Arguments</strong></p><p>-<code>framework::Framework</code>: the framework that bonds wil be removed from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1001-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.compare_bonds_in_framework" href="#PorousMaterials.compare_bonds_in_framework"><code>PorousMaterials.compare_bonds_in_framework</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bonds_equal = compare_bonds_in_framework(framework1, framework2, atol=0.0)</code></pre><p>Returns whether the bonds defined in framework1 are the same as the bonds defined in framework2. It checks whether the atoms in the same positions have the same bonds.</p><p><strong>Arguments</strong></p><p>-<code>framework1::Framework</code>: The first framework -<code>framework2::Framework</code>: The second framework -<code>atol::Float64</code>: absolute tolerance for the comparison of coordinates in the framework</p><p><strong>Returns</strong></p><p>-<code>bonds_equal::Bool</code>: Wether the bonds in framework1 and framework2 are equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L1086-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.default_bondingrules" href="#PorousMaterials.default_bondingrules"><code>PorousMaterials.default_bondingrules</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_bondingrules = default_bondingrules()</code></pre><p>Returns the default bonding rules. Using <code>append!</code> and/or <code>prepend!</code> to add to the default bonding rules:</p><p><strong>Example</strong></p><pre><code class="language-none">bond_rules = default_bondingrules()
prepend!(bond_rules, BondingRule(:Cu, :*, 0.1, 2.6))</code></pre><p><strong>Returns</strong></p><p>-<code>default_bondingrules::Array{BondingRule, 1}</code>: The default bonding rules: <code>[BondingRule(:*, :*, 0.4, 1.2), BondingRule(:*, :*, 0.4, 1.9)]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Crystal.jl#L43-L56">source</a></section></article><h2 id="Grids-1"><a class="docs-heading-anchor" href="#Grids-1">Grids</a><a class="docs-heading-anchor-permalink" href="#Grids-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.Grid" href="#PorousMaterials.Grid"><code>PorousMaterials.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (<code>Box</code>). Each grid point has data, <code>data</code>, associated with it, of type <code>T</code>, stored in a 3D array.</p><p><strong>Attributes</strong></p><ul><li><code>box::Box</code>: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.</li><li><code>n_pts::Tuple{Int, Int, Int}</code>: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.</li><li><code>data::Array{T, 3}</code>: three dimensional array conaining data associated with each grid point.</li><li><code>units::Symbol</code>: the units associated with each data point.</li><li><code>origin::Array{Float64, 1}</code>: the origin of the grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.xf_to_id" href="#PorousMaterials.xf_to_id"><code>PorousMaterials.xf_to_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">voxel_id = xf_to_id(n_pts, xf)</code></pre><p>Returns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of <code>n_pts[1]</code> by <code>n_pts[2]</code> by <code>n_pts[3]</code> voxels. Periodic boundary conditions are applied.</p><p><strong>Arguments</strong></p><ul><li><code>n_pts::Tuple{Int, Int, Int}</code>: The number of points for each axis in the <code>Grid</code></li><li><code>xf::Array{Float64, 1}</code>: The fractional coordinates to be converted to an id</li></ul><p><strong>Returns</strong></p><ul><li><code>id::Array{Int, 1}</code>: The array indices for storing this point in space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.update_density!" href="#PorousMaterials.update_density!"><code>PorousMaterials.update_density!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_density!(grid, molecule, species)</code></pre><p>updates the density grid based on an array of molecules. If a molecule doesn&#39;t match the specified species it won&#39;t be added to the density grid. This function doesn&#39;t calculate the actual densities, it will need a <code>./ = num_snapshots</code> at the end of the GCMC simulation.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Grid</code>: the grid to be updated</li><li><code>molecules::Array{Molecule, 1}</code>: An array of molecules whose positions will  be added to the grid</li><li><code>species::Symbol</code>: The species of atom that can be added to this density grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.apply_periodic_boundary_condition!" href="#PorousMaterials.apply_periodic_boundary_condition!"><code>PorousMaterials.apply_periodic_boundary_condition!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_periodic_boundary_condition!(molecule)</code></pre><p>Check if the <code>center_of_mass</code> of a <code>Molecule</code> is outside of a <code>Box</code>. If so, apply periodic boundary conditions and translate the center of mass of the <code>Molecule</code> (and its atoms and point charges) so that it is inside of the <code>Box</code>.</p><p><strong>Arguments</strong></p><ul><li><code>molecule::Molecule</code>: A molecule we&#39;re interested in seeing if its&#39; center of mass falls within <code>simulation_box</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/MChelpers.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.write_cube" href="#PorousMaterials.write_cube"><code>PorousMaterials.write_cube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_cube(grid, filename, verbose=true)</code></pre><p>Write grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Grid</code>: grid with associated data at each grid point.</li><li><code>filename::AbstractString</code>: name of .cube file to which we write the grid; this is relative to <code>PATH_TO_GRIDS</code>.</li><li><code>verbose::Bool</code>: print name of file after writing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.read_cube" href="#PorousMaterials.read_cube"><code>PorousMaterials.read_cube</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid = read_cube(filename)</code></pre><p>Read a .cube file and return a populated <code>Grid</code> data structure.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: name of .cube file to which we write the grid; this is relative to <code>PATH_TO_GRIDS</code></li></ul><p><strong>Returns</strong></p><ul><li><code>grid::Grid</code>: A grid data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L155-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.energy_grid" href="#PorousMaterials.energy_grid"><code>PorousMaterials.energy_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750)</code></pre><p>Superimposes a regular grid of points (regularly spaced in fractional coordinates of the <code>framework.box</code>) over the unit cell of a crystal, with <code>n_gridpts</code> dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.</p><p>The ensemble average is a Boltzmann average over rotations:  - R T log ⟨e⁻ᵇᵁ⟩</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: crystal in which we seek to compute an energy grid for a molecule. <code>grid.box</code> will be <code>framework.box</code>.</li><li><code>molecule::Molecule</code>: molecule for which we seek an energy grid</li><li><code>ljforcefield::LJForceField</code>: molecular model for computing molecule-framework interactions</li><li><code>n_pts::Tuple{Int, Int, Int}=(50,50,50)</code>: number of grid points in each fractional coordinate dimension, including endpoints (0, 1)</li><li><code>n_rotations::Int</code>: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.</li></ul><p>This is only relevant for molecules that are comprised of more than one Lennard Jones sphere.</p><ul><li><code>temperature::Float64</code>: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.</li><li><code>units::Symbol</code>: either <code>:K</code> or <code>:kJ_mol</code>, the units in which the energy should be stored in the returned <code>Grid</code>.</li><li><code>center::Bool</code>: shift coords of grid so that the origin is the center of the unit cell <code>framework.box</code>.</li><li><code>verbose::Bool=true</code>: print some information.</li></ul><p><strong>Returns</strong></p><ul><li><code>grid::Grid</code>: A grid data structure containing the potential energy of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/d658dc5e7e6c158051f28a28455da209409cd7ea/src/Grid.jl#L221-L244">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matter/">« Matter</a><a class="docs-footer-nextpage" href="../molecules/">Molecules »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 10 January 2020 03:21">Friday 10 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
