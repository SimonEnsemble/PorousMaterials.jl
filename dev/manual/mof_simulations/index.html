<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Molecular Simulations · PorousMaterials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/flux.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PorousMaterials.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">PorousMaterials</a></li><li><a class="tocitem" href="../../guides/input_files/">Loading Data</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../matter/">Matter</a></li><li><a class="tocitem" href="../boxes_crystals_grids/">Boxes, Crystals, and Grids</a></li><li><a class="tocitem" href="../molecules/">Molecules</a></li><li><a class="tocitem" href="../atomic_interactions/">Atomic Interactions</a></li><li class="is-active"><a class="tocitem" href>Molecular Simulations</a><ul class="internal"><li><a class="tocitem" href="#Demo-of-Henry-coefficients-Calculation-1"><span>Demo of Henry coefficients Calculation</span></a></li><li><a class="tocitem" href="#Demo-of-Grand-canonical-Monte-Carlo-Simulations-1"><span>Demo of Grand-canonical Monte Carlo Simulations</span></a></li><li><a class="tocitem" href="#Henry-Coefficient-Calculations-1"><span>Henry Coefficient Calculations</span></a></li><li><a class="tocitem" href="#Grand-Canonical-Monte-Carlo-Simulations-1"><span>Grand-Canonical Monte Carlo Simulations</span></a></li></ul></li><li><a class="tocitem" href="../other/">Other</a></li></ul></li><li><a class="tocitem" href="../../guides/faq/">FAQ</a></li><li><a class="tocitem" href="../../guides/help_wanted/">Help Wanted</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Molecular Simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Molecular Simulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/master/docs/src/manual/mof_simulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Demo-of-Henry-coefficients-Calculation-1"><a class="docs-heading-anchor" href="#Demo-of-Henry-coefficients-Calculation-1">Demo of Henry coefficients Calculation</a><a class="docs-heading-anchor-permalink" href="#Demo-of-Henry-coefficients-Calculation-1" title="Permalink"></a></h2><p>Compute the Henry coefficient of CO&lt;sub&gt;2&lt;/sub&gt; in CAXVII_clean (Fe&lt;sub&gt;2&lt;/sub&gt;(dobdc)) at 298 K using the Dreiding force field:</p><pre><code class="language-julia">using PorousMaterials

# read in xtal structure file and populate a Framework data structure
framework = Framework(&quot;CAXVII_clean.cif&quot;)                                               

# read in Lennard-Jones force field parameters and populate a LJForceField data structure
forcefield = LJForceField(&quot;Dreiding.csv&quot;, cutoffradius=12.5)                                  

# read in a molecule format file and populate a Molecule data structure
molecule = Molecule(&quot;CO2&quot;)                                                              

temperature = 298.0 # K

# conduct Widom insertions and compute Henry coefficient, heat of adsorption
results = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200)

# ... prints stuff
# results automatically saved to .jld load later in one line of code

# returns dictionary for easy querying
results[&quot;Qst (kJ/mol)&quot;] # -21.0
results[&quot;henry coefficient [mol/(kg-Pa)]&quot;] # 2.88e-05</code></pre><p>The simulation is parallelized across a maximum of 5 cores.</p><h2 id="Demo-of-Grand-canonical-Monte-Carlo-Simulations-1"><a class="docs-heading-anchor" href="#Demo-of-Grand-canonical-Monte-Carlo-Simulations-1">Demo of Grand-canonical Monte Carlo Simulations</a><a class="docs-heading-anchor-permalink" href="#Demo-of-Grand-canonical-Monte-Carlo-Simulations-1" title="Permalink"></a></h2><p>Simulate the adsorption of CO&lt;sub&gt;2&lt;/sub&gt; in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:</p><pre><code class="language-julia">using PorousMaterials

# read in xtal structure file and populate a Framework data structure
framework = Framework(&quot;FIQCEN_clean_min_charges.cif&quot;)
# remove annoying numbers from atom labels
strip_numbers_from_atom_labels!(framework)

# read in Lennard-Jones force field parameters and populate a LJForceField data structure
forcefield = LJForceField(&quot;UFF.csv&quot;, cutoffradius=12.8)

# read in a molecule format file and populate a Molecule data structure
molecule = Molecule(&quot;CO2&quot;)

temperature = 298.0 # K
pressure = 1.0 # bar

# conduct grand-canonical Monte Carlo simulation
results, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield,
            n_burn_cycles=5000, n_sample_cycles=5000)

# ... prints stuff
# results automatically saved to .jld load later in one line of code

# returns dictionary for easy querying
results[&quot;⟨N⟩ (molecules/unit cell)&quot;]
results[&quot;Q_st (K)&quot;]</code></pre><p>Or, compute the entire adsorption isotherm at once, parallelized across many cores:</p><pre><code class="language-julia">pressures = [0.2, 0.6, 0.8, 1.0] # bar

# loop over all pressures and compute entire adsorption isotherm in parallel
results = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,
            n_burn_cycles=5000, n_sample_cycles=5000)</code></pre><p>Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:</p><pre><code class="language-julia"># loop over all pressures and run GCMC simulations in series.
# load in the configurations of the molecules from the previous pressure.
results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,
            n_burn_cycles=1000, n_sample_cycles=5000)</code></pre><h2 id="Henry-Coefficient-Calculations-1"><a class="docs-heading-anchor" href="#Henry-Coefficient-Calculations-1">Henry Coefficient Calculations</a><a class="docs-heading-anchor-permalink" href="#Henry-Coefficient-Calculations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.henry_coefficient" href="#PorousMaterials.henry_coefficient"><code>PorousMaterials.henry_coefficient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">result = henry_coefficient(framework, molecule, temperature, ljforcefield,
                            nb_insertions=1e6, verbose=true, ewald_precision=1e-6,
                            autosave=true)</code></pre><p>Conduct particle insertions to compute the Henry coefficient Kₕ of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): ⟨N⟩ = Kₕ P, where P is pressure and Kₕ is the Henry coefficient.</p><p>Kₕ = β ⟨e^{-β U}⟩, where the average is over positions and orientations of the molecule in the framework.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: the porous crystal in which we seek to simulate adsorption</li><li><code>molecule::Molecule</code>: the adsorbate molecule</li><li><code>temperature::Float64</code>: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)</li><li><code>ljforcefield::LJForceField</code>: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.</li><li><code>insertions_per_volume::Int</code>: number of Widom insertions to perform for computing the</li></ul><p>average, per unit cell volume (Å³)</p><ul><li><code>verbose::Bool</code>: whether or not to print off information during the simulation.</li><li><code>ewald_precision::Float64</code>: desired precision for Ewald summations; used to determine</li></ul><p>the replication factors in reciprocal space.</p><ul><li><code>autosave::Bool</code>: save results file as a .jld in PATH<em>TO</em>DATA * <code>sims</code></li><li><code>filename_comment::AbstractString</code>: An optional comment that will be appended to the name of the saved file.</li><li><code>write_checkpoint::Bool</code>: Will periodically save checkpoints to start the job from a previous state.</li><li><code>load_checkpoint::Bool</code>: Instructs the program to look for a checkpoint file in <code>data/henry_checkpoints</code></li></ul><p>and start the simulation from that point.</p><ul><li><code>checkpoint_frequency::Int</code>: The frequency at which we will save a checkpoint file. Is only used if <code>write_checkpoint=true</code></li></ul><p><strong>Returns</strong></p><ul><li><code>result::Dict{String, Float64}</code>: A dictionary containing all the results from the Henry coefficient simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/Henry.jl#L4-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.henry_result_savename" href="#PorousMaterials.henry_result_savename"><code>PorousMaterials.henry_result_savename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_name = henry_result_savename(framework, molecule, temperature,
                               ljforcefield, insertions_per_volume;
                               comment=&quot;&quot;)</code></pre><p>Determine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: The porous crystal being tested</li><li><code>molecule::Molecule</code>: The molecule being tested inside the crystal</li><li><code>temperature::Float64</code>: The temperature used in the simulation units: Kelvin (K)</li><li><code>ljforcefield::LJForceField</code>: The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces</li><li><code>insertions_per_volume::Union{Int, Float64}</code>: The number of widom insertions per unit volume.   Will be scaled according to the framework we&#39;re working with</li><li><code>comment::AbstractString</code>: An optional comment that will be appended to the filename</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/Henry.jl#L331-L349">source</a></section></article><h2 id="Grand-Canonical-Monte-Carlo-Simulations-1"><a class="docs-heading-anchor" href="#Grand-Canonical-Monte-Carlo-Simulations-1">Grand-Canonical Monte Carlo Simulations</a><a class="docs-heading-anchor-permalink" href="#Grand-Canonical-Monte-Carlo-Simulations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.gcmc_simulation" href="#PorousMaterials.gcmc_simulation"><code>PorousMaterials.gcmc_simulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">results, molecules = gcmc_simulation(framework, molecule, temperature, pressure,
                                     ljforcefield; n_sample_cycles=5000,
                                     n_burn_cycles=5000, sample_frequency=1,
                                     verbose=false, molecules=Molecule[],
                                     eos=:ideal, ewald_precision=1e-6,
                                     load_checkpoint_file=false,
                                     show_progress_bar=false, checkpoint=Dict(),
                                     write_checkpoints=false, checkpoint_frequency=100,
                                     write_adsorbate_snapshots=false,
                                     snapshot_frequency=1, calculate_density_grid=false,
                                     density_grid_dx=1.0, density_grid_species=nothing,
                                     filename_comment=&quot;&quot;)</code></pre><p>Runs a grand-canonical (μVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field.</p><p>A cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation.</p><p><strong>Arguments</strong></p><ul><li><code>framework::Framework</code>: the porous crystal in which we seek to simulate adsorption</li><li><code>molecule::Molecule</code>: a template of the adsorbate molecule of which we seek to simulate</li><li><code>temperature::Float64</code>: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)</li><li><code>pressure::Float64</code>: pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material. units: bar   the adsorption</li><li><code>ljforcefield::LJForceField</code>: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.</li><li><code>n_burn_cycles::Int</code>: number of cycles to allow the system to reach equilibrium before   sampling.</li><li><code>n_sample_cycles::Int</code>: number of cycles used for sampling</li><li><code>sample_frequency::Int</code>: during the sampling cycles, sample e.g. the number of adsorbed   gas molecules every this number of Markov proposals.</li><li><code>verbose::Bool</code>: whether or not to print off information during the simulation.</li><li><code>molecules::Array{Molecule, 1}</code>: a starting configuration of molecules in the framework.</li></ul><p>Note that we assume these coordinates are Cartesian, i.e. corresponding to a unit box.</p><ul><li><code>ewald_precision::Float64</code>: The desired precision for the long range Ewald summation</li><li><code>eos::Symbol</code>: equation of state to use for calculation of fugacity from pressure. Default</li></ul><p>is ideal gas, where fugacity = pressure.</p><ul><li><code>load_checkpoint_file::Bool</code>: Will find a checkpoint file corresponding to the <a href="#PorousMaterials.gcmc_result_savename"><code>gcmc_result_savename</code></a> if true.   If that file is not found, function will throw an error.</li><li><code>checkpoint::Dict</code>: A checkpoint dictionary that will work as a starting configuration for the run.   The dictionary has to have the following keys: <code>outer_cycle</code>, <code>molecules</code>, <code>system_energy</code>, <code>current_block</code>, <code>gcmc_stats</code>, <code>markov_counts</code>, <code>markov_chain_time</code> and <code>time</code>. If this argument is used, keep <code>load_checkpoint_file=false</code>.</li><li><code>write_checkpoints::Bool</code>: Will save checkpoints in data/gcmc_checkpoints if this is true.</li><li><code>checkpoint_frequency::Int</code>: Will save checkpoint files every <code>checkpoint_frequency</code> cycles.</li><li><code>write_adsorbate_snapshots::Bool</code>: Whether the simulation will create and save a snapshot file</li><li><code>snapshot_frequency::Int</code>: The number of cycles taken between each snapshot (after burn cycle completion)</li><li><code>calculate_density_grid::Bool</code>: Whether the simulation will keep track of a density grid for adsorbates</li><li><code>density_grid_dx::Float64</code>: The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by <a href="manual/@ref"><code>required_n_pts</code></a>.</li><li><code>density_grid_species::Symbol</code>: The atomic species within the <code>molecule</code> for which we will compute the density grid.</li><li><code>filename_comment::AbstractString</code>: An optional comment that will be appended to the name of the saved file (if autosaved)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/GCMC.jl#L260-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.adsorption_isotherm" href="#PorousMaterials.adsorption_isotherm"><code>PorousMaterials.adsorption_isotherm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">results = adsorption_isotherm(framework, molecule, temperature, pressures,
                              ljforcefield; n_sample_cycles=5000,
                              n_burn_cycles=5000, sample_frequency=1,
                              verbose=true, ewald_precision=1e-6, eos=:ideal, 
                              load_checkpoint_file=false, checkpoint=Dict(), 
                              write_checkpoints=false, checkpoint_frequency=50,
                              write_adsorbate_snapshots=false,
                              snapshot_frequency=1, calculate_density_grid=false,
                              density_grid_dx=1.0, density_grid_species=nothing,
                              filename_comment=&quot;&quot;, show_progress_bar=false)</code></pre><p>Run a set of grand-canonical (μVT) Monte Carlo simulations in parallel. Arguments are the same as <a href="#PorousMaterials.gcmc_simulation"><code>gcmc_simulation</code></a>, as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as <code>julia -p 4 mysim.jl</code> to allocate e.g. four cores. See <a href="https://docs.julialang.org/en/stable/manual/parallel-computing/#Parallel-Computing-1">Parallel Computing</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/GCMC.jl#L192-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.stepwise_adsorption_isotherm" href="#PorousMaterials.stepwise_adsorption_isotherm"><code>PorousMaterials.stepwise_adsorption_isotherm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures,
                              ljforcefield; n_sample_cycles=5000,
                              n_burn_cycles=5000, sample_frequency=1,
                              verbose=true, ewald_precision=1e-6, eos=:ideal,
                              load_checkpoint_file=false, checkpoint=Dict(),
                              write_checkpoints=false, checkpoint_frequency=50,
                              write_adsorbate_snapshots=false,
                              snapshot_frequency=1, calculate_density_grid=false,
                              density_grid_dx=1.0, density_grid_species=nothing,
                              filename_comment=&quot;&quot;, show_progress_bar=false)</code></pre><p>Run a set of grand-canonical (μVT) Monte Carlo simulations in series. Arguments are the same as <a href="#PorousMaterials.gcmc_simulation"><code>gcmc_simulation</code></a>, as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of <code>pressures</code> is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see <a href="#PorousMaterials.adsorption_isotherm"><code>adsorption_isotherm</code></a> which runs the μVT simulation at each pressure in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/GCMC.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PorousMaterials.gcmc_result_savename" href="#PorousMaterials.gcmc_result_savename"><code>PorousMaterials.gcmc_result_savename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">file_save_name = gcmc_result_savename(framework_name, molecule_species,
                                    ljforcefield_name, temperature, pressure,
                                    n_burn_cycles, n_sample_cycles; comment=&quot;&quot;,
                                    extension=&quot;&quot;)</code></pre><p>Determine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.</p><p><strong>Arguments</strong></p><ul><li><code>framework_name::AbstractString</code>: The porous crystal being tested</li><li><code>molecule_species::Symbol</code>: The molecule being tested inside the porous crystal</li><li><code>ljforcefield_name::AbstractString</code>: The molecular model being used in this   simulation to describe intermolecular Van der Waals interactions</li><li><code>temperature::Float64</code>: The temperature used in the simulation units: Kelvin (K)</li><li><code>pressure::Float64</code>: The pressure used in the simulation units: bar</li><li><code>n_burn_cycles::Int</code>: The number of burn cycles used in this simulation</li><li><code>n_sample_cycles::Int</code>: The number of sample cycles used in this simulation</li><li><code>comment::AbstractString</code>: An optional comment that will be appended to the end of the filename</li><li><code>extension::AbstractString</code>: The extension for the file being created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/PorousMaterials.jl/blob/16a3c273dfbd4c50dad2f2cc5708dbb42091ff2a/src/GCMC.jl#L893-L914">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../atomic_interactions/">« Atomic Interactions</a><a class="docs-footer-nextpage" href="../other/">Other »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 December 2019 00:10">Tuesday 24 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
