{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A pure- Julia package for classical molecular modeling of adsorption in porous crystals such as metal-organic frameworks (MOFs). \ud83d\udd28 Compute the potential energy of a molecule at particular position and orientation inside of a porous crystal \ud83d\udd28 Write a potential energy grid of a molecule inside a porous material to visualize binding sites \ud83d\udd28 Compute the Henry coefficient of a gas in a porous crystal \ud83d\udd28 Run grand-canonical Monte Carlo simulations of gas adsorption in a porous crystal Designed for high-throughput computations to minimize input files and querying results from output files. User-friendly. Instructive error messages thrown when they should be. Well-documented. Easy to install. In development, please contribute, post issues \ud83d\udc1b, and improve! Installation # Download and install the Julia programming language , v1.0. In Julia, open the package manager (using ] ) and enter the following: add PorousMaterials In Julia, load all functions in PorousMaterials.jl into the namespace: using PorousMaterials # that's it Tests # Run the unit-ish tests in the script tests/runtests.jl manually or type Pkg.test(\"PorousMaterials\") into Julia. Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and are found in tests/henry_test.jl and tests/gcmc_test.jl .","title":"PorousMaterials"},{"location":"#installation","text":"Download and install the Julia programming language , v1.0. In Julia, open the package manager (using ] ) and enter the following: add PorousMaterials In Julia, load all functions in PorousMaterials.jl into the namespace: using PorousMaterials # that's it","title":"Installation"},{"location":"#tests","text":"Run the unit-ish tests in the script tests/runtests.jl manually or type Pkg.test(\"PorousMaterials\") into Julia. Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and are found in tests/henry_test.jl and tests/gcmc_test.jl .","title":"Tests"},{"location":"guides/faq/","text":"FAQ # How do I type out the math symbols? e.g. box.\u03b1 ? Julia supports unicode input ! Type box.\\alpha , then hit tab. Voil\u00e0. There is a vim extension for Julia here . How do I run as a script in the command line? It is instructive to first run an example in the Julia REPL so you can print out and interact with attributes of your forcefield , framework , and molecule to ensure they are correct. If you want to then run the Julia code in the command line, simply put the commands in a text file with a .jl extension and run in terminal as julia my_script.jl . For parallelization in adsorption_isotherm and henry_coefficient , call e.g. 4 cores with julia -p 4 my_script.jl . Can I use PorousMaterials.jl in Jupyter Notebook/ Jupyter Lab? Yes! See here . How can I convert my .cif into P1 symmetry for PorousMaterials.jl ? We hope someone will contribute this feature to PorousMaterials.jl eventually. For now, you can use OpenBabel : obabel -icif non-P1.cif -ocif -O P1.cif --fillUC strict","title":"FAQ"},{"location":"guides/faq/#faq","text":"How do I type out the math symbols? e.g. box.\u03b1 ? Julia supports unicode input ! Type box.\\alpha , then hit tab. Voil\u00e0. There is a vim extension for Julia here . How do I run as a script in the command line? It is instructive to first run an example in the Julia REPL so you can print out and interact with attributes of your forcefield , framework , and molecule to ensure they are correct. If you want to then run the Julia code in the command line, simply put the commands in a text file with a .jl extension and run in terminal as julia my_script.jl . For parallelization in adsorption_isotherm and henry_coefficient , call e.g. 4 cores with julia -p 4 my_script.jl . Can I use PorousMaterials.jl in Jupyter Notebook/ Jupyter Lab? Yes! See here . How can I convert my .cif into P1 symmetry for PorousMaterials.jl ? We hope someone will contribute this feature to PorousMaterials.jl eventually. For now, you can use OpenBabel : obabel -icif non-P1.cif -ocif -O P1.cif --fillUC strict","title":"FAQ"},{"location":"guides/help_wanted/","text":"Help wanted and needed # the speed of a GCMC or Henry simulation is determined primarily by how fast PorousMaterials.jl can compute the electrostatic and vdw potential energy. Some core functions that can speed up this are: nearest_image! in src/NearestImage.jl Ewald sums in src/Electrostatics.jl . (electrostatics are a huge bottleneck.) src/VdWEnergetics.jl The scripts test/vdw_timing.jl and test/ewald_timing.jl time the functions for benchmarking. consolidate eikar , eikbr , eikcr somehow without slowing down the Ewald sum. more tests added to tests/runtests.jl , tests/henry_tests.jl , tests/gcmc_tests.jl geometric-based pore size calculations (largest free and included spheres), surface area, and porosity calculations that take Framework 's as input handle .cif's without P1 symmetry. i.e. convert any .cif to P1 symmetry extend gcmc_simulation to handle mixtures better default rules for choosing Ewald sum parameters? alpha, kvectors required... Henry coefficient code prints off Ewald sum params 5 times if run with one core... set good defaults for gcmc_simulation probabilities (as now) but also allow user to change through default arguments to the function automatically adjust the translation step \u03b4 in gcmc_simulation during burn cycles to have 50% acceptance of translation moves (online gradient descent?) EQEq or other charge equilibration schemes for assinging charges, taking a Framework as input.","title":"Help Wanted"},{"location":"guides/help_wanted/#help-wanted-and-needed","text":"the speed of a GCMC or Henry simulation is determined primarily by how fast PorousMaterials.jl can compute the electrostatic and vdw potential energy. Some core functions that can speed up this are: nearest_image! in src/NearestImage.jl Ewald sums in src/Electrostatics.jl . (electrostatics are a huge bottleneck.) src/VdWEnergetics.jl The scripts test/vdw_timing.jl and test/ewald_timing.jl time the functions for benchmarking. consolidate eikar , eikbr , eikcr somehow without slowing down the Ewald sum. more tests added to tests/runtests.jl , tests/henry_tests.jl , tests/gcmc_tests.jl geometric-based pore size calculations (largest free and included spheres), surface area, and porosity calculations that take Framework 's as input handle .cif's without P1 symmetry. i.e. convert any .cif to P1 symmetry extend gcmc_simulation to handle mixtures better default rules for choosing Ewald sum parameters? alpha, kvectors required... Henry coefficient code prints off Ewald sum params 5 times if run with one core... set good defaults for gcmc_simulation probabilities (as now) but also allow user to change through default arguments to the function automatically adjust the translation step \u03b4 in gcmc_simulation during burn cycles to have 50% acceptance of translation moves (online gradient descent?) EQEq or other charge equilibration schemes for assinging charges, taking a Framework as input.","title":"Help wanted and needed"},{"location":"guides/input_files/","text":"Input files to describe crystals, molecules, and forcefields # All input files are stored in the path PorousMaterials.PATH_TO_DATA (type into Julia). By default, this path is set to be in the present working directory (type pwd() into Julia) in a folder data/ . Go inside PorousMaterials.jl/test/data to see example input files for each case below. There will be example code snippets through the documentation showing how to load in various files. To get a feel for this we have included a Tutorial Mode in PorousMaterials.jl that sets the PorousMaterial.PATH_TO_DATA to the data folder in our testing directory. To follow along with the examples without downloading your own data simply do the following: using PorousMaterials set_tutorial_mode() \u250c Warning: PorousMaterials is now in Tutorial Mode. You have access to the testing data to experiment with PorousMaterials. \u2502 To get access to your own data use: reset_path_to_data() \u2514 @ PorousMaterials ~/git_files/PorousMaterials.jl/src/PorousMaterials.jl:75 Atomic masses # Add fancy pseudo-atoms to data/atomic_masses.csv . Peng-Robinson gas parameters # Critical temperatures and pressures and acentric factors are stored in data/PengRobinsonGasProps.csv .","title":"Loading Data"},{"location":"guides/input_files/#input-files-to-describe-crystals-molecules-and-forcefields","text":"All input files are stored in the path PorousMaterials.PATH_TO_DATA (type into Julia). By default, this path is set to be in the present working directory (type pwd() into Julia) in a folder data/ . Go inside PorousMaterials.jl/test/data to see example input files for each case below. There will be example code snippets through the documentation showing how to load in various files. To get a feel for this we have included a Tutorial Mode in PorousMaterials.jl that sets the PorousMaterial.PATH_TO_DATA to the data folder in our testing directory. To follow along with the examples without downloading your own data simply do the following: using PorousMaterials set_tutorial_mode() \u250c Warning: PorousMaterials is now in Tutorial Mode. You have access to the testing data to experiment with PorousMaterials. \u2502 To get access to your own data use: reset_path_to_data() \u2514 @ PorousMaterials ~/git_files/PorousMaterials.jl/src/PorousMaterials.jl:75","title":"Input files to describe crystals, molecules, and forcefields"},{"location":"guides/input_files/#atomic-masses","text":"Add fancy pseudo-atoms to data/atomic_masses.csv .","title":"Atomic masses"},{"location":"guides/input_files/#peng-robinson-gas-parameters","text":"Critical temperatures and pressures and acentric factors are stored in data/PengRobinsonGasProps.csv .","title":"Peng-Robinson gas parameters"},{"location":"manual/atomic_interactions/","text":"Loading in Forcefield Files # Lennard-Jones forcefield parameters are stored in comma-separated-value format in PorousMaterials.PATH_TO_FORCEFIELDS . Interaction of an adsorbate with the framework is modeled as pair-wise additive and with Lennard-Jones potentials of the form: V(r) = 4 * epsilon * [ x ^ 12 - x ^ 6 ] , where x = sigma / r The Lennard Jones force field input files, e.g. UFF.csv contain a list of pure (i.e. X-X, where X is an atom) sigmas and epsilons in units Angstrom and Kelvin, respectively. Note that, e.g., in the UFF paper, the Lennard Jones potential is written in a different form and thus parameters need to be converted to correspond to the functional form used in PorousMaterials.jl . using PorousMaterials ljff = LJForceField( UFF.csv ) PorousMaterials will the output information about the forcefield file you just loaded: Force field: UFF.csv Number of atoms included: 106 Cut-off radius (\u212b) = 14.0 This also prints all of the atoms included in the loaded forcefield with their given \u03f5 and \u03c3. This was excluded because it would use too much space on this page. Building Blocks of PorousMaterials: Lennard-Jones forcefields # # read in Lennard-Jones force field parameters from the Universal Force Field forcefield = LJForceField( UFF.csv , cutoffradius=14.0, mixing_rules= Lorentz-Berthelot ) # access the Lennard-Jones epsilon sigma for Xe forcefield.pure_\u03f5[:Xe] # K forcefield.pure_\u03c3[:Xe] # \u212b # access the Lennard-Jones epsilon sigma for Xe-C interactions forcefield.\u03f5[:Xe][:C] # K forcefield.\u03c3\u00b2[:Xe][:C] # \u212b (store \u03c3\u00b2 for faster computation) Building Blocks of PorousMaterials: Potential energies # First, set the fractional coordinates of the molecule in the context of some unit cell box. # molecule in a framework set_fractional_coords!(molecule, framework.box) # molecule in a 10 by 10 by 10 cube box = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) # make a box set_fractional_coords!(molecule, box) Potential Energies: Van der Waals # What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at [0.0, 1.0, 3.0] Cartesian coordinates using the UFF as a molecular model? using PorousMaterials framework = Framework( SBMOF-1.cif ) forcefield = LJForceField( UFF.csv ) molecule = Molecule( Xe ) set_fractional_coords!(molecule, framework.box) translate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian energy = vdw_energy(framework, molecule, forcefield) # K Potential Energies: Electrostatics # What is the electrostatic potential energy of a CO 2 adsorbate inside CAXVII_clean at [0.0, 1.0, 0.0] Cartesian coordinate? using PorousMaterials framework = Framework( CAXVII_clean.cif ) # has charges molecule = Molecule( CO2 ) set_fractional_coords!(molecule, framework.box) translate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian rotate!(molecule, framework.box) # let's give it a random orientation # this is for speed. pre-compute k-vectors and allocate memory eparams, kvectors, eikar, eikbr, eikcr = setup_Ewald_sum(12.0, framework.box) energy = electrostatic_potential_energy(framework, molecule, eparams, kvectors, eikar, eikbr, eikcr) Potential Energies: Equations of state # Calculate fugacity of methane at 298 K and 65 bar using the Peng-Robinson EOS: fluid = PengRobinsonFluid(:CH4) props = calculate_properties(fluid, 298.0, 65.0) # dictionary of PREOS properties props[ fugacity coefficient ] # 0.8729 Calculate compressibility factor of hydrogen at 300 K and 50 bar using van der Waals EOS: fluid = VdWFluid(:H2) props = calculate_properties(fluid, 300.0, 50.0) # dictionary of VdW properties props[ compressibility factor ] # 1.03511 Pass eos=:PengRobinson to gcmc_simulation to automatically convert pressure to fugacity using the Peng-Robinson equation of state. Forcefields # # PorousMaterials.LJForceField Type . Data structure for a Lennard Jones forcefield. Attributes name::String : name of forcefield; correponds to filename pure_\u03c3::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03c3 of an X-X interaction, where X is an atom. (units: Angstrom) pure_\u03f5::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03f5 of an X-X interaction, where X is an atom. (units: K) \u03c3\u00b2::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03c3\u00b2 (units: Angstrom\u00b2) for cross-interactions. Example use is sigmas_squared[:He][:C] \u03f5::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03f5 (units: K) for cross-interactions. Example use is epsilons[:He][:C] cutoffradius_squared::Float64 : The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom\u00b2). We store \u03c3\u00b2 to speed up computations, which involve \u03c3\u00b2, not \u03c3. source # PorousMaterials.replication_factors Function . repfactors = replication_factors(unitcell, cutoffradius) Find the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied. A non-replicated supercell has 1 as the replication factor in each dimension ( repfactors = (1, 1, 1) ). Arguments unitcell::Box : The unit cell of the framework cutoff_radius::Float64 : Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom) Returns repfactors::Tuple{Int, Int, Int} : The replication factors in the a, b, c directions source # PorousMaterials.check_forcefield_coverage Function . check_forcefield_coverage(framework, ljforcefield) check_forcefield_coverage(molecule, ljforcefield) Check that the force field contains parameters for every atom present in a framework or molecule. Will print out which atoms are missing. Arguments framework::Framework : The framework containing the crystal structure information molecule::Molecule : A molecule object ljforcefield::LJForceField : A Lennard Jones forcefield object containing information on atom interactions Returns all_covered::Bool : Returns true if all atoms in the framework are also included in ljforcefield . False otherwise source Potential Energy # # PorousMaterials.PotentialEnergy Type . pe = PotentialEnergy() Data structure to store potential energy, partitioned into van der Waals ( energy.vdw ) and electrostatic ( energy.coulomb ) interactions, both Float64 . This returns a PotentialEnergy data type where the vdw and coulomb attributes are set to 0.0 Returns pe::PotentialEnergy : A structure containing van der Waals and electrostatic energies, initialized at 0.0 Attributes vdw::Float64 : The potential energy contributions from Van der Waals interactions coulomb::Float64 : The potential energy contributions from electrostatic interactions source # PorousMaterials.SystemPotentialEnergy Type . system_potential_energy = SystemPotentialEnergy() Data structure to facilitate storing/partitioning potential energy of a system. It stores the potential energy from guest-host and guest-guest interactions separately. This initializes guest host and guest guest with PotentialEnergy(), so when it is created the total energy recorded is 0.0 Returns system_potential_energy::SystemPotentialEnergy : A structure containing the potential energy of the system, broken down into guest-guest and guest-host interactions Attributes guest_host::PotentialEnergy : The total potential energy from all guest-host interactions in the system guest_guest::PotentialEnergy : The total potential energy from all guest-guest interactions in the system source Nearest Image Conventions # # PorousMaterials.nearest_image! Function . nearest_image!(dxf) Applies the nearest image convention on a vector dxf between two atoms in fractional space; modifies dxf for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space. Warning: this assumes the two molecules are in the box described by fractional coords [0, 1]\u00b3. Arguments dxf::Array{Float64} : A vector between two atoms in fractional space source Electrostatics Energy # # PorousMaterials.Eikr Type . eikr = Eikr(eikar, eikbr, eikcr) mutable struct for holding the eikr vectors Attributes eikar::OffsetArray{Complex{Float64}} : array for storing e^{i * ka \u22c5 r}; has indices 0:kreps[1] and corresponds to recip. vectors in a-direction eikbr::OffsetArray{Complex{Float64}} : array for storing e^{i * kb \u22c5 r}; has indices -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction eikcr::OffsetArray{Complex{Float64}} : array for storing e^{i * kc \u22c5 r}; has indices -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction source # PorousMaterials.electrostatic_potential_energy Function . \u03d5 = electrostatic_potential_energy(framework, molecule, eparams, eikr) Compute the electrostatic potential energy of a molecule inside a framework. The electrostatic potential is created by the point charges assigned to the framework atoms in framework.charges . Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at differences in energy in a Monte Carlo simulation. Warning: it is assumed that the framework is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in eparams.sr_cutoff_r . Arguments framework::Framework : Crystal structure (see framework.charges for charges) molecule::Molecule : The molecule being compared to the atoms in the framework. eparams::EwaldParams : data structure containing Ewald summation settings eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns pot::EwaldSum : Electrostatic potential between framework and molecule (units: K) source \u03d5 = electrostatic_potential_energy(molecules, eparams, box, eikr) Compute the electrostatic potential energy of a system comprised of an array of Molecule s. The EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive. Returns an EwaldSum type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (\u03d5.sr, \u03d5.lr, \u03d5.self, \u03d5.intra). Units of energy: Kelvin Arguments molecules::Array{Molecules, 1} : array of molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings box::Box : the box the energy is being computed in eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns \u03d5::GGEwaldSum : The total electrostatic potential energy source # PorousMaterials.precompute_kvec_wts Function . kvectors = precompute_kvec_wts(kreps, box, \u03b1, max_mag_k_sqrd=Inf) For speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry: cos(-k\u22c5(x-x\u1d62)) + cos(k\u22c5(x-x\u1d62)) = 2 cos(k\u22c5(x-x\u1d62)) If max_mag_k_sqrd is passed, k-vectors with a magnitude greater than max_mag_k_sqrd are not included. Arguments kreps::Tuple{Int, Int, Int} : number of k-vector replications required in a, b, c box::Box : the simulation box containing the reciprocal lattice. \u03b1::Float64 : Ewald sum convergence parameter (units: inverse \u212b) max_mag_k_sqrd::Float64 : cutoff for |k|\u00b2 in Fourier sum; if passed, do not include k-vectors with magnitude squared greater than this. Returns kvectors::Array{Kvector, 1} : array of k-vectors to include in the Fourier sum and their corresponding weights indicating the contribution to the Fourier sum. source # PorousMaterials.setup_Ewald_sum Function . eparams = setup_Ewald_sum(box, sr_cutoff_r; \u03f5=1e-6, verbose=false) Given the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information. Also, pre-compute weights on k-vector contributions to Ewald sum in Fourier space. Also, allocate OffsetArrays for storing e^{i * k \u22c5 r} where r = x - x\u2c7c and k is a reciprocal lattice vector. Arguments box::Box : the simulation box containing the reciprocal lattice. sr_cutoff_r::Float64 : cutoff-radius (units: \u212b) for short-range contributions to Ewald \u03f5::Float64 : desired level of precision. Typical value is 1e-6, but this does not verbose::Bool : If true will print results Returns eparams::EwaldParams : data structure containing Ewald summation settings corresponding weights indicating the contribution to the Fourier sum. source # PorousMaterials.total_electrostatic_potential_energy Function . total_\u03d5 = total_electrostatic_potential_energy(molecules, eparams, box, eikr) Calculates the total electrostatic potential energy of an array of Molecule s using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this Arguments molecules::Array{Molecule, 1} : The molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings box::Box : The box the energy is being computed in. eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns \u03d5::GGEwaldSum : The total electrostatic potential energy source total_\u03d5 = total_electrostatic_potential_energy(framework, molecules, eparams, eikr) Explanation of total electrostatic potential_energy that uses framework Arguments framework::Framework : Crystal structure (see framework.charges for charges) molecules::Array{Molecule, 1} : The molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. source Van der Waals Energy # # PorousMaterials.lennard_jones Function . energy = lennard_jones(r\u00b2, \u03c3\u00b2, \u03f5) (units: Kelvin) Calculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. \u03c3 and \u03f5 are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of \u03f5 are). Arguments r\u00b2::Float64 : distance between two (pseudo)atoms in question squared (Angstrom\u00b2) \u03c3\u00b2::Float64 : sigma parameter in Lennard Jones potential squared (units: Angstrom\u00b2) \u03f5::Float64 : epsilon parameter in Lennard Jones potential (units: Kelvin) Returns energy::Float64 : Lennard Jones potential energy source # PorousMaterials.vdw_energy Function . energy = vdw_energy(framework, molecule, ljforcefield) Calculates the van der Waals interaction energy between a molecule and a framework. Applies the nearest image convention to find the closest replicate of a specific atom. WARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See replicate . Arguments framework::Framework : Crystal structure molecule::Molecule : adsorbate (includes position/orientation/atoms) ljforcefield::LJForceField : Lennard Jones force field Returns energy::Float64 : Van der Waals interaction energy source gg_energy = vdw_energy(molecule_id, molecules, ljforcefield, simulation_box) Calculates van der Waals interaction energy of a single adsorbate molecules[molecule_id] with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention. Arguments molecule_id::Int : Molecule ID used to determine which molecule in molecules we wish to calculate the guest-guest interactions molecules::Array{Molecule, 1} : An array of Molecule data structures ljforcefield::LJForceField : A Lennard Jones forcefield data structure describing the interactions between different atoms simulation_box::Box : The simulation box for the computation. Returns gg_energy::Float64 : The guest-guest interaction energy of molecules[molecule_id] with the other molecules in molecules source # PorousMaterials.vdw_energy_no_PBC Function . pot_energy = vdw_energy_no_PBC(atoms, molecule, ljff) Assumes unit cell box is a unit cube and no periodic boundary conditions are applied. source","title":"Atomic Interactions"},{"location":"manual/atomic_interactions/#loading-in-forcefield-files","text":"Lennard-Jones forcefield parameters are stored in comma-separated-value format in PorousMaterials.PATH_TO_FORCEFIELDS . Interaction of an adsorbate with the framework is modeled as pair-wise additive and with Lennard-Jones potentials of the form: V(r) = 4 * epsilon * [ x ^ 12 - x ^ 6 ] , where x = sigma / r The Lennard Jones force field input files, e.g. UFF.csv contain a list of pure (i.e. X-X, where X is an atom) sigmas and epsilons in units Angstrom and Kelvin, respectively. Note that, e.g., in the UFF paper, the Lennard Jones potential is written in a different form and thus parameters need to be converted to correspond to the functional form used in PorousMaterials.jl . using PorousMaterials ljff = LJForceField( UFF.csv ) PorousMaterials will the output information about the forcefield file you just loaded: Force field: UFF.csv Number of atoms included: 106 Cut-off radius (\u212b) = 14.0 This also prints all of the atoms included in the loaded forcefield with their given \u03f5 and \u03c3. This was excluded because it would use too much space on this page.","title":"Loading in Forcefield Files"},{"location":"manual/atomic_interactions/#building-blocks-of-porousmaterials-lennard-jones-forcefields","text":"# read in Lennard-Jones force field parameters from the Universal Force Field forcefield = LJForceField( UFF.csv , cutoffradius=14.0, mixing_rules= Lorentz-Berthelot ) # access the Lennard-Jones epsilon sigma for Xe forcefield.pure_\u03f5[:Xe] # K forcefield.pure_\u03c3[:Xe] # \u212b # access the Lennard-Jones epsilon sigma for Xe-C interactions forcefield.\u03f5[:Xe][:C] # K forcefield.\u03c3\u00b2[:Xe][:C] # \u212b (store \u03c3\u00b2 for faster computation)","title":"Building Blocks of PorousMaterials: Lennard-Jones forcefields"},{"location":"manual/atomic_interactions/#building-blocks-of-porousmaterials-potential-energies","text":"First, set the fractional coordinates of the molecule in the context of some unit cell box. # molecule in a framework set_fractional_coords!(molecule, framework.box) # molecule in a 10 by 10 by 10 cube box = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) # make a box set_fractional_coords!(molecule, box)","title":"Building Blocks of PorousMaterials: Potential energies"},{"location":"manual/atomic_interactions/#potential-energies-van-der-waals","text":"What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at [0.0, 1.0, 3.0] Cartesian coordinates using the UFF as a molecular model? using PorousMaterials framework = Framework( SBMOF-1.cif ) forcefield = LJForceField( UFF.csv ) molecule = Molecule( Xe ) set_fractional_coords!(molecule, framework.box) translate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian energy = vdw_energy(framework, molecule, forcefield) # K","title":"Potential Energies: Van der Waals"},{"location":"manual/atomic_interactions/#potential-energies-electrostatics","text":"What is the electrostatic potential energy of a CO 2 adsorbate inside CAXVII_clean at [0.0, 1.0, 0.0] Cartesian coordinate? using PorousMaterials framework = Framework( CAXVII_clean.cif ) # has charges molecule = Molecule( CO2 ) set_fractional_coords!(molecule, framework.box) translate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian rotate!(molecule, framework.box) # let's give it a random orientation # this is for speed. pre-compute k-vectors and allocate memory eparams, kvectors, eikar, eikbr, eikcr = setup_Ewald_sum(12.0, framework.box) energy = electrostatic_potential_energy(framework, molecule, eparams, kvectors, eikar, eikbr, eikcr)","title":"Potential Energies: Electrostatics"},{"location":"manual/atomic_interactions/#potential-energies-equations-of-state","text":"Calculate fugacity of methane at 298 K and 65 bar using the Peng-Robinson EOS: fluid = PengRobinsonFluid(:CH4) props = calculate_properties(fluid, 298.0, 65.0) # dictionary of PREOS properties props[ fugacity coefficient ] # 0.8729 Calculate compressibility factor of hydrogen at 300 K and 50 bar using van der Waals EOS: fluid = VdWFluid(:H2) props = calculate_properties(fluid, 300.0, 50.0) # dictionary of VdW properties props[ compressibility factor ] # 1.03511 Pass eos=:PengRobinson to gcmc_simulation to automatically convert pressure to fugacity using the Peng-Robinson equation of state.","title":"Potential Energies: Equations of state"},{"location":"manual/atomic_interactions/#forcefields","text":"# PorousMaterials.LJForceField Type . Data structure for a Lennard Jones forcefield. Attributes name::String : name of forcefield; correponds to filename pure_\u03c3::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03c3 of an X-X interaction, where X is an atom. (units: Angstrom) pure_\u03f5::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03f5 of an X-X interaction, where X is an atom. (units: K) \u03c3\u00b2::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03c3\u00b2 (units: Angstrom\u00b2) for cross-interactions. Example use is sigmas_squared[:He][:C] \u03f5::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03f5 (units: K) for cross-interactions. Example use is epsilons[:He][:C] cutoffradius_squared::Float64 : The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom\u00b2). We store \u03c3\u00b2 to speed up computations, which involve \u03c3\u00b2, not \u03c3. source # PorousMaterials.replication_factors Function . repfactors = replication_factors(unitcell, cutoffradius) Find the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied. A non-replicated supercell has 1 as the replication factor in each dimension ( repfactors = (1, 1, 1) ). Arguments unitcell::Box : The unit cell of the framework cutoff_radius::Float64 : Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom) Returns repfactors::Tuple{Int, Int, Int} : The replication factors in the a, b, c directions source # PorousMaterials.check_forcefield_coverage Function . check_forcefield_coverage(framework, ljforcefield) check_forcefield_coverage(molecule, ljforcefield) Check that the force field contains parameters for every atom present in a framework or molecule. Will print out which atoms are missing. Arguments framework::Framework : The framework containing the crystal structure information molecule::Molecule : A molecule object ljforcefield::LJForceField : A Lennard Jones forcefield object containing information on atom interactions Returns all_covered::Bool : Returns true if all atoms in the framework are also included in ljforcefield . False otherwise source","title":"Forcefields"},{"location":"manual/atomic_interactions/#potential-energy","text":"# PorousMaterials.PotentialEnergy Type . pe = PotentialEnergy() Data structure to store potential energy, partitioned into van der Waals ( energy.vdw ) and electrostatic ( energy.coulomb ) interactions, both Float64 . This returns a PotentialEnergy data type where the vdw and coulomb attributes are set to 0.0 Returns pe::PotentialEnergy : A structure containing van der Waals and electrostatic energies, initialized at 0.0 Attributes vdw::Float64 : The potential energy contributions from Van der Waals interactions coulomb::Float64 : The potential energy contributions from electrostatic interactions source # PorousMaterials.SystemPotentialEnergy Type . system_potential_energy = SystemPotentialEnergy() Data structure to facilitate storing/partitioning potential energy of a system. It stores the potential energy from guest-host and guest-guest interactions separately. This initializes guest host and guest guest with PotentialEnergy(), so when it is created the total energy recorded is 0.0 Returns system_potential_energy::SystemPotentialEnergy : A structure containing the potential energy of the system, broken down into guest-guest and guest-host interactions Attributes guest_host::PotentialEnergy : The total potential energy from all guest-host interactions in the system guest_guest::PotentialEnergy : The total potential energy from all guest-guest interactions in the system source","title":"Potential Energy"},{"location":"manual/atomic_interactions/#nearest-image-conventions","text":"# PorousMaterials.nearest_image! Function . nearest_image!(dxf) Applies the nearest image convention on a vector dxf between two atoms in fractional space; modifies dxf for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space. Warning: this assumes the two molecules are in the box described by fractional coords [0, 1]\u00b3. Arguments dxf::Array{Float64} : A vector between two atoms in fractional space source","title":"Nearest Image Conventions"},{"location":"manual/atomic_interactions/#electrostatics-energy","text":"# PorousMaterials.Eikr Type . eikr = Eikr(eikar, eikbr, eikcr) mutable struct for holding the eikr vectors Attributes eikar::OffsetArray{Complex{Float64}} : array for storing e^{i * ka \u22c5 r}; has indices 0:kreps[1] and corresponds to recip. vectors in a-direction eikbr::OffsetArray{Complex{Float64}} : array for storing e^{i * kb \u22c5 r}; has indices -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction eikcr::OffsetArray{Complex{Float64}} : array for storing e^{i * kc \u22c5 r}; has indices -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction source # PorousMaterials.electrostatic_potential_energy Function . \u03d5 = electrostatic_potential_energy(framework, molecule, eparams, eikr) Compute the electrostatic potential energy of a molecule inside a framework. The electrostatic potential is created by the point charges assigned to the framework atoms in framework.charges . Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at differences in energy in a Monte Carlo simulation. Warning: it is assumed that the framework is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in eparams.sr_cutoff_r . Arguments framework::Framework : Crystal structure (see framework.charges for charges) molecule::Molecule : The molecule being compared to the atoms in the framework. eparams::EwaldParams : data structure containing Ewald summation settings eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns pot::EwaldSum : Electrostatic potential between framework and molecule (units: K) source \u03d5 = electrostatic_potential_energy(molecules, eparams, box, eikr) Compute the electrostatic potential energy of a system comprised of an array of Molecule s. The EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive. Returns an EwaldSum type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (\u03d5.sr, \u03d5.lr, \u03d5.self, \u03d5.intra). Units of energy: Kelvin Arguments molecules::Array{Molecules, 1} : array of molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings box::Box : the box the energy is being computed in eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns \u03d5::GGEwaldSum : The total electrostatic potential energy source # PorousMaterials.precompute_kvec_wts Function . kvectors = precompute_kvec_wts(kreps, box, \u03b1, max_mag_k_sqrd=Inf) For speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry: cos(-k\u22c5(x-x\u1d62)) + cos(k\u22c5(x-x\u1d62)) = 2 cos(k\u22c5(x-x\u1d62)) If max_mag_k_sqrd is passed, k-vectors with a magnitude greater than max_mag_k_sqrd are not included. Arguments kreps::Tuple{Int, Int, Int} : number of k-vector replications required in a, b, c box::Box : the simulation box containing the reciprocal lattice. \u03b1::Float64 : Ewald sum convergence parameter (units: inverse \u212b) max_mag_k_sqrd::Float64 : cutoff for |k|\u00b2 in Fourier sum; if passed, do not include k-vectors with magnitude squared greater than this. Returns kvectors::Array{Kvector, 1} : array of k-vectors to include in the Fourier sum and their corresponding weights indicating the contribution to the Fourier sum. source # PorousMaterials.setup_Ewald_sum Function . eparams = setup_Ewald_sum(box, sr_cutoff_r; \u03f5=1e-6, verbose=false) Given the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information. Also, pre-compute weights on k-vector contributions to Ewald sum in Fourier space. Also, allocate OffsetArrays for storing e^{i * k \u22c5 r} where r = x - x\u2c7c and k is a reciprocal lattice vector. Arguments box::Box : the simulation box containing the reciprocal lattice. sr_cutoff_r::Float64 : cutoff-radius (units: \u212b) for short-range contributions to Ewald \u03f5::Float64 : desired level of precision. Typical value is 1e-6, but this does not verbose::Bool : If true will print results Returns eparams::EwaldParams : data structure containing Ewald summation settings corresponding weights indicating the contribution to the Fourier sum. source # PorousMaterials.total_electrostatic_potential_energy Function . total_\u03d5 = total_electrostatic_potential_energy(molecules, eparams, box, eikr) Calculates the total electrostatic potential energy of an array of Molecule s using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this Arguments molecules::Array{Molecule, 1} : The molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings box::Box : The box the energy is being computed in. eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. Returns \u03d5::GGEwaldSum : The total electrostatic potential energy source total_\u03d5 = total_electrostatic_potential_energy(framework, molecules, eparams, eikr) Explanation of total electrostatic potential_energy that uses framework Arguments framework::Framework : Crystal structure (see framework.charges for charges) molecules::Array{Molecule, 1} : The molecules comprising the system. eparams::EwaldParams : data structure containing Ewald summation settings eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation. source","title":"Electrostatics Energy"},{"location":"manual/atomic_interactions/#van-der-waals-energy","text":"# PorousMaterials.lennard_jones Function . energy = lennard_jones(r\u00b2, \u03c3\u00b2, \u03f5) (units: Kelvin) Calculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. \u03c3 and \u03f5 are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of \u03f5 are). Arguments r\u00b2::Float64 : distance between two (pseudo)atoms in question squared (Angstrom\u00b2) \u03c3\u00b2::Float64 : sigma parameter in Lennard Jones potential squared (units: Angstrom\u00b2) \u03f5::Float64 : epsilon parameter in Lennard Jones potential (units: Kelvin) Returns energy::Float64 : Lennard Jones potential energy source # PorousMaterials.vdw_energy Function . energy = vdw_energy(framework, molecule, ljforcefield) Calculates the van der Waals interaction energy between a molecule and a framework. Applies the nearest image convention to find the closest replicate of a specific atom. WARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See replicate . Arguments framework::Framework : Crystal structure molecule::Molecule : adsorbate (includes position/orientation/atoms) ljforcefield::LJForceField : Lennard Jones force field Returns energy::Float64 : Van der Waals interaction energy source gg_energy = vdw_energy(molecule_id, molecules, ljforcefield, simulation_box) Calculates van der Waals interaction energy of a single adsorbate molecules[molecule_id] with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention. Arguments molecule_id::Int : Molecule ID used to determine which molecule in molecules we wish to calculate the guest-guest interactions molecules::Array{Molecule, 1} : An array of Molecule data structures ljforcefield::LJForceField : A Lennard Jones forcefield data structure describing the interactions between different atoms simulation_box::Box : The simulation box for the computation. Returns gg_energy::Float64 : The guest-guest interaction energy of molecules[molecule_id] with the other molecules in molecules source # PorousMaterials.vdw_energy_no_PBC Function . pot_energy = vdw_energy_no_PBC(atoms, molecule, ljff) Assumes unit cell box is a unit cube and no periodic boundary conditions are applied. source","title":"Van der Waals Energy"},{"location":"manual/boxes_crystals_grids/","text":"Loading in Crystal Structure Files # Place .cif and .cssr crystal structure files in PorousMaterials.PATH_TO_CRYSTALS . PorousMaterials.jl currently takes crystals in P1 symmetry only. From here you can start julia and do the following to load a framework and start working with it. using PorousMaterials f = Framework( SBMOF-1.cif ) PorousMaterials will then output information about the framework you just loaded: Name: SBMOF-1.cif Bravais unit cell of a crystal. Unit cell angles \u03b1 = 90.000000 deg. \u03b2 = 100.897000 deg. \u03b3 = 90.000000 deg. Unit cell dimensions a = 11.619300 \u212b. b = 5.566700 \u212b, c = 22.931200 \u212b Volume of unit cell: 1456.472102 \u212b\u00b3 Number of atoms = 120 Number of charges = 0 Chemical formula: Dict(:H= 8,:S= 1,:Ca= 1,:O= 6,:C= 14) Building Blocks of PorousMaterials: Bravais lattice # We later apply periodic boundary conditions to mimic a crystal of infinite extent. A Box describes a Bravais lattice . To make a 10 by 10 by 10 \u212b Bravais lattice with right angles: box = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) box.a, box.b, box.c # unit cell dimensions (10.0 \u212b) box.\u03b1, box.\u03b2, box.\u03b3 # unit cell angles (1.57... radians) box.\u03a9 # volume (1000.0 \u212b\u00b3) box.f_to_c # fractional to Cartesian coordinate transformation matrix box.c_to_f # Cartesian to fractional coordinate transformation matrix box.reciprocal_lattice # rows are reciprocal lattice vectors Replicate a box as follows: box = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2 box.a # 20 \u212b Building Blocks of PorousMaterials: Porous Crystals # using PorousMaterials # read in xtal structure file framework = Framework( SBMOF-1.cif ) # access unit cell box framework.box # access Lennard-Jones spheres and point charges comprising the crystal framework.atoms framework.charges # remove annoying numbers on the atom labels strip_numbers_from_atom_labels!(framework) # compute crystal density \u03c1 = crystal_density(framework) # kg/m3 # compute the chemical formula cf = chemical_formula(framework) # assign charges according to atom type charges = Dict(:Ca = 3.0, :O = 2.0, :C = -1.0, :S = 7.0, :H = -1.0) charged_framework = assign_charges(framework, charges) # replicate visualize framework = replicate(framework, (3, 3, 3)) write_to_xyz(framework, SBMOF-1.xyz ) Demo of Potential Energy Grid # Superimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid. using PorousMaterials framework = Framework( SBMOF-1.cif ) molecule = Molecule( Xe ) forcefield = LJForceField( UFF.csv ) grid = energy_grid(framework, molecule, forcefield, n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure Write to a .cube volume file to visualize the potential energy contours. write_cube(grid, CH4_in_SBMOF1.cube ) Boxes # # PorousMaterials.Box Type . box = Box(a, b, c, \u03b1, \u03b2, \u03b3, volume, f_to_c, c_to_f, reciprocal_lattice) box = Box(a, b, c, \u03b1, \u03b2, \u03b3) box = Box(f_to_c) Data structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates. Attributes a,b,c::Float64 : unit cell dimensions (units: Angstroms) \u03b1,\u03b2,\u03b3::Float64 : unit cell angles (units: radians) \u03a9::Float64 : volume of the unit cell (units: cubic Angtroms) f_to_c::Array{Float64,2} : the 3x3 transformation matrix used to map fractional coordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom c_to_f::Array{Float64,2} : the 3x3 transformation matrix used to map Cartesian coordinates to fractional coordinates. units: inverse Angstrom reciprocal_lattice::Array{Float64, 2} : the rows are the reciprocal lattice vectors. This choice was made (instead of columns) for speed of Ewald Sums. source # PorousMaterials.replicate Function . new_box = replicate(original_box, repfactors) Replicates a Box in positive directions to construct a new Box representing a supercell. The original_box is replicated according to the factors in repfactors . Note replicate(original_box, repfactors=(1, 1, 1)) returns same Box . The new fractional coordinates as described by f_to_c and c_to_f still \u2208 [0, 1]. Arguments original_box::Box : The box that you want to replicate repfactors::Tuple{Int, Int, Int} : The factor you want to replicate the box by Returns box::Box : Fully formed Box object source replicated_frame = replicate(framework, repfactors) Replicates the atoms and charges in a Framework in positive directions to construct a new Framework . Note replicate(framework, (1, 1, 1)) returns the same Framework . Arguments framework::Framework : The framework to replicate repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction. Returns replicated_frame::Framework : Replicated framework source # PorousMaterials.UnitCube Function . unit_cube = UnitCube() This function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles. source # PorousMaterials.write_vtk Function . write_vtk(box, filename; verbose=true, center_at_origin=false) write_vtk(framework) Write a Box to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a Framework is passed, the Box of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension. Appends \".vtk\" extension to filename automatically if not passed. Arguments box::Box : a Bravais lattice filename::AbstractString : filename of the .vtk file output (absolute path) framework::Framework : A framework containing the crystal structure information center_at_origin::Bool : center box at origin if true. if false, the origin is the corner of the box. source # PorousMaterials.inside Function . inside_box = inside(x, box) # true or false Determine whether a Cartesian vector x lays inside a Box . This works by computing the fractional coordinates of vector x and ensuring each lie within the interval [0, 1] . source Crystals # # PorousMaterials.Framework Type . framework = Framework(filename, check_charge_neutrality=true, net_charge_tol=0.001, check_atom_and_charge_overlap=true, remove_overlap=false) framework = Framework(name, box, atoms, charges) Read a crystal structure file (.cif or .cssr) and populate a Framework data structure, or construct a Framework data structure directly. Arguments filename::AbstractString : the name of the crystal structure file (include \".cif\" or \".cssr\") read from PATH_TO_CRYSTALS . check_charge_neutrality::Bool : check for charge neutrality net_charge_tol::Float64 : when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value. check_atom_and_charge_overlap::Bool : throw an error if overlapping atoms are detected. remove_overlap::Bool : remove identical atoms automatically. Identical atoms are the same element atoms which overlap. Returns framework::Framework : A framework containing the crystal structure information Attributes name::AbstractString : name of crystal structure box::Box : unit cell (Bravais Lattice) atoms::Atoms : list of Atoms in crystal unit cell charges::Charges : list of point charges in crystal unit cell source # PorousMaterials.remove_overlapping_atoms_and_charges Function . new_framework = remove_overlapping_atoms_and_charges(framework, overlap_tol=0.1, verbose=true) Takes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical. Arguments framework::Framework : The framework containing the crystal structure information atom_overlap_tol::Float64 : The minimum distance between two atoms that is tolerated charge_overlap_tol::Float64 : The minimum distance between two charges that is tolerated Returns new_framework::Framework : A new framework where identical atoms have been removed. source # PorousMaterials.strip_numbers_from_atom_labels! Function . strip_numbers_from_atom_labels!(framework) Strip numbers from labels for framework.atoms . Precisely, for atom in framework.atoms , find the first number that appears in atom . Remove this number and all following characters from atom . e.g. C12 \u2013 C Ba12A_3 \u2013 Ba Arguments framework::Framework : The framework containing the crystal structure information source # PorousMaterials.chemical_formula Function . formula = chemical_formula(framework, verbose=false) Find the irreducible chemical formula of a crystal structure. Arguments framework::Framework : The framework containing the crystal structure information verbose::Bool : If true , will print the chemical formula as well Returns formula::Dict{Symbol, Int} : A dictionary with the irreducible chemical formula of a crystal structure source # PorousMaterials.molecular_weight Function . mass_of_framework = molecular_weight(framework) Calculates the molecular weight of a unit cell of the framework in amu using information stored in data/atomicmasses.csv . Arguments framework::Framework : The framework containing the crystal structure information Returns mass_of_framework::Float64 : The molecular weight of a unit cell of the framework in amu source # PorousMaterials.crystal_density Function . \u03c1 = crystal_density(framework) # kg/m\u00b2 Compute the crystal density of a framework. Pulls atomic masses from read_atomic_masses . Arguments framework::Framework : The framework containing the crystal structure information Returns \u03c1::Float64 : The crystal density of a framework in kg/m\u00b3 source # PorousMaterials.replicate Method . replicated_frame = replicate(framework, repfactors) Replicates the atoms and charges in a Framework in positive directions to construct a new Framework . Note replicate(framework, (1, 1, 1)) returns the same Framework . Arguments framework::Framework : The framework to replicate repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction. Returns replicated_frame::Framework : Replicated framework source # PorousMaterials.charged Method . charged_flag = charged(framework, verbose=false) # true or false Determine if a framework has point charges source # PorousMaterials.write_cif Function . write_cif(framework, filename) Write a framework::Framework to a .cif file with filename::AbstractString . If filename does not include the .cif extension, it will automatically be added. source # PorousMaterials.assign_charges Function . new_framework = assign_charges(framework, charges, net_charge_tol=1e-5) Assign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of framework.atoms . If the framework already has charges, the charges are removed and new charges are added accordingly so that framework.atoms.n_atoms == framework.charges.n_charges . Examples charges = Dict(:Ca = 2.0, :C = 1.0, :H = -1.0) new_framework = assign_charges(framework, charges) charges = [4.0, 2.0, -6.0] # framework.atoms is length 3 new_framework = assign_charges(framework, charges) Arguments framework::Framework : the framework to which we should add charges (not modified in this function) charges::Union{Dict{Symbol, Float64}, Array{Float64, 1}} : a dictionary that returns the charge assigned to the species of atom or an array of charges to assign, with order consistent with the order in framework.atoms (units: electrons). net_charge_tol::Float64 : the net charge tolerated when asserting charge neutrality of the resulting framework Returns new_framework::Framework : a new framework identical to the one passed except charges are assigned. source Grids # # PorousMaterials.Grid Type . Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box ( Box ). Each grid point has data, data , associated with it, of type T , stored in a 3D array. Attributes box::Box : describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included. n_pts::Tuple{Int, Int, Int} : number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included. data::Array{T, 3} : three dimensional array conaining data associated with each grid point. units::Symbol : the units associated with each data point. origin::Array{Float64, 1} : the origin of the grid. source # PorousMaterials.xf_to_id Function . voxel_id = xf_to_id(n_pts, xf) Returns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of n_pts[1] by n_pts[2] by n_pts[3] voxels. Periodic boundary conditions are applied. Arguments n_pts::Tuple{Int, Int, Int} : The number of points for each axis in the Grid xf::Array{Float64, 1} : The fractional coordinates to be converted to an id Returns id::Array{Int, 1} : The array indices for storing this point in space source # PorousMaterials.update_density! Function . update_density!(grid, molecule, species) updates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a ./ = num_snapshots at the end of the GCMC simulation. Arguments grid::Grid : the grid to be updated molecules::Array{Molecule, 1} : An array of molecules whose positions will be added to the grid species::Symbol : The species of atom that can be added to this density grid source # PorousMaterials.apply_periodic_boundary_condition! Function . apply_periodic_boundary_condition!(molecule) Check if the center_of_mass of a Molecule is outside of a Box . If so, apply periodic boundary conditions and translate the center of mass of the Molecule (and its atoms and point charges) so that it is inside of the Box . Arguments molecule::Molecule : A molecule we're interested in seeing if its' center of mass falls within simulation_box source # PorousMaterials.write_cube Function . write_cube(grid, filename, verbose=true) Write grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms. Arguments grid::Grid : grid with associated data at each grid point. filename::AbstractString : name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS . verbose::Bool : print name of file after writing. source # PorousMaterials.read_cube Function . grid = read_cube(filename) Read a .cube file and return a populated Grid data structure. Arguments filename::AbstractString : name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS Returns grid::Grid : A grid data structure source # PorousMaterials.energy_grid Function . grid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750) Superimposes a regular grid of points (regularly spaced in fractional coordinates of the framework.box ) over the unit cell of a crystal, with n_gridpts dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations. The ensemble average is a Boltzmann average over rotations: - R T log \u27e8e\u207b\u1d47\u1d41\u27e9 Arguments framework::Framework : crystal in which we seek to compute an energy grid for a molecule. grid.box will be framework.box . molecule::Molecule : molecule for which we seek an energy grid ljforcefield::LJForceField : molecular model for computing molecule-framework interactions n_pts::Tuple{Int, Int, Int}=(50,50,50) : number of grid points in each fractional coordinate dimension, including endpoints (0, 1) n_rotations::Int : number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point. This is only relevant for molecules that are comprised of more than one Lennard Jones sphere. temperature::Float64 : the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point. units::Symbol : either :K or :kJ_mol , the units in which the energy should be stored in the returned Grid . center::Bool : shift coords of grid so that the origin is the center of the unit cell framework.box . verbose::Bool=true : print some information. Returns grid::Grid : A grid data structure containing the potential energy of the system source","title":"Boxes, Crystals, and Grids"},{"location":"manual/boxes_crystals_grids/#loading-in-crystal-structure-files","text":"Place .cif and .cssr crystal structure files in PorousMaterials.PATH_TO_CRYSTALS . PorousMaterials.jl currently takes crystals in P1 symmetry only. From here you can start julia and do the following to load a framework and start working with it. using PorousMaterials f = Framework( SBMOF-1.cif ) PorousMaterials will then output information about the framework you just loaded: Name: SBMOF-1.cif Bravais unit cell of a crystal. Unit cell angles \u03b1 = 90.000000 deg. \u03b2 = 100.897000 deg. \u03b3 = 90.000000 deg. Unit cell dimensions a = 11.619300 \u212b. b = 5.566700 \u212b, c = 22.931200 \u212b Volume of unit cell: 1456.472102 \u212b\u00b3 Number of atoms = 120 Number of charges = 0 Chemical formula: Dict(:H= 8,:S= 1,:Ca= 1,:O= 6,:C= 14)","title":"Loading in Crystal Structure Files"},{"location":"manual/boxes_crystals_grids/#building-blocks-of-porousmaterials-bravais-lattice","text":"We later apply periodic boundary conditions to mimic a crystal of infinite extent. A Box describes a Bravais lattice . To make a 10 by 10 by 10 \u212b Bravais lattice with right angles: box = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) box.a, box.b, box.c # unit cell dimensions (10.0 \u212b) box.\u03b1, box.\u03b2, box.\u03b3 # unit cell angles (1.57... radians) box.\u03a9 # volume (1000.0 \u212b\u00b3) box.f_to_c # fractional to Cartesian coordinate transformation matrix box.c_to_f # Cartesian to fractional coordinate transformation matrix box.reciprocal_lattice # rows are reciprocal lattice vectors Replicate a box as follows: box = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2 box.a # 20 \u212b","title":"Building Blocks of PorousMaterials: Bravais lattice"},{"location":"manual/boxes_crystals_grids/#building-blocks-of-porousmaterials-porous-crystals","text":"using PorousMaterials # read in xtal structure file framework = Framework( SBMOF-1.cif ) # access unit cell box framework.box # access Lennard-Jones spheres and point charges comprising the crystal framework.atoms framework.charges # remove annoying numbers on the atom labels strip_numbers_from_atom_labels!(framework) # compute crystal density \u03c1 = crystal_density(framework) # kg/m3 # compute the chemical formula cf = chemical_formula(framework) # assign charges according to atom type charges = Dict(:Ca = 3.0, :O = 2.0, :C = -1.0, :S = 7.0, :H = -1.0) charged_framework = assign_charges(framework, charges) # replicate visualize framework = replicate(framework, (3, 3, 3)) write_to_xyz(framework, SBMOF-1.xyz )","title":"Building Blocks of PorousMaterials: Porous Crystals"},{"location":"manual/boxes_crystals_grids/#demo-of-potential-energy-grid","text":"Superimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid. using PorousMaterials framework = Framework( SBMOF-1.cif ) molecule = Molecule( Xe ) forcefield = LJForceField( UFF.csv ) grid = energy_grid(framework, molecule, forcefield, n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure Write to a .cube volume file to visualize the potential energy contours. write_cube(grid, CH4_in_SBMOF1.cube )","title":"Demo of Potential Energy Grid"},{"location":"manual/boxes_crystals_grids/#boxes","text":"# PorousMaterials.Box Type . box = Box(a, b, c, \u03b1, \u03b2, \u03b3, volume, f_to_c, c_to_f, reciprocal_lattice) box = Box(a, b, c, \u03b1, \u03b2, \u03b3) box = Box(f_to_c) Data structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates. Attributes a,b,c::Float64 : unit cell dimensions (units: Angstroms) \u03b1,\u03b2,\u03b3::Float64 : unit cell angles (units: radians) \u03a9::Float64 : volume of the unit cell (units: cubic Angtroms) f_to_c::Array{Float64,2} : the 3x3 transformation matrix used to map fractional coordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom c_to_f::Array{Float64,2} : the 3x3 transformation matrix used to map Cartesian coordinates to fractional coordinates. units: inverse Angstrom reciprocal_lattice::Array{Float64, 2} : the rows are the reciprocal lattice vectors. This choice was made (instead of columns) for speed of Ewald Sums. source # PorousMaterials.replicate Function . new_box = replicate(original_box, repfactors) Replicates a Box in positive directions to construct a new Box representing a supercell. The original_box is replicated according to the factors in repfactors . Note replicate(original_box, repfactors=(1, 1, 1)) returns same Box . The new fractional coordinates as described by f_to_c and c_to_f still \u2208 [0, 1]. Arguments original_box::Box : The box that you want to replicate repfactors::Tuple{Int, Int, Int} : The factor you want to replicate the box by Returns box::Box : Fully formed Box object source replicated_frame = replicate(framework, repfactors) Replicates the atoms and charges in a Framework in positive directions to construct a new Framework . Note replicate(framework, (1, 1, 1)) returns the same Framework . Arguments framework::Framework : The framework to replicate repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction. Returns replicated_frame::Framework : Replicated framework source # PorousMaterials.UnitCube Function . unit_cube = UnitCube() This function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles. source # PorousMaterials.write_vtk Function . write_vtk(box, filename; verbose=true, center_at_origin=false) write_vtk(framework) Write a Box to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a Framework is passed, the Box of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension. Appends \".vtk\" extension to filename automatically if not passed. Arguments box::Box : a Bravais lattice filename::AbstractString : filename of the .vtk file output (absolute path) framework::Framework : A framework containing the crystal structure information center_at_origin::Bool : center box at origin if true. if false, the origin is the corner of the box. source # PorousMaterials.inside Function . inside_box = inside(x, box) # true or false Determine whether a Cartesian vector x lays inside a Box . This works by computing the fractional coordinates of vector x and ensuring each lie within the interval [0, 1] . source","title":"Boxes"},{"location":"manual/boxes_crystals_grids/#crystals","text":"# PorousMaterials.Framework Type . framework = Framework(filename, check_charge_neutrality=true, net_charge_tol=0.001, check_atom_and_charge_overlap=true, remove_overlap=false) framework = Framework(name, box, atoms, charges) Read a crystal structure file (.cif or .cssr) and populate a Framework data structure, or construct a Framework data structure directly. Arguments filename::AbstractString : the name of the crystal structure file (include \".cif\" or \".cssr\") read from PATH_TO_CRYSTALS . check_charge_neutrality::Bool : check for charge neutrality net_charge_tol::Float64 : when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value. check_atom_and_charge_overlap::Bool : throw an error if overlapping atoms are detected. remove_overlap::Bool : remove identical atoms automatically. Identical atoms are the same element atoms which overlap. Returns framework::Framework : A framework containing the crystal structure information Attributes name::AbstractString : name of crystal structure box::Box : unit cell (Bravais Lattice) atoms::Atoms : list of Atoms in crystal unit cell charges::Charges : list of point charges in crystal unit cell source # PorousMaterials.remove_overlapping_atoms_and_charges Function . new_framework = remove_overlapping_atoms_and_charges(framework, overlap_tol=0.1, verbose=true) Takes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical. Arguments framework::Framework : The framework containing the crystal structure information atom_overlap_tol::Float64 : The minimum distance between two atoms that is tolerated charge_overlap_tol::Float64 : The minimum distance between two charges that is tolerated Returns new_framework::Framework : A new framework where identical atoms have been removed. source # PorousMaterials.strip_numbers_from_atom_labels! Function . strip_numbers_from_atom_labels!(framework) Strip numbers from labels for framework.atoms . Precisely, for atom in framework.atoms , find the first number that appears in atom . Remove this number and all following characters from atom . e.g. C12 \u2013 C Ba12A_3 \u2013 Ba Arguments framework::Framework : The framework containing the crystal structure information source # PorousMaterials.chemical_formula Function . formula = chemical_formula(framework, verbose=false) Find the irreducible chemical formula of a crystal structure. Arguments framework::Framework : The framework containing the crystal structure information verbose::Bool : If true , will print the chemical formula as well Returns formula::Dict{Symbol, Int} : A dictionary with the irreducible chemical formula of a crystal structure source # PorousMaterials.molecular_weight Function . mass_of_framework = molecular_weight(framework) Calculates the molecular weight of a unit cell of the framework in amu using information stored in data/atomicmasses.csv . Arguments framework::Framework : The framework containing the crystal structure information Returns mass_of_framework::Float64 : The molecular weight of a unit cell of the framework in amu source # PorousMaterials.crystal_density Function . \u03c1 = crystal_density(framework) # kg/m\u00b2 Compute the crystal density of a framework. Pulls atomic masses from read_atomic_masses . Arguments framework::Framework : The framework containing the crystal structure information Returns \u03c1::Float64 : The crystal density of a framework in kg/m\u00b3 source # PorousMaterials.replicate Method . replicated_frame = replicate(framework, repfactors) Replicates the atoms and charges in a Framework in positive directions to construct a new Framework . Note replicate(framework, (1, 1, 1)) returns the same Framework . Arguments framework::Framework : The framework to replicate repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction. Returns replicated_frame::Framework : Replicated framework source # PorousMaterials.charged Method . charged_flag = charged(framework, verbose=false) # true or false Determine if a framework has point charges source # PorousMaterials.write_cif Function . write_cif(framework, filename) Write a framework::Framework to a .cif file with filename::AbstractString . If filename does not include the .cif extension, it will automatically be added. source # PorousMaterials.assign_charges Function . new_framework = assign_charges(framework, charges, net_charge_tol=1e-5) Assign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of framework.atoms . If the framework already has charges, the charges are removed and new charges are added accordingly so that framework.atoms.n_atoms == framework.charges.n_charges . Examples charges = Dict(:Ca = 2.0, :C = 1.0, :H = -1.0) new_framework = assign_charges(framework, charges) charges = [4.0, 2.0, -6.0] # framework.atoms is length 3 new_framework = assign_charges(framework, charges) Arguments framework::Framework : the framework to which we should add charges (not modified in this function) charges::Union{Dict{Symbol, Float64}, Array{Float64, 1}} : a dictionary that returns the charge assigned to the species of atom or an array of charges to assign, with order consistent with the order in framework.atoms (units: electrons). net_charge_tol::Float64 : the net charge tolerated when asserting charge neutrality of the resulting framework Returns new_framework::Framework : a new framework identical to the one passed except charges are assigned. source","title":"Crystals"},{"location":"manual/boxes_crystals_grids/#grids","text":"# PorousMaterials.Grid Type . Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box ( Box ). Each grid point has data, data , associated with it, of type T , stored in a 3D array. Attributes box::Box : describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included. n_pts::Tuple{Int, Int, Int} : number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included. data::Array{T, 3} : three dimensional array conaining data associated with each grid point. units::Symbol : the units associated with each data point. origin::Array{Float64, 1} : the origin of the grid. source # PorousMaterials.xf_to_id Function . voxel_id = xf_to_id(n_pts, xf) Returns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of n_pts[1] by n_pts[2] by n_pts[3] voxels. Periodic boundary conditions are applied. Arguments n_pts::Tuple{Int, Int, Int} : The number of points for each axis in the Grid xf::Array{Float64, 1} : The fractional coordinates to be converted to an id Returns id::Array{Int, 1} : The array indices for storing this point in space source # PorousMaterials.update_density! Function . update_density!(grid, molecule, species) updates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a ./ = num_snapshots at the end of the GCMC simulation. Arguments grid::Grid : the grid to be updated molecules::Array{Molecule, 1} : An array of molecules whose positions will be added to the grid species::Symbol : The species of atom that can be added to this density grid source # PorousMaterials.apply_periodic_boundary_condition! Function . apply_periodic_boundary_condition!(molecule) Check if the center_of_mass of a Molecule is outside of a Box . If so, apply periodic boundary conditions and translate the center of mass of the Molecule (and its atoms and point charges) so that it is inside of the Box . Arguments molecule::Molecule : A molecule we're interested in seeing if its' center of mass falls within simulation_box source # PorousMaterials.write_cube Function . write_cube(grid, filename, verbose=true) Write grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms. Arguments grid::Grid : grid with associated data at each grid point. filename::AbstractString : name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS . verbose::Bool : print name of file after writing. source # PorousMaterials.read_cube Function . grid = read_cube(filename) Read a .cube file and return a populated Grid data structure. Arguments filename::AbstractString : name of .cube file to which we write the grid; this is relative to PATH_TO_GRIDS Returns grid::Grid : A grid data structure source # PorousMaterials.energy_grid Function . grid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750) Superimposes a regular grid of points (regularly spaced in fractional coordinates of the framework.box ) over the unit cell of a crystal, with n_gridpts dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations. The ensemble average is a Boltzmann average over rotations: - R T log \u27e8e\u207b\u1d47\u1d41\u27e9 Arguments framework::Framework : crystal in which we seek to compute an energy grid for a molecule. grid.box will be framework.box . molecule::Molecule : molecule for which we seek an energy grid ljforcefield::LJForceField : molecular model for computing molecule-framework interactions n_pts::Tuple{Int, Int, Int}=(50,50,50) : number of grid points in each fractional coordinate dimension, including endpoints (0, 1) n_rotations::Int : number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point. This is only relevant for molecules that are comprised of more than one Lennard Jones sphere. temperature::Float64 : the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point. units::Symbol : either :K or :kJ_mol , the units in which the energy should be stored in the returned Grid . center::Bool : shift coords of grid so that the origin is the center of the unit cell framework.box . verbose::Bool=true : print some information. Returns grid::Grid : A grid data structure containing the potential energy of the system source","title":"Grids"},{"location":"manual/matter/","text":"Matter is the foundation for every data type defined in PorousMaterials. Two structs are used to define all atomic structures: Atoms and Charges . Every atom, molecule, or crystal structure can be simulated by understanding its atoms and its point charges. We chose to store each collection as a single object (Atoms) rather than an array of objects (Array{Atom}) because it allows us to store the locations in contiguous memory. We found significant speed increases when storing each collection as a single object. One array of locations also allowed us to take advantage of broadcasting. For example, it is useful when calculating the energy inside a framework. Instead of looping through every atom, we can instead run this line: dxf = broadcast(-, framework.atoms.xf, molecule.atoms.xf[i]) This calculates the distance between one atom in a molecule and every atom in the framework. Building Blocks of PorousMaterials: Matter # In PorousMaterials.jl , crystals and molecules are composed of Atoms and Charges To create a carbon atom at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice): xf = Array{Float64, 2}(undef, 3, 0) xf = [xf [0.1, 0.2, 0.5]] atoms = Atoms([:C], xf) # constructor atoms.species[1] # :C atoms.xf[:, 1] # [0.1, 0.2, 0.5] To create a point charge of +1 at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice): xf = Array{Float64, 2}(undef, 3, 0) xf = [xf [0.1, 0.2, 0.5]] charges = Charges([1.0], xf) charges.q[1] # 1.0 charges.xf[:, 1] # [0.1, 0.2, 0.5] Matter # # PorousMaterials.Atoms Type . Data structure holds a set of atom species and their positions in fractional coordinates. Fractional coords of atom i is charges.xf[:, i] . Example use atoms = Atoms(2, [:C, :F], [0.0 1.0; 2.0 3.0; 4.0 5.0]) Attributes n_atoms::Int : number of atoms species::Array{Symbol, 1} : atom species xf::Array{Float64, 2} : fractional coordinates in the columns source # PorousMaterials.Charges Type . Data structure holds a set of point charges and their positions in fractional coordinates. Fractional coords of charge i is charges.xf[:, i] . Example use charges = Charges(2, [-1.0, 1.0], [0.0 1.0; 2.0 3.0; 4.0 5.0]) Attributes n_charges::Int : number of charges q::Array{Float64, 1} : signed magnitude of charges (units: electrons) xf::Array{Float64, 2} : fractional coordinates in the columns source","title":"Matter"},{"location":"manual/matter/#building-blocks-of-porousmaterials-matter","text":"In PorousMaterials.jl , crystals and molecules are composed of Atoms and Charges To create a carbon atom at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice): xf = Array{Float64, 2}(undef, 3, 0) xf = [xf [0.1, 0.2, 0.5]] atoms = Atoms([:C], xf) # constructor atoms.species[1] # :C atoms.xf[:, 1] # [0.1, 0.2, 0.5] To create a point charge of +1 at [0.1, 0.2, 0.5] fractional coordinates (in the context of some Bravais lattice): xf = Array{Float64, 2}(undef, 3, 0) xf = [xf [0.1, 0.2, 0.5]] charges = Charges([1.0], xf) charges.q[1] # 1.0 charges.xf[:, 1] # [0.1, 0.2, 0.5]","title":"Building Blocks of PorousMaterials: Matter"},{"location":"manual/matter/#matter","text":"# PorousMaterials.Atoms Type . Data structure holds a set of atom species and their positions in fractional coordinates. Fractional coords of atom i is charges.xf[:, i] . Example use atoms = Atoms(2, [:C, :F], [0.0 1.0; 2.0 3.0; 4.0 5.0]) Attributes n_atoms::Int : number of atoms species::Array{Symbol, 1} : atom species xf::Array{Float64, 2} : fractional coordinates in the columns source # PorousMaterials.Charges Type . Data structure holds a set of point charges and their positions in fractional coordinates. Fractional coords of charge i is charges.xf[:, i] . Example use charges = Charges(2, [-1.0, 1.0], [0.0 1.0; 2.0 3.0; 4.0 5.0]) Attributes n_charges::Int : number of charges q::Array{Float64, 1} : signed magnitude of charges (units: electrons) xf::Array{Float64, 2} : fractional coordinates in the columns source","title":"Matter"},{"location":"manual/mof_simulations/","text":"Demo of Henry coefficients Calculation # Compute the Henry coefficient of CO 2 in CAXVII_clean (Fe 2 (dobdc)) at 298 K using the Dreiding force field: using PorousMaterials # read in xtal structure file and populate a Framework data structure framework = Framework( CAXVII_clean.cif ) # read in Lennard-Jones force field parameters and populate a LJForceField data structure forcefield = LJForceField( Dreiding.csv , cutoffradius=12.5) # read in a molecule format file and populate a Molecule data structure molecule = Molecule( CO2 ) temperature = 298.0 # K # conduct Widom insertions and compute Henry coefficient, heat of adsorption results = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200) # ... prints stuff # results automatically saved to .jld load later in one line of code # returns dictionary for easy querying results[ Qst (kJ/mol) ] # -21.0 results[ henry coefficient [mol/(kg-Pa)] ] # 2.88e-05 The simulation is parallelized across a maximum of 5 cores. Demo of Grand-canonical Monte Carlo Simulations # Simulate the adsorption of CO 2 in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field: using PorousMaterials # read in xtal structure file and populate a Framework data structure framework = Framework( FIQCEN_clean_min_charges.cif ) # remove annoying numbers from atom labels strip_numbers_from_atom_labels!(framework) # read in Lennard-Jones force field parameters and populate a LJForceField data structure forcefield = LJForceField( UFF.csv , cutoffradius=12.8) # read in a molecule format file and populate a Molecule data structure molecule = Molecule( CO2 ) temperature = 298.0 # K pressure = 1.0 # bar # conduct grand-canonical Monte Carlo simulation results, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield, n_burn_cycles=5000, n_sample_cycles=5000) # ... prints stuff # results automatically saved to .jld load later in one line of code # returns dictionary for easy querying results[ \u27e8N\u27e9 (molecules/unit cell) ] results[ Q_st (K) ] Or, compute the entire adsorption isotherm at once, parallelized across many cores: pressures = [0.2, 0.6, 0.8, 1.0] # bar # loop over all pressures and compute entire adsorption isotherm in parallel results = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield, n_burn_cycles=5000, n_sample_cycles=5000) Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles: # loop over all pressures and run GCMC simulations in series. # load in the configurations of the molecules from the previous pressure. results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield, n_burn_cycles=1000, n_sample_cycles=5000) Henry Coefficient Calculations # # PorousMaterials.henry_coefficient Function . result = henry_coefficient(framework, molecule, temperature, ljforcefield, nb_insertions=1e6, verbose=true, ewald_precision=1e-6, autosave=true) Conduct particle insertions to compute the Henry coefficient K\u2095 of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): \u27e8N\u27e9 = K\u2095 P, where P is pressure and K\u2095 is the Henry coefficient. K\u2095 = \u03b2 \u27e8e^{-\u03b2 U}\u27e9, where the average is over positions and orientations of the molecule in the framework. Arguments framework::Framework : the porous crystal in which we seek to simulate adsorption molecule::Molecule : the adsorbate molecule temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: Kelvin (K) ljforcefield::LJForceField : the molecular model used to describe the energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions. insertions_per_volume::Int : number of Widom insertions to perform for computing the average, per unit cell volume (\u212b\u00b3) verbose::Bool : whether or not to print off information during the simulation. ewald_precision::Float64 : desired precision for Ewald summations; used to determine the replication factors in reciprocal space. autosave::Bool : save results file as a .jld in PATH TO DATA * sims filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file. write_checkpoint::Bool : Will periodically save checkpoints to start the job from a previous state. load_checkpoint::Bool : Instructs the program to look for a checkpoint file in data/henry_checkpoints and start the simulation from that point. checkpoint_frequency::Int : The frequency at which we will save a checkpoint file. Is only used if write_checkpoint=true Returns result::Dict{String, Float64} : A dictionary containing all the results from the Henry coefficient simulation source # PorousMaterials.henry_result_savename Function . save_name = henry_result_savename(framework, molecule, temperature, ljforcefield, insertions_per_volume; comment= ) Determine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds. Arguments framework::Framework : The porous crystal being tested molecule::Molecule : The molecule being tested inside the crystal temperature::Float64 : The temperature used in the simulation units: Kelvin (K) ljforcefield::LJForceField : The molecular model being used in the simulation to describe the intermolecular Van der Waals forces insertions_per_volume::Union{Int, Float64} : The number of widom insertions per unit volume. Will be scaled according to the framework we're working with comment::AbstractString : An optional comment that will be appended to the filename source Grand-Canonical Monte Carlo Simulations # # PorousMaterials.gcmc_simulation Function . results, molecules = gcmc_simulation(framework, molecule, temperature, pressure, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=false, molecules=Molecule[], eos=:ideal, ewald_precision=1e-6, load_checkpoint_file=false, show_progress_bar=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=100, filename_comment= ) Runs a grand-canonical (\u03bcVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field. A cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation. Arguments framework::Framework : the porous crystal in which we seek to simulate adsorption molecule::Molecule : a template of the adsorbate molecule of which we seek to simulate temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: Kelvin (K) pressure::Float64 : pressure of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: bar the adsorption ljforcefield::LJForceField : the molecular model used to describe the energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions. n_burn_cycles::Int : number of cycles to allow the system to reach equilibrium before sampling. n_sample_cycles::Int : number of cycles used for sampling sample_frequency::Int : during the sampling cycles, sample e.g. the number of adsorbed gas molecules every this number of Markov proposals. verbose::Bool : whether or not to print off information during the simulation. molecules::Array{Molecule, 1} : a starting configuration of molecules in the framework. Note that we assume these coordinates are Cartesian, i.e. corresponding to a unit box. ewald_precision::Float64 : The desired precision for the long range Ewald summation eos::Symbol : equation of state to use for calculation of fugacity from pressure. Default is ideal gas, where fugacity = pressure. load_checkpoint_file::Bool : Will find a checkpoint file corresponding to the gcmc_result_savename if true. If that file is not found, function will throw an error. checkpoint::Dict : A checkpoint dictionary that will work as a starting configuration for the run. The dictionary has to have the following keys: outer_cycle , molecules , system_energy , current_block , gcmc_stats , markov_counts , markov_chain_time and time . If this argument is used, keep load_checkpoint_file=false . write_checkpoints::Bool : Will save checkpoints in data/gcmc_checkpoints if this is true. checkpoint_frequency::Int : Will save checkpoint files every checkpoint_frequency cycles. write_adsorbate_snapshots::Bool : Whether the simulation will create and save a snapshot file snapshot_frequency::Int : The number of cycles taken between each snapshot (after burn cycle completion) calculate_density_grid::Bool : Whether the simulation will keep track of a density grid for adsorbates density_grid_dx::Float64 : The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by required_n_pts . density_grid_species::Symbol : The atomic species within the molecule for which we will compute the density grid. filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file (if autosaved) source # PorousMaterials.adsorption_isotherm Function . results = adsorption_isotherm(framework, molecule, temperature, pressures, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=true, ewald_precision=1e-6, eos=:ideal, load_checkpoint_file=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=50, filename_comment= , show_progress_bar=false) Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in parallel. Arguments are the same as gcmc_simulation , as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as julia -p 4 mysim.jl to allocate e.g. four cores. See Parallel Computing . source # PorousMaterials.stepwise_adsorption_isotherm Function . results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=true, ewald_precision=1e-6, eos=:ideal, load_checkpoint_file=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=50, filename_comment= , show_progress_bar=false) Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in series. Arguments are the same as gcmc_simulation , as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of pressures is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see adsorption_isotherm which runs the \u03bcVT simulation at each pressure in parallel. source # PorousMaterials.gcmc_result_savename Function . file_save_name = gcmc_result_savename(framework_name, molecule_species, ljforcefield_name, temperature, pressure, n_burn_cycles, n_sample_cycles; comment= , extension= ) Determine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds. Arguments framework_name::AbstractString : The porous crystal being tested molecule_species::Symbol : The molecule being tested inside the porous crystal ljforcefield_name::AbstractString : The molecular model being used in this simulation to describe intermolecular Van der Waals interactions temperature::Float64 : The temperature used in the simulation units: Kelvin (K) pressure::Float64 : The pressure used in the simulation units: bar n_burn_cycles::Int : The number of burn cycles used in this simulation n_sample_cycles::Int : The number of sample cycles used in this simulation comment::AbstractString : An optional comment that will be appended to the end of the filename extension::AbstractString : The extension for the file being created source","title":"Molecular Simulations"},{"location":"manual/mof_simulations/#demo-of-henry-coefficients-calculation","text":"Compute the Henry coefficient of CO 2 in CAXVII_clean (Fe 2 (dobdc)) at 298 K using the Dreiding force field: using PorousMaterials # read in xtal structure file and populate a Framework data structure framework = Framework( CAXVII_clean.cif ) # read in Lennard-Jones force field parameters and populate a LJForceField data structure forcefield = LJForceField( Dreiding.csv , cutoffradius=12.5) # read in a molecule format file and populate a Molecule data structure molecule = Molecule( CO2 ) temperature = 298.0 # K # conduct Widom insertions and compute Henry coefficient, heat of adsorption results = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200) # ... prints stuff # results automatically saved to .jld load later in one line of code # returns dictionary for easy querying results[ Qst (kJ/mol) ] # -21.0 results[ henry coefficient [mol/(kg-Pa)] ] # 2.88e-05 The simulation is parallelized across a maximum of 5 cores.","title":"Demo of Henry coefficients Calculation"},{"location":"manual/mof_simulations/#demo-of-grand-canonical-monte-carlo-simulations","text":"Simulate the adsorption of CO 2 in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field: using PorousMaterials # read in xtal structure file and populate a Framework data structure framework = Framework( FIQCEN_clean_min_charges.cif ) # remove annoying numbers from atom labels strip_numbers_from_atom_labels!(framework) # read in Lennard-Jones force field parameters and populate a LJForceField data structure forcefield = LJForceField( UFF.csv , cutoffradius=12.8) # read in a molecule format file and populate a Molecule data structure molecule = Molecule( CO2 ) temperature = 298.0 # K pressure = 1.0 # bar # conduct grand-canonical Monte Carlo simulation results, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield, n_burn_cycles=5000, n_sample_cycles=5000) # ... prints stuff # results automatically saved to .jld load later in one line of code # returns dictionary for easy querying results[ \u27e8N\u27e9 (molecules/unit cell) ] results[ Q_st (K) ] Or, compute the entire adsorption isotherm at once, parallelized across many cores: pressures = [0.2, 0.6, 0.8, 1.0] # bar # loop over all pressures and compute entire adsorption isotherm in parallel results = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield, n_burn_cycles=5000, n_sample_cycles=5000) Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles: # loop over all pressures and run GCMC simulations in series. # load in the configurations of the molecules from the previous pressure. results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield, n_burn_cycles=1000, n_sample_cycles=5000)","title":"Demo of Grand-canonical Monte Carlo Simulations"},{"location":"manual/mof_simulations/#henry-coefficient-calculations","text":"# PorousMaterials.henry_coefficient Function . result = henry_coefficient(framework, molecule, temperature, ljforcefield, nb_insertions=1e6, verbose=true, ewald_precision=1e-6, autosave=true) Conduct particle insertions to compute the Henry coefficient K\u2095 of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): \u27e8N\u27e9 = K\u2095 P, where P is pressure and K\u2095 is the Henry coefficient. K\u2095 = \u03b2 \u27e8e^{-\u03b2 U}\u27e9, where the average is over positions and orientations of the molecule in the framework. Arguments framework::Framework : the porous crystal in which we seek to simulate adsorption molecule::Molecule : the adsorbate molecule temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: Kelvin (K) ljforcefield::LJForceField : the molecular model used to describe the energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions. insertions_per_volume::Int : number of Widom insertions to perform for computing the average, per unit cell volume (\u212b\u00b3) verbose::Bool : whether or not to print off information during the simulation. ewald_precision::Float64 : desired precision for Ewald summations; used to determine the replication factors in reciprocal space. autosave::Bool : save results file as a .jld in PATH TO DATA * sims filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file. write_checkpoint::Bool : Will periodically save checkpoints to start the job from a previous state. load_checkpoint::Bool : Instructs the program to look for a checkpoint file in data/henry_checkpoints and start the simulation from that point. checkpoint_frequency::Int : The frequency at which we will save a checkpoint file. Is only used if write_checkpoint=true Returns result::Dict{String, Float64} : A dictionary containing all the results from the Henry coefficient simulation source # PorousMaterials.henry_result_savename Function . save_name = henry_result_savename(framework, molecule, temperature, ljforcefield, insertions_per_volume; comment= ) Determine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds. Arguments framework::Framework : The porous crystal being tested molecule::Molecule : The molecule being tested inside the crystal temperature::Float64 : The temperature used in the simulation units: Kelvin (K) ljforcefield::LJForceField : The molecular model being used in the simulation to describe the intermolecular Van der Waals forces insertions_per_volume::Union{Int, Float64} : The number of widom insertions per unit volume. Will be scaled according to the framework we're working with comment::AbstractString : An optional comment that will be appended to the filename source","title":"Henry Coefficient Calculations"},{"location":"manual/mof_simulations/#grand-canonical-monte-carlo-simulations","text":"# PorousMaterials.gcmc_simulation Function . results, molecules = gcmc_simulation(framework, molecule, temperature, pressure, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=false, molecules=Molecule[], eos=:ideal, ewald_precision=1e-6, load_checkpoint_file=false, show_progress_bar=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=100, filename_comment= ) Runs a grand-canonical (\u03bcVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field. A cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation. Arguments framework::Framework : the porous crystal in which we seek to simulate adsorption molecule::Molecule : a template of the adsorbate molecule of which we seek to simulate temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: Kelvin (K) pressure::Float64 : pressure of bulk gas phase in equilibrium with adsorbed phase in the porous material. units: bar the adsorption ljforcefield::LJForceField : the molecular model used to describe the energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions. n_burn_cycles::Int : number of cycles to allow the system to reach equilibrium before sampling. n_sample_cycles::Int : number of cycles used for sampling sample_frequency::Int : during the sampling cycles, sample e.g. the number of adsorbed gas molecules every this number of Markov proposals. verbose::Bool : whether or not to print off information during the simulation. molecules::Array{Molecule, 1} : a starting configuration of molecules in the framework. Note that we assume these coordinates are Cartesian, i.e. corresponding to a unit box. ewald_precision::Float64 : The desired precision for the long range Ewald summation eos::Symbol : equation of state to use for calculation of fugacity from pressure. Default is ideal gas, where fugacity = pressure. load_checkpoint_file::Bool : Will find a checkpoint file corresponding to the gcmc_result_savename if true. If that file is not found, function will throw an error. checkpoint::Dict : A checkpoint dictionary that will work as a starting configuration for the run. The dictionary has to have the following keys: outer_cycle , molecules , system_energy , current_block , gcmc_stats , markov_counts , markov_chain_time and time . If this argument is used, keep load_checkpoint_file=false . write_checkpoints::Bool : Will save checkpoints in data/gcmc_checkpoints if this is true. checkpoint_frequency::Int : Will save checkpoint files every checkpoint_frequency cycles. write_adsorbate_snapshots::Bool : Whether the simulation will create and save a snapshot file snapshot_frequency::Int : The number of cycles taken between each snapshot (after burn cycle completion) calculate_density_grid::Bool : Whether the simulation will keep track of a density grid for adsorbates density_grid_dx::Float64 : The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by required_n_pts . density_grid_species::Symbol : The atomic species within the molecule for which we will compute the density grid. filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file (if autosaved) source # PorousMaterials.adsorption_isotherm Function . results = adsorption_isotherm(framework, molecule, temperature, pressures, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=true, ewald_precision=1e-6, eos=:ideal, load_checkpoint_file=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=50, filename_comment= , show_progress_bar=false) Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in parallel. Arguments are the same as gcmc_simulation , as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as julia -p 4 mysim.jl to allocate e.g. four cores. See Parallel Computing . source # PorousMaterials.stepwise_adsorption_isotherm Function . results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, ljforcefield; n_sample_cycles=5000, n_burn_cycles=5000, sample_frequency=1, verbose=true, ewald_precision=1e-6, eos=:ideal, load_checkpoint_file=false, checkpoint=Dict(), write_checkpoints=false, checkpoint_frequency=50, filename_comment= , show_progress_bar=false) Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in series. Arguments are the same as gcmc_simulation , as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of pressures is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see adsorption_isotherm which runs the \u03bcVT simulation at each pressure in parallel. source # PorousMaterials.gcmc_result_savename Function . file_save_name = gcmc_result_savename(framework_name, molecule_species, ljforcefield_name, temperature, pressure, n_burn_cycles, n_sample_cycles; comment= , extension= ) Determine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds. Arguments framework_name::AbstractString : The porous crystal being tested molecule_species::Symbol : The molecule being tested inside the porous crystal ljforcefield_name::AbstractString : The molecular model being used in this simulation to describe intermolecular Van der Waals interactions temperature::Float64 : The temperature used in the simulation units: Kelvin (K) pressure::Float64 : The pressure used in the simulation units: bar n_burn_cycles::Int : The number of burn cycles used in this simulation n_sample_cycles::Int : The number of sample cycles used in this simulation comment::AbstractString : An optional comment that will be appended to the end of the filename extension::AbstractString : The extension for the file being created source","title":"Grand-Canonical Monte Carlo Simulations"},{"location":"manual/molecules/","text":"Loading in Molecule Files # Molecule input files are stored in PorousMaterials.PATH_TO_MOLECULES . Each molecule possesses its own directory and contains two files: point_charges.csv and lennard_jones_spheres.csv , comma-separated-value files describing the point charges and Lennard Jones spheres, respectively, comprising the molecule. Only rigid molecules are currently supported. Units of length are in Angstrom; units of charges are electrons. using PorousMaterials m = Molecule( CO2 ) PorousMaterials will then output information about the molecule you just loaded: Molecule species: CO2 Center of mass (fractional coords): [0.0, 0.0, 0.0] Atoms: atom = C_CO2, xf = [0.000, 0.000, 0.000] atom = O_CO2, xf = [-1.160, 0.000, 0.000] atom = O_CO2, xf = [1.160, 0.000, 0.000] Point charges: charge = 0.700000, xf = [0.000, 0.000, 0.000] charge = -0.350000, xf = [-1.160, 0.000, 0.000] charge = -0.350000, xf = [1.160, 0.000, 0.000] Building Blocks of PorousMaterials: Molecules # molecule = Molecule( CO2 ) # fractional coords in terms of unit cube box # access Lennard-Jones spheres point charges that comprise molecule molecule.atoms molecule.charges # translate to [1.0, 2.0, 3.0] fractional coordinates translate_to!(molecule, [1.0, 2.0, 3.0]) # translate by [0.1, 0.0, 0.0] fractional coordinates translate_by!(molecule, [0.1, 0.0, 0.0]) # conduct a uniform random rotation rotate!(molecule, UnitCube()) # b/c now fractional coords defined in context of a unit cube Molecules # # PorousMaterials.Molecule Type . Data structure for a molecule/adsorbate. Attributes species::Symbol : Species of molecule, e.g. :CO2 atoms::Atoms : array of Lennard-Jones spheres comprising the molecule charges::Charges : array of point charges comprising the molecule xf_com::Array{Float64, 1} : center of mass of the molecule in fractional coordinates source # PorousMaterials.n_atoms Function . num_atoms = n_atoms(molecules) calculates the total number of atoms in an array of molecules Arguments molecule::Array{Molecule, 1} : The molecules to count the number of atoms in Returns The total number of atoms in the molecules passed in source # PorousMaterials.translate_to! Function . translate_to!(molecule, xf) translate_to!(molecule, x, box) Translate a molecule a molecule to point xf in fractional coordinate space or to x in Cartesian coordinate space. For the latter, a unit cell box is required for context. The molecule is translated such that its center of mass is at xf /x`. Arguments molecule::Molecule : The molecule which will be translated to xf xf::Array{Float64, 1} : A vector containing the coordinates of the final destination of the molecule source # PorousMaterials.rotate! Function . rotate!(molecule, box) Conduct a random rotation of the molecule about its center of mass. The box is needed because the molecule contains only its fractional coordinates. Arguments molecule::Molecule : The molecule which will be subject to a random rotation box::Box : The molecule only contains fractional coordinates, so the box is needed for a correct rotation source # PorousMaterials.rotation_matrix Method . r = rotation_matrix() Generate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x , this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x) . See James Arvo. Fast Random Rotation Matrices. https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf Returns r::Array{Float64, 2} : A 3x3 random rotation matrix source # PorousMaterials.rotation_matrix Method . R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u R = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim` Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis u . See Wikipedia . Arguments \u03b8::Float64 : angle to rotate about an axis, in radians u::Array{Float64, 1} : axis about which to rotate dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively. assume_unit_vector::Bool : assume u is a unit vector; otherwise, u will be normalized internal to this function. Returns R::Array{Float64, 2} : 3D rotation matrix. so R * x will rotate vector x as desired. source # PorousMaterials.rand_point_on_unit_sphere Function . u = rand_point_on_unit_sphere() Generate a unit vector with a random orientation. Returns u::Array{Float64, 1} : A unit vector with a random orientation source # PorousMaterials.charged Method . charged_flag = charged(molecule, verbose=false) Determine if a molecule has point charges Arguments molecule::Molecule : The molecule which will be checked for charges verbose::Bool : Will print result if true Returns charged_flag::Bool : true if molecule is charged, false otherwise source Molecular Movement # # PorousMaterials.insert_molecule! Function . insert_molecule!(molecules, box, template) Inserts an additional adsorbate molecule into the simulation box using the template provided. The center of mass of the molecule is chosen at a uniform random position in the simulation box. A uniformly random orientation of the molecule is chosen by rotating about the center of mass. Arguments molecules::Array{Molecule, 1} : An array of Molecule objects box::Box : The simulation box template::Molecule : A template molecule used as reference when inserting molecules source # PorousMaterials.delete_molecule! Function . delete_molecule!(molecule_id, molecules) Removes a random molecule from the current molecules in the framework. molecule_id decides which molecule will be deleted, for a simulation, it must be a randomly generated value Arguments molecule_id::Int : The molecule ID is used to determine which molecule in molecules should be removed molecules::Array{Molecule, 1} : An array of Molecule objects source # PorousMaterials.translate_molecule! Function . translate_molecule!(molecule, box) Perturbs the Cartesian coordinates of a molecule about its center of mass by a random vector of max length \u03b4. Applies periodic boundary conditions to keep the molecule inside the simulation box. Returns a deep copy of the old molecule in case it needs replaced if the Monte Carlo proposal is rejected. Arguments molecule::Molecule : The molecule we want to perturb box::Box : The simulation box Returns old_molecule::Molecule : The old molecule in case the MC proposal is rejected source # PorousMaterials.reinsert_molecule! Function . reinsert_molecule(molecule, box) Move molecule to a new center of mass randomly distrubted in the unit cell and choose a random orientation for it. Return a deep copy of the starting molecule for possible restoration. This MC move can be viewed as a more aggressive translate_molecule! . Arguments molecule::Molecule : The molecule we want to perturb box::Box : The simulation box source # PorousMaterials.rotatable Function . need_to_rotate = rotatable(molecule) Determines whether or not a given molecule needs to be rotated. For example, rotating a single atom isn't necessary. Arguments molecule::Molecule : The molecule being tested. This function determines if a rotation of this molecule will do anything. Returns is_rotatable::Bool : A boolean describing whether or not rotating the molecule will alter its interactions with other molecules source","title":"Molecules"},{"location":"manual/molecules/#loading-in-molecule-files","text":"Molecule input files are stored in PorousMaterials.PATH_TO_MOLECULES . Each molecule possesses its own directory and contains two files: point_charges.csv and lennard_jones_spheres.csv , comma-separated-value files describing the point charges and Lennard Jones spheres, respectively, comprising the molecule. Only rigid molecules are currently supported. Units of length are in Angstrom; units of charges are electrons. using PorousMaterials m = Molecule( CO2 ) PorousMaterials will then output information about the molecule you just loaded: Molecule species: CO2 Center of mass (fractional coords): [0.0, 0.0, 0.0] Atoms: atom = C_CO2, xf = [0.000, 0.000, 0.000] atom = O_CO2, xf = [-1.160, 0.000, 0.000] atom = O_CO2, xf = [1.160, 0.000, 0.000] Point charges: charge = 0.700000, xf = [0.000, 0.000, 0.000] charge = -0.350000, xf = [-1.160, 0.000, 0.000] charge = -0.350000, xf = [1.160, 0.000, 0.000]","title":"Loading in Molecule Files"},{"location":"manual/molecules/#building-blocks-of-porousmaterials-molecules","text":"molecule = Molecule( CO2 ) # fractional coords in terms of unit cube box # access Lennard-Jones spheres point charges that comprise molecule molecule.atoms molecule.charges # translate to [1.0, 2.0, 3.0] fractional coordinates translate_to!(molecule, [1.0, 2.0, 3.0]) # translate by [0.1, 0.0, 0.0] fractional coordinates translate_by!(molecule, [0.1, 0.0, 0.0]) # conduct a uniform random rotation rotate!(molecule, UnitCube()) # b/c now fractional coords defined in context of a unit cube","title":"Building Blocks of PorousMaterials: Molecules"},{"location":"manual/molecules/#molecules","text":"# PorousMaterials.Molecule Type . Data structure for a molecule/adsorbate. Attributes species::Symbol : Species of molecule, e.g. :CO2 atoms::Atoms : array of Lennard-Jones spheres comprising the molecule charges::Charges : array of point charges comprising the molecule xf_com::Array{Float64, 1} : center of mass of the molecule in fractional coordinates source # PorousMaterials.n_atoms Function . num_atoms = n_atoms(molecules) calculates the total number of atoms in an array of molecules Arguments molecule::Array{Molecule, 1} : The molecules to count the number of atoms in Returns The total number of atoms in the molecules passed in source # PorousMaterials.translate_to! Function . translate_to!(molecule, xf) translate_to!(molecule, x, box) Translate a molecule a molecule to point xf in fractional coordinate space or to x in Cartesian coordinate space. For the latter, a unit cell box is required for context. The molecule is translated such that its center of mass is at xf /x`. Arguments molecule::Molecule : The molecule which will be translated to xf xf::Array{Float64, 1} : A vector containing the coordinates of the final destination of the molecule source # PorousMaterials.rotate! Function . rotate!(molecule, box) Conduct a random rotation of the molecule about its center of mass. The box is needed because the molecule contains only its fractional coordinates. Arguments molecule::Molecule : The molecule which will be subject to a random rotation box::Box : The molecule only contains fractional coordinates, so the box is needed for a correct rotation source # PorousMaterials.rotation_matrix Method . r = rotation_matrix() Generate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x , this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x) . See James Arvo. Fast Random Rotation Matrices. https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf Returns r::Array{Float64, 2} : A 3x3 random rotation matrix source # PorousMaterials.rotation_matrix Method . R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u R = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim` Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis u . See Wikipedia . Arguments \u03b8::Float64 : angle to rotate about an axis, in radians u::Array{Float64, 1} : axis about which to rotate dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively. assume_unit_vector::Bool : assume u is a unit vector; otherwise, u will be normalized internal to this function. Returns R::Array{Float64, 2} : 3D rotation matrix. so R * x will rotate vector x as desired. source # PorousMaterials.rand_point_on_unit_sphere Function . u = rand_point_on_unit_sphere() Generate a unit vector with a random orientation. Returns u::Array{Float64, 1} : A unit vector with a random orientation source # PorousMaterials.charged Method . charged_flag = charged(molecule, verbose=false) Determine if a molecule has point charges Arguments molecule::Molecule : The molecule which will be checked for charges verbose::Bool : Will print result if true Returns charged_flag::Bool : true if molecule is charged, false otherwise source","title":"Molecules"},{"location":"manual/molecules/#molecular-movement","text":"# PorousMaterials.insert_molecule! Function . insert_molecule!(molecules, box, template) Inserts an additional adsorbate molecule into the simulation box using the template provided. The center of mass of the molecule is chosen at a uniform random position in the simulation box. A uniformly random orientation of the molecule is chosen by rotating about the center of mass. Arguments molecules::Array{Molecule, 1} : An array of Molecule objects box::Box : The simulation box template::Molecule : A template molecule used as reference when inserting molecules source # PorousMaterials.delete_molecule! Function . delete_molecule!(molecule_id, molecules) Removes a random molecule from the current molecules in the framework. molecule_id decides which molecule will be deleted, for a simulation, it must be a randomly generated value Arguments molecule_id::Int : The molecule ID is used to determine which molecule in molecules should be removed molecules::Array{Molecule, 1} : An array of Molecule objects source # PorousMaterials.translate_molecule! Function . translate_molecule!(molecule, box) Perturbs the Cartesian coordinates of a molecule about its center of mass by a random vector of max length \u03b4. Applies periodic boundary conditions to keep the molecule inside the simulation box. Returns a deep copy of the old molecule in case it needs replaced if the Monte Carlo proposal is rejected. Arguments molecule::Molecule : The molecule we want to perturb box::Box : The simulation box Returns old_molecule::Molecule : The old molecule in case the MC proposal is rejected source # PorousMaterials.reinsert_molecule! Function . reinsert_molecule(molecule, box) Move molecule to a new center of mass randomly distrubted in the unit cell and choose a random orientation for it. Return a deep copy of the starting molecule for possible restoration. This MC move can be viewed as a more aggressive translate_molecule! . Arguments molecule::Molecule : The molecule we want to perturb box::Box : The simulation box source # PorousMaterials.rotatable Function . need_to_rotate = rotatable(molecule) Determines whether or not a given molecule needs to be rotated. For example, rotating a single atom isn't necessary. Arguments molecule::Molecule : The molecule being tested. This function determines if a rotation of this molecule will do anything. Returns is_rotatable::Bool : A boolean describing whether or not rotating the molecule will alter its interactions with other molecules source","title":"Molecular Movement"},{"location":"manual/other/","text":"PorousMaterials relies on functions that fall outside of the sections discussed up to this point. They are useful, but operate on their own for the most part. Control over directories for input and output files # Call print_file_paths() to show where input/output files are read from/written to. To change the directory where certain files are read from/output to, for example: @eval PorousMaterials PATH_TO_CRYSTALS = joinpath(pwd(), my_xtals ) @eval PorousMaterials PATH_TO_FORCEFIELDS = joinpath(pwd(), my_ffs ) @eval PorousMaterials PATH_TO_GRIDS = joinpath(pwd(), my_grids ) @eval PorousMaterials PATH_TO_MOLECULES = joinpath(pwd(), my_molecules ) @eval PorousMaterials PATH_TO_DATA = pwd() To use absolute file paths when reading in e.g. crystals via the Framework constructor, you can simply: @eval PorousMaterials PATH_TO_CRYSTALS = Call set_default_file_paths() to set input/output file paths back to default. The PATH_TO_DATA is crucial for loading in data files. These functions allow the user to control this after they have done using PorousMaterials . The set_tutorial_mode() function has been discussed before, and it allows you to recreate our example and try PorousMaterials before loading your data. The other functions allow the user to reset the PATH_TO_DATA to the data folder in their current directory or to another directory on their machine if their files are stored in many places. Reading in Atomic Values # These functions are used to read in the atomicmasses.csv , atom_properties.csv , and cpk_atom_colors.csv files from the current PATH_TO_DATA directory. They contain information on the masses, radii, and cpk color scheme for atoms. Using .xyz files # These functions allow the user to load and save .xyz files describing where molecules appear in a given space. This can be used to save the location of molecules in the middle of a simulation or to visualize what is happening. Fitting data to adsorption models # PorousMaterials allows for a DataFrame to be read in and fitted to a single-site Langmuir model or to a Henry's law model. using PorousMaterials using DataFrames adsorption_data = DataFrame(Dict( Pressure (bar) = [0.008045, 0.042218, 0.078772, 0.108018, 0.156741, 0.312670, 0.414986, 0.517303, 0.619628, 0.719519, 0.821872, 0.863296, 0.912055, 0.960878, 0.982918, 0.990353, 0.995361, 0.998043, 1.000610, 1.005600, 1.005720], Adsorption (mmol/g) = [4.062603, 4.462196, 4.560714, 4.659598, 4.707321, 4.950402, 5.045670, 5.140938, 5.286339, 5.431875, 5.727768, 5.826027, 6.074420, 6.673929, 7.324955, 8.026830, 8.778973, 10.133170, 10.835313, 11.487143, 12.189375])) # We can fit the adsorption data to a Langmuir isotherm with the following call. Note that we need to enter the column names for the pressure and adsorption. results = fit_adsorption_isotherm(adsorption_data, Symbol( Pressure (bar) ), Symbol( Adsorption (mmol/g) ), :langmuir) M, K = results[ M ], results[ K ] # We can also use the function to get the Henry Coefficient results = fit_adsorption_isotherm(adsorption_data, Symbol( Pressure (bar) ), Symbol( Adsorption (mmol/g) ), :henry) H = results[ H ] PATH_TO_DATA Control # # PorousMaterials.print_file_paths Function . print_file_paths() Print off paths where PorousMaterials.jl looks for input files and writes output files. source # PorousMaterials.set_default_file_paths Function . set_default_file_paths(print_paths=true) Sets the default paths for where input files and some output files are stored. To see current set up, call print_file_paths source # PorousMaterials.set_tutorial_mode Function . set_tutorial_mode() Places PorousMaterials in \"Tutorial Mode\". It changes the PATH_TO_DATA variable to the directory where the PorousMaterials test data is stored. It can be used to follow examples shown in the README. It displays a warning so that the user knows They are no longer using their own data. source Reading in Atomic Values # # PorousMaterials.read_atomic_radii Function . atomic_radii = read_atomic_radii() Return atomic_radii::Dict{Symbol, Float64} , where atom_masses[\":C\"] gives the atomic radii of carbon (10.87 Angstrom). Returns atomic_radii::Dict{Symbol, Float64} : A dictionary linking an element symbol to its' corresponding atomic radius source # PorousMaterials.read_atomic_masses Function . atomic_masses = read_atomic_masses() Read the data/atomicmasses.csv file to construct a dictionary of atoms and their atomic masses in amu. Returns atomic_masses::Dict{Symbol, Float64} : A dictionary containing the atomic masses of each atom stored in data/atomicmasses.csv source # PorousMaterials.read_cpk_colors Function . atom_colors = read_cpk_colors() Read in CPK color scheme for atoms. Return atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} such that atom_colors[\":C\"] gives RGB code for carbon as a tuple, (144, 144, 144) . https://en.wikipedia.org/wiki/CPK_coloring Returns atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} : A dictionary linking an element symbol to its' corresponding CPK color in RGB source Using .xyz files # # PorousMaterials.read_xyz Function . atoms, x = read_xyz(filename) Return the list of atoms (Array{Symbol, 1}) and their Cartesian coordinates x::Array{Float64, 2} as stored in the .xyz file. x[:, k] will return Cartesian coords of the kth atom. Arguments filename::AbstractString : The filename of the .xyz file Returns atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O] read from the .xyz file. x::Array{Float64, 2} : The Cartesian coordinates of the atoms. x[:, k] will return cartesian coordinates of the k-th atom source # PorousMaterials.write_xyz Function . write_xyz(atoms, x, filename; comment= ) write_xyz(molecules, box, filename; comment= ) write_xyz(framework, filename; comment= , center=false) Write a molecule, framework, or array of atoms positions to an .xyz file. Arguments atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O] x::Array{Float64, 2} : The Cartesian coordinates of the atoms. x[:, k] contains Cartesian coordinates of the k-th atom molecules::Array{Molecule, 1} : an array of molecules whose atoms to write to .xyz framework::Framework : a crystal structure whose atoms to write to .xyz filename::AbstractString : The filename of the .xyz file. (\".xyz\" appended automatically if the extension is not provided.) (absolute path) comment::AbstractString : comment if you'd like to write to the file. center::Bool : shift atoms so that origin is the center of the framework.box source write_xyz(box, molecules, xyz_file) Writes the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end. This writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion. Arguments box::Box : The box the molecules are in, to convert molecule positions to cartesian coordinates molecules::Array{Molecule, 1} : The array of molecules to be written to the file xyz_file::IOStream : The open 'write' file stream the data will be saved to source Generic Rotations # # PorousMaterials.rotation_matrix Function . r = rotation_matrix() Generate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x , this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x) . See James Arvo. Fast Random Rotation Matrices. https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf Returns r::Array{Float64, 2} : A 3x3 random rotation matrix source R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u R = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim` Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis u . See Wikipedia . Arguments \u03b8::Float64 : angle to rotate about an axis, in radians u::Array{Float64, 1} : axis about which to rotate dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively. assume_unit_vector::Bool : assume u is a unit vector; otherwise, u will be normalized internal to this function. Returns R::Array{Float64, 2} : 3D rotation matrix. so R * x will rotate vector x as desired. source Fitting data # # PorousMaterials.fit_adsorption_isotherm Function . params = fit_adsorption_isotherm(df, pressure_col_name, loading_col_name, model) Takes in a DataFrame df containing adsorption isotherm data and fits an analytical model to the data to identify its parameters of best fit, returned as a dictionary. Available models are :henry and :langmuir The Henry model takes the following form: N = HP The identified Henry coefficient is params[\"H\"] . The Langmuir model takes the following form: N = (MKP)/(1+KP) where N is the total adsorption, M is the maximum monolayer coverage, K is the Langmuir constant. and P is the pressure of the gas. Arguments df::DataFrame : The DataFrame containing the pressure and adsorption data for the isotherm pressure_col_name::Symbol : The header of the pressure column. Can be found with names(df) loading_col_name::Symbol : The header of the loading/adsorption column. Can be found with names(df) model::Symbol : The model chosen to fit to the adsorption isotherm data Returns params::Dict{AbstractString, Float64} : A Dictionary with the parameters corresponding to each model along with the MSE of the fit. :langmuir contains \"M\" and \"K\". :henry contains \"H\". source","title":"Other"},{"location":"manual/other/#control-over-directories-for-input-and-output-files","text":"Call print_file_paths() to show where input/output files are read from/written to. To change the directory where certain files are read from/output to, for example: @eval PorousMaterials PATH_TO_CRYSTALS = joinpath(pwd(), my_xtals ) @eval PorousMaterials PATH_TO_FORCEFIELDS = joinpath(pwd(), my_ffs ) @eval PorousMaterials PATH_TO_GRIDS = joinpath(pwd(), my_grids ) @eval PorousMaterials PATH_TO_MOLECULES = joinpath(pwd(), my_molecules ) @eval PorousMaterials PATH_TO_DATA = pwd() To use absolute file paths when reading in e.g. crystals via the Framework constructor, you can simply: @eval PorousMaterials PATH_TO_CRYSTALS = Call set_default_file_paths() to set input/output file paths back to default. The PATH_TO_DATA is crucial for loading in data files. These functions allow the user to control this after they have done using PorousMaterials . The set_tutorial_mode() function has been discussed before, and it allows you to recreate our example and try PorousMaterials before loading your data. The other functions allow the user to reset the PATH_TO_DATA to the data folder in their current directory or to another directory on their machine if their files are stored in many places.","title":"Control over directories for input and output files"},{"location":"manual/other/#reading-in-atomic-values","text":"These functions are used to read in the atomicmasses.csv , atom_properties.csv , and cpk_atom_colors.csv files from the current PATH_TO_DATA directory. They contain information on the masses, radii, and cpk color scheme for atoms.","title":"Reading in Atomic Values"},{"location":"manual/other/#using-xyz-files","text":"These functions allow the user to load and save .xyz files describing where molecules appear in a given space. This can be used to save the location of molecules in the middle of a simulation or to visualize what is happening.","title":"Using .xyz files"},{"location":"manual/other/#fitting-data-to-adsorption-models","text":"PorousMaterials allows for a DataFrame to be read in and fitted to a single-site Langmuir model or to a Henry's law model. using PorousMaterials using DataFrames adsorption_data = DataFrame(Dict( Pressure (bar) = [0.008045, 0.042218, 0.078772, 0.108018, 0.156741, 0.312670, 0.414986, 0.517303, 0.619628, 0.719519, 0.821872, 0.863296, 0.912055, 0.960878, 0.982918, 0.990353, 0.995361, 0.998043, 1.000610, 1.005600, 1.005720], Adsorption (mmol/g) = [4.062603, 4.462196, 4.560714, 4.659598, 4.707321, 4.950402, 5.045670, 5.140938, 5.286339, 5.431875, 5.727768, 5.826027, 6.074420, 6.673929, 7.324955, 8.026830, 8.778973, 10.133170, 10.835313, 11.487143, 12.189375])) # We can fit the adsorption data to a Langmuir isotherm with the following call. Note that we need to enter the column names for the pressure and adsorption. results = fit_adsorption_isotherm(adsorption_data, Symbol( Pressure (bar) ), Symbol( Adsorption (mmol/g) ), :langmuir) M, K = results[ M ], results[ K ] # We can also use the function to get the Henry Coefficient results = fit_adsorption_isotherm(adsorption_data, Symbol( Pressure (bar) ), Symbol( Adsorption (mmol/g) ), :henry) H = results[ H ]","title":"Fitting data to adsorption models"},{"location":"manual/other/#path_to_data-control","text":"# PorousMaterials.print_file_paths Function . print_file_paths() Print off paths where PorousMaterials.jl looks for input files and writes output files. source # PorousMaterials.set_default_file_paths Function . set_default_file_paths(print_paths=true) Sets the default paths for where input files and some output files are stored. To see current set up, call print_file_paths source # PorousMaterials.set_tutorial_mode Function . set_tutorial_mode() Places PorousMaterials in \"Tutorial Mode\". It changes the PATH_TO_DATA variable to the directory where the PorousMaterials test data is stored. It can be used to follow examples shown in the README. It displays a warning so that the user knows They are no longer using their own data. source","title":"PATH_TO_DATA Control"},{"location":"manual/other/#reading-in-atomic-values_1","text":"# PorousMaterials.read_atomic_radii Function . atomic_radii = read_atomic_radii() Return atomic_radii::Dict{Symbol, Float64} , where atom_masses[\":C\"] gives the atomic radii of carbon (10.87 Angstrom). Returns atomic_radii::Dict{Symbol, Float64} : A dictionary linking an element symbol to its' corresponding atomic radius source # PorousMaterials.read_atomic_masses Function . atomic_masses = read_atomic_masses() Read the data/atomicmasses.csv file to construct a dictionary of atoms and their atomic masses in amu. Returns atomic_masses::Dict{Symbol, Float64} : A dictionary containing the atomic masses of each atom stored in data/atomicmasses.csv source # PorousMaterials.read_cpk_colors Function . atom_colors = read_cpk_colors() Read in CPK color scheme for atoms. Return atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} such that atom_colors[\":C\"] gives RGB code for carbon as a tuple, (144, 144, 144) . https://en.wikipedia.org/wiki/CPK_coloring Returns atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} : A dictionary linking an element symbol to its' corresponding CPK color in RGB source","title":"Reading in Atomic Values"},{"location":"manual/other/#using-xyz-files_1","text":"# PorousMaterials.read_xyz Function . atoms, x = read_xyz(filename) Return the list of atoms (Array{Symbol, 1}) and their Cartesian coordinates x::Array{Float64, 2} as stored in the .xyz file. x[:, k] will return Cartesian coords of the kth atom. Arguments filename::AbstractString : The filename of the .xyz file Returns atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O] read from the .xyz file. x::Array{Float64, 2} : The Cartesian coordinates of the atoms. x[:, k] will return cartesian coordinates of the k-th atom source # PorousMaterials.write_xyz Function . write_xyz(atoms, x, filename; comment= ) write_xyz(molecules, box, filename; comment= ) write_xyz(framework, filename; comment= , center=false) Write a molecule, framework, or array of atoms positions to an .xyz file. Arguments atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O] x::Array{Float64, 2} : The Cartesian coordinates of the atoms. x[:, k] contains Cartesian coordinates of the k-th atom molecules::Array{Molecule, 1} : an array of molecules whose atoms to write to .xyz framework::Framework : a crystal structure whose atoms to write to .xyz filename::AbstractString : The filename of the .xyz file. (\".xyz\" appended automatically if the extension is not provided.) (absolute path) comment::AbstractString : comment if you'd like to write to the file. center::Bool : shift atoms so that origin is the center of the framework.box source write_xyz(box, molecules, xyz_file) Writes the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end. This writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion. Arguments box::Box : The box the molecules are in, to convert molecule positions to cartesian coordinates molecules::Array{Molecule, 1} : The array of molecules to be written to the file xyz_file::IOStream : The open 'write' file stream the data will be saved to source","title":"Using .xyz files"},{"location":"manual/other/#generic-rotations","text":"# PorousMaterials.rotation_matrix Function . r = rotation_matrix() Generate a 3x3 random rotation matrix r such that when a point x is rotated using this rotation matrix via r * x , this point x is placed at a uniform random distributed position on the surface of a sphere of radius norm(x) . See James Arvo. Fast Random Rotation Matrices. https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf Returns r::Array{Float64, 2} : A 3x3 random rotation matrix source R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u R = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim` Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis u . See Wikipedia . Arguments \u03b8::Float64 : angle to rotate about an axis, in radians u::Array{Float64, 1} : axis about which to rotate dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively. assume_unit_vector::Bool : assume u is a unit vector; otherwise, u will be normalized internal to this function. Returns R::Array{Float64, 2} : 3D rotation matrix. so R * x will rotate vector x as desired. source","title":"Generic Rotations"},{"location":"manual/other/#fitting-data","text":"# PorousMaterials.fit_adsorption_isotherm Function . params = fit_adsorption_isotherm(df, pressure_col_name, loading_col_name, model) Takes in a DataFrame df containing adsorption isotherm data and fits an analytical model to the data to identify its parameters of best fit, returned as a dictionary. Available models are :henry and :langmuir The Henry model takes the following form: N = HP The identified Henry coefficient is params[\"H\"] . The Langmuir model takes the following form: N = (MKP)/(1+KP) where N is the total adsorption, M is the maximum monolayer coverage, K is the Langmuir constant. and P is the pressure of the gas. Arguments df::DataFrame : The DataFrame containing the pressure and adsorption data for the isotherm pressure_col_name::Symbol : The header of the pressure column. Can be found with names(df) loading_col_name::Symbol : The header of the loading/adsorption column. Can be found with names(df) model::Symbol : The model chosen to fit to the adsorption isotherm data Returns params::Dict{AbstractString, Float64} : A Dictionary with the parameters corresponding to each model along with the MSE of the fit. :langmuir contains \"M\" and \"K\". :henry contains \"H\". source","title":"Fitting data"}]}