{
    "docs": [
        {
            "location": "/", 
            "text": "A pure-\nJulia\n package for classical molecular modeling of adsorption in porous crystals such as metal-organic frameworks (MOFs).\n\n\n\ud83d\udd28 Compute the potential energy of a molecule at particular position and orientation inside of a porous crystal\n\n\n\ud83d\udd28 Write a potential energy grid of a molecule inside a porous material to visualize binding sites\n\n\n\ud83d\udd28 Compute the Henry coefficient of a gas in a porous crystal\n\n\n\ud83d\udd28 Run grand-canonical Monte Carlo simulations of gas adsorption in a porous crystal\n\n\nDesigned for high-throughput computations to minimize input files and querying results from output files. User-friendly. Instructive error messages thrown when they should be. Well-documented. Easy to install.\n\n\nIn development, please contribute, post issues \ud83d\udc1b, and improve!\n\n\n\n\nInstallation\n#\n\n\n\n\n\n\nDownload and install the \nJulia programming language\n, v1.0.\n\n\n\n\n\n\nIn Julia, open the package manager (using \n]\n) and enter the following:\n\n\n\n\n\n\nadd PorousMaterials\n\n\n\n\n\n\nIn Julia, load all functions in \nPorousMaterials.jl\n into the namespace:\n\n\n\n\nusing PorousMaterials # that's it\n\n\n\n\n\n\nTests\n#\n\n\nRun the unit-ish tests in the script \ntests/runtests.jl\n manually or type \nPkg.test(\"PorousMaterials\")\n into Julia.\n\n\nDirect tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and are found in \ntests/henry_test.jl\n and \ntests/gcmc_test.jl\n.", 
            "title": "PorousMaterials"
        }, 
        {
            "location": "/#installation", 
            "text": "Download and install the  Julia programming language , v1.0.    In Julia, open the package manager (using  ] ) and enter the following:    add PorousMaterials   In Julia, load all functions in  PorousMaterials.jl  into the namespace:   using PorousMaterials # that's it", 
            "title": "Installation"
        }, 
        {
            "location": "/#tests", 
            "text": "Run the unit-ish tests in the script  tests/runtests.jl  manually or type  Pkg.test(\"PorousMaterials\")  into Julia.  Direct tests for Henry coefficients and grand-canonical Monte Carlo simulations take much longer and are found in  tests/henry_test.jl  and  tests/gcmc_test.jl .", 
            "title": "Tests"
        }, 
        {
            "location": "/guides/input_files/", 
            "text": "Input files to describe crystals, molecules, and forcefields\n#\n\n\nAll input files are stored in the path \nPorousMaterials.PATH_TO_DATA\n (type into Julia). By default, this path is set to be in the present working directory (type \npwd()\n into Julia) in a folder \ndata/\n. Go inside \nPorousMaterials.jl/test/data\n to see example input files for each case below.\n\n\nThere will be example code snippets through the documentation showing how to load in various files. To get a feel for this we have included a Tutorial Mode in \nPorousMaterials.jl\n that sets the \nPorousMaterial.PATH_TO_DATA\n to the data folder in our testing directory. To follow along with the examples without downloading your own data simply do the following:\n\n\nusing PorousMaterials\n\nset_tutorial_mode()\n    \u250c Warning: PorousMaterials is now in Tutorial Mode. You have access to the testing data to experiment with PorousMaterials.\n    \u2502 To get access to your own data use: reset_path_to_data()\n    \u2514 @ PorousMaterials ~/git_files/PorousMaterials.jl/src/PorousMaterials.jl:75\n\n\n\n\n\n\nAtomic masses\n#\n\n\nAdd fancy pseudo-atoms to \ndata/atomic_masses.csv\n.\n\n\n\n\nPeng-Robinson gas parameters\n#\n\n\nCritical temperatures and pressures and acentric factors are stored in \ndata/PengRobinsonGasProps.csv\n.", 
            "title": "Loading Data"
        }, 
        {
            "location": "/guides/input_files/#input-files-to-describe-crystals-molecules-and-forcefields", 
            "text": "All input files are stored in the path  PorousMaterials.PATH_TO_DATA  (type into Julia). By default, this path is set to be in the present working directory (type  pwd()  into Julia) in a folder  data/ . Go inside  PorousMaterials.jl/test/data  to see example input files for each case below.  There will be example code snippets through the documentation showing how to load in various files. To get a feel for this we have included a Tutorial Mode in  PorousMaterials.jl  that sets the  PorousMaterial.PATH_TO_DATA  to the data folder in our testing directory. To follow along with the examples without downloading your own data simply do the following:  using PorousMaterials\n\nset_tutorial_mode()\n    \u250c Warning: PorousMaterials is now in Tutorial Mode. You have access to the testing data to experiment with PorousMaterials.\n    \u2502 To get access to your own data use: reset_path_to_data()\n    \u2514 @ PorousMaterials ~/git_files/PorousMaterials.jl/src/PorousMaterials.jl:75", 
            "title": "Input files to describe crystals, molecules, and forcefields"
        }, 
        {
            "location": "/guides/input_files/#atomic-masses", 
            "text": "Add fancy pseudo-atoms to  data/atomic_masses.csv .", 
            "title": "Atomic masses"
        }, 
        {
            "location": "/guides/input_files/#peng-robinson-gas-parameters", 
            "text": "Critical temperatures and pressures and acentric factors are stored in  data/PengRobinsonGasProps.csv .", 
            "title": "Peng-Robinson gas parameters"
        }, 
        {
            "location": "/manual/matter/", 
            "text": "Matter is the foundation for every data type defined in PorousMaterials. Two structs are used to define all atomic structures: \nAtoms\n and \nCharges\n. Every atom, molecule, or crystal structure can be simulated by understanding its atoms and its point charges.\n\n\nWe chose to store each collection as a single object (Atoms) rather than an array of objects (Array{Atom}) because it allows us to store the locations in contiguous memory. We found significant speed increases when storing each collection as a single object.\n\n\nOne array of locations also allowed us to take advantage of broadcasting. For example, it is useful when calculating the energy inside a framework. Instead of looping through every atom, we can instead run this line:\n\n\ndxf = broadcast(-, framework.atoms.xf, molecule.atoms.xf[i])\n\n\n\n\nThis calculates the distance between one atom in a molecule and every atom in the framework.\n\n\n\n\nBuilding Blocks of PorousMaterials: Matter\n#\n\n\nIn \nPorousMaterials.jl\n, crystals and molecules are composed of \nAtoms\n and \nCharges\n\n\nTo create a carbon atom at \n[0.1, 0.2, 0.5]\n fractional coordinates (in the context of some Bravais lattice):\n\n\nxf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\natoms = Atoms([:C], xf) # constructor\natoms.species[1] # :C\natoms.xf[:, 1] # [0.1, 0.2, 0.5]\n\n\n\n\nTo create a point charge of +1 at \n[0.1, 0.2, 0.5]\n fractional coordinates (in the context of some Bravais lattice):\n\n\nxf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\ncharges = Charges([1.0], xf)\ncharges.q[1] # 1.0\ncharges.xf[:, 1] # [0.1, 0.2, 0.5]\n\n\n\n\n\n\nMatter\n#\n\n\n#\n\n\nPorousMaterials.Atoms\n \n \nType\n.\n\n\nData structure holds a set of atom species and their positions in fractional coordinates.\n\n\nFractional coords of atom \ni\n is \ncharges.xf[:, i]\n.\n\n\nExample use\n\n\natoms = Atoms(2, [:C, :F], [0.0 1.0; 2.0 3.0; 4.0 5.0])\n\n\n\n\nAttributes\n\n\n\n\nn_atoms::Int\n: number of atoms\n\n\nspecies::Array{Symbol, 1}\n: atom species\n\n\nxf::Array{Float64, 2}\n: fractional coordinates in the columns\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.Charges\n \n \nType\n.\n\n\nData structure holds a set of point charges and their positions in fractional coordinates.\n\n\nFractional coords of charge \ni\n is \ncharges.xf[:, i]\n.\n\n\nExample use\n\n\ncharges = Charges(2, [-1.0, 1.0], [0.0 1.0; 2.0 3.0; 4.0 5.0])\n\n\n\n\nAttributes\n\n\n\n\nn_charges::Int\n: number of charges\n\n\nq::Array{Float64, 1}\n: signed magnitude of charges (units: electrons)\n\n\nxf::Array{Float64, 2}\n: fractional coordinates in the columns\n\n\n\n\nsource", 
            "title": "Matter"
        }, 
        {
            "location": "/manual/matter/#building-blocks-of-porousmaterials-matter", 
            "text": "In  PorousMaterials.jl , crystals and molecules are composed of  Atoms  and  Charges  To create a carbon atom at  [0.1, 0.2, 0.5]  fractional coordinates (in the context of some Bravais lattice):  xf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\natoms = Atoms([:C], xf) # constructor\natoms.species[1] # :C\natoms.xf[:, 1] # [0.1, 0.2, 0.5]  To create a point charge of +1 at  [0.1, 0.2, 0.5]  fractional coordinates (in the context of some Bravais lattice):  xf = Array{Float64, 2}(undef, 3, 0)\nxf = [xf [0.1, 0.2, 0.5]]\ncharges = Charges([1.0], xf)\ncharges.q[1] # 1.0\ncharges.xf[:, 1] # [0.1, 0.2, 0.5]", 
            "title": "Building Blocks of PorousMaterials: Matter"
        }, 
        {
            "location": "/manual/matter/#matter", 
            "text": "#  PorousMaterials.Atoms     Type .  Data structure holds a set of atom species and their positions in fractional coordinates.  Fractional coords of atom  i  is  charges.xf[:, i] .  Example use  atoms = Atoms(2, [:C, :F], [0.0 1.0; 2.0 3.0; 4.0 5.0])  Attributes   n_atoms::Int : number of atoms  species::Array{Symbol, 1} : atom species  xf::Array{Float64, 2} : fractional coordinates in the columns   source  #  PorousMaterials.Charges     Type .  Data structure holds a set of point charges and their positions in fractional coordinates.  Fractional coords of charge  i  is  charges.xf[:, i] .  Example use  charges = Charges(2, [-1.0, 1.0], [0.0 1.0; 2.0 3.0; 4.0 5.0])  Attributes   n_charges::Int : number of charges  q::Array{Float64, 1} : signed magnitude of charges (units: electrons)  xf::Array{Float64, 2} : fractional coordinates in the columns   source", 
            "title": "Matter"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/", 
            "text": "Loading in Crystal Structure Files\n#\n\n\nPlace \n.cif\n and \n.cssr\n crystal structure files in \ndata/crystals\n. \nPorousMaterials.jl\n currently takes crystals in P1 symmetry only. From here you can start julia and do the following to load a framework and start working with it.\n\n\nusing PorousMaterials\n\nf = Framework(\nSBMOF-1.cif\n)\n\n\n\n\nPorousMaterials will then output information about the framework you just loaded:\n\n\nName: SBMOF-1.cif\nBravais unit cell of a crystal.\n        Unit cell angles \u03b1 = 90.000000 deg. \u03b2 = 100.897000 deg. \u03b3 = 90.000000 deg.\n        Unit cell dimensions a = 11.619300 \u212b. b = 5.566700 \u212b, c = 22.931200 \u212b\n        Volume of unit cell: 1456.472102 \u212b\u00b3\n\nNumber of atoms = 120\nNumber of charges = 0\nChemical formula: Dict(:H=\n8,:S=\n1,:Ca=\n1,:O=\n6,:C=\n14)\n\n\n\n\n\n\nBuilding Blocks of PorousMaterials: Bravais lattice\n#\n\n\nWe later apply periodic boundary conditions to mimic a crystal of infinite extent. A \nBox\n describes a \nBravais lattice\n.\n\n\nTo make a 10 by 10 by 10 \u212b Bravais lattice with right angles:\n\n\nbox = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2)\n\nbox.a, box.b, box.c # unit cell dimensions (10.0 \u212b)\nbox.\u03b1, box.\u03b2, box.\u03b3 # unit cell angles (1.57... radians)\nbox.\u03a9 # volume (1000.0 \u212b\u00b3)\nbox.f_to_c # fractional to Cartesian coordinate transformation matrix\nbox.c_to_f # Cartesian to fractional coordinate transformation matrix\nbox.reciprocal_lattice # rows are reciprocal lattice vectors\n\n\n\n\nReplicate a box as follows:\n\n\nbox = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2\nbox.a # 20 \u212b\n\n\n\n\n\n\nBuilding Blocks of PorousMaterials: Porous Crystals\n#\n\n\nusing PorousMaterials\n\n# read in xtal structure file\nframework = Framework(\nSBMOF-1.cif\n)\n\n# access unit cell box\nframework.box\n\n# access Lennard-Jones spheres and point charges comprising the crystal\nframework.atoms\nframework.charges\n\n# remove annoying numbers on the atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# compute crystal density\n\u03c1 = crystal_density(framework) # kg/m3\n\n# compute the chemical formula\ncf = chemical_formula(framework)\n\n# assign charges according to atom type\ncharges = Dict(:Ca =\n 3.0, :O =\n 2.0, :C =\n -1.0, :S =\n 7.0, :H =\n -1.0)\ncharged_framework = assign_charges(framework, charges)\n\n# replicate \n visualize\nframework = replicate(framework, (3, 3, 3))\nwrite_to_xyz(framework, \nSBMOF-1.xyz\n)\n\n\n\n\n\n\nDemo of Potential Energy Grid\n#\n\n\nSuperimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid.\n\n\nusing PorousMaterials\n\nframework = Framework(\nSBMOF-1.cif\n)\nmolecule = Molecule(\nXe\n)\nforcefield = LJForceField(\nUFF.csv\n)\n\ngrid = energy_grid(framework, molecule, forcefield,\n    n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure\n\n\n\n\nWrite to a .cube volume file to visualize the potential energy contours.\n\n\nwrite_cube(grid, \nCH4_in_SBMOF1.cube\n)\n\n\n\n\n\n\nBoxes\n#\n\n\n#\n\n\nPorousMaterials.Box\n \n \nType\n.\n\n\nbox = Box(a, b, c, \u03b1, \u03b2, \u03b3, volume, f_to_c, c_to_f, reciprocal_lattice)\nbox = Box(a, b, c, \u03b1, \u03b2, \u03b3)\nbox = Box(f_to_c)\n\n\n\n\nData structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.\n\n\nAttributes\n\n\n\n\na,b,c::Float64\n: unit cell dimensions (units: Angstroms)\n\n\n\u03b1,\u03b2,\u03b3::Float64\n: unit cell angles (units: radians)\n\n\n\u03a9::Float64\n: volume of the unit cell (units: cubic Angtroms)\n\n\nf_to_c::Array{Float64,2}\n: the 3x3 transformation matrix used to map fractional\n\n\n\n\ncoordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom\n\n\n\n\nc_to_f::Array{Float64,2}\n: the 3x3 transformation matrix used to map Cartesian\n\n\n\n\ncoordinates to fractional coordinates. units: inverse Angstrom\n\n\n\n\nreciprocal_lattice::Array{Float64, 2}\n: the \nrows\n are the reciprocal lattice vectors.\n\n\n\n\nThis choice was made (instead of columns) for speed of Ewald Sums.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.replicate\n \n \nFunction\n.\n\n\nnew_box = replicate(original_box, repfactors)\n\n\n\n\nReplicates a \nBox\n in positive directions to construct a new \nBox\n representing a supercell. The \noriginal_box\n is replicated according to the factors in \nrepfactors\n. Note \nreplicate(original_box, repfactors=(1, 1, 1))\n returns same \nBox\n. The new fractional coordinates as described by \nf_to_c\n and \nc_to_f\n still \u2208 [0, 1].\n\n\nArguments\n\n\n\n\noriginal_box::Box\n: The box that you want to replicate\n\n\nrepfactors::Tuple{Int, Int, Int}\n: The factor you want to replicate the box by\n\n\n\n\nReturns\n\n\n\n\nbox::Box\n: Fully formed Box object\n\n\n\n\nsource\n\n\nreplicated_frame = replicate(framework, repfactors)\n\n\n\n\nReplicates the atoms and charges in a \nFramework\n in positive directions to construct a new \nFramework\n. Note \nreplicate(framework, (1, 1, 1))\n returns the same \nFramework\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework to replicate\n\n\nrepfactors::Tuple{Int, Int, Int}\n: The factors by which to replicate the crystal structure in each direction.\n\n\n\n\nReturns\n\n\n\n\nreplicated_frame::Framework\n: Replicated framework\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.UnitCube\n \n \nFunction\n.\n\n\nunit_cube = UnitCube()\n\n\n\n\nThis function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.write_vtk\n \n \nFunction\n.\n\n\nwrite_vtk(box, filename; verbose=true, center_at_origin=false)\nwrite_vtk(framework)\n\n\n\n\nWrite a \nBox\n to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a \nFramework\n is passed, the \nBox\n of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.\n\n\nAppends \".vtk\" extension to \nfilename\n automatically if not passed.\n\n\nArguments\n\n\n\n\nbox::Box\n: a Bravais lattice\n\n\nfilename::AbstractString\n: filename of the .vtk file output (absolute path)\n\n\nframework::Framework\n: A framework containing the crystal structure information\n\n\ncenter_at_origin::Bool\n: center box at origin if true. if false, the origin is the corner of the box.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.inside\n \n \nFunction\n.\n\n\ninside_box = inside(x, box) # true or false\n\n\n\n\nDetermine whether a Cartesian vector \nx\n lays inside a \nBox\n. This works by computing the  fractional coordinates of vector \nx\n and ensuring each lie within the interval \n[0, 1]\n.\n\n\nsource\n\n\n\n\nCrystals\n#\n\n\n#\n\n\nPorousMaterials.Framework\n \n \nType\n.\n\n\nframework = Framework(filename, check_charge_neutrality=true,\n                      net_charge_tol=0.001, check_atom_and_charge_overlap=true,\n                      remove_overlap=false)\nframework = Framework(name, box, atoms, charges)\n\n\n\n\nRead a crystal structure file (.cif or .cssr) and populate a \nFramework\n data structure, or construct a \nFramework\n data structure directly.\n\n\nArguments\n\n\n\n\nfilename::AbstractString\n: the name of the crystal structure file (include \".cif\" or \".cssr\") read from \njoinpath(PorousMaterials.PATH_TO_DATA, \"structures\")\n.\n\n\ncheck_charge_neutrality::Bool\n: check for charge neutrality\n\n\nnet_charge_tol::Float64\n: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.\n\n\ncheck_atom_and_charge_overlap::Bool\n: throw an error if overlapping atoms are detected.\n\n\nremove_overlap::Bool\n: remove identical atoms automatically. Identical atoms are the same element atoms which overlap.\n\n\n\n\nReturns\n\n\n\n\nframework::Framework\n: A framework containing the crystal structure information\n\n\n\n\nAttributes\n\n\n\n\nname::AbstractString\n: name of crystal structure\n\n\nbox::Box\n: unit cell (Bravais Lattice)\n\n\natoms::Atoms\n: list of Atoms in crystal unit cell\n\n\ncharges::Charges\n: list of point charges in crystal unit cell\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.remove_overlapping_atoms_and_charges\n \n \nFunction\n.\n\n\nnew_framework = remove_overlapping_atoms_and_charges(framework, overlap_tol=0.1, verbose=true)\n\n\n\n\nTakes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\natom_overlap_tol::Float64\n: The minimum distance between two atoms that is tolerated\n\n\ncharge_overlap_tol::Float64\n: The minimum distance between two charges that is tolerated\n\n\n\n\nReturns\n\n\n\n\nnew_framework::Framework\n: A new framework where identical atoms have been removed.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.strip_numbers_from_atom_labels!\n \n \nFunction\n.\n\n\nstrip_numbers_from_atom_labels!(framework)\n\n\n\n\nStrip numbers from labels for \nframework.atoms\n. Precisely, for \natom\n in \nframework.atoms\n, find the first number that appears in \natom\n. Remove this number and all following characters from \natom\n. e.g. C12 \u2013\n C    Ba12A_3 \u2013\n Ba\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.chemical_formula\n \n \nFunction\n.\n\n\nformula = chemical_formula(framework, verbose=false)\n\n\n\n\nFind the irreducible chemical formula of a crystal structure.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\nverbose::Bool\n: If \ntrue\n, will print the chemical formula as well\n\n\n\n\nReturns\n\n\n\n\nformula::Dict{Symbol, Int}\n: A dictionary with the irreducible chemical formula of a crystal structure\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.molecular_weight\n \n \nFunction\n.\n\n\nmass_of_framework = molecular_weight(framework)\n\n\n\n\nCalculates the molecular weight of a unit cell of the framework in amu using information stored in \ndata/atomicmasses.csv\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\n\n\nReturns\n\n\n\n\nmass_of_framework::Float64\n: The molecular weight of a unit cell of the framework in amu\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.crystal_density\n \n \nFunction\n.\n\n\n\u03c1 = crystal_density(framework) # kg/m\u00b2\n\n\n\n\nCompute the crystal density of a framework. Pulls atomic masses from \nread_atomic_masses\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\n\n\nReturns\n\n\n\n\n\u03c1::Float64\n: The crystal density of a framework in kg/m\u00b3\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.replicate\n \n \nMethod\n.\n\n\nreplicated_frame = replicate(framework, repfactors)\n\n\n\n\nReplicates the atoms and charges in a \nFramework\n in positive directions to construct a new \nFramework\n. Note \nreplicate(framework, (1, 1, 1))\n returns the same \nFramework\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework to replicate\n\n\nrepfactors::Tuple{Int, Int, Int}\n: The factors by which to replicate the crystal structure in each direction.\n\n\n\n\nReturns\n\n\n\n\nreplicated_frame::Framework\n: Replicated framework\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.charged\n \n \nMethod\n.\n\n\ncharged_flag = charged(framework, verbose=false) # true or false\n\n\n\n\nDetermine if a framework has point charges\n\n\nsource\n\n\n#\n\n\nPorousMaterials.write_cif\n \n \nFunction\n.\n\n\nwrite_cif(framework, filename)\n\n\n\n\nWrite a \nframework::Framework\n to a .cif file with \nfilename::AbstractString\n. If \nfilename\n does not include the .cif extension, it will automatically be added.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.assign_charges\n \n \nFunction\n.\n\n\nnew_framework = assign_charges(framework, charges, net_charge_tol=1e-5)\n\n\n\n\nAssign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of \nframework.atoms\n.\n\n\nIf the framework already has charges, the charges are removed and new charges are added accordingly so that \nframework.atoms.n_atoms == framework.charges.n_charges\n.\n\n\nExamples\n\n\ncharges = Dict(:Ca =\n 2.0, :C =\n 1.0, :H =\n -1.0)\nnew_framework = assign_charges(framework, charges)\n\n\n\n\ncharges = [4.0, 2.0, -6.0] # framework.atoms is length 3\nnew_framework = assign_charges(framework, charges)\n\n\n\n\nArguments\n\n\n\n\nframework::Framework\n: the framework to which we should add charges (not modified in\n\n\n\n\nthis function)\n\n\n\n\ncharges::Union{Dict{Symbol, Float64}, Array{Float64, 1}}\n: a dictionary that returns the\n\n\n\n\ncharge assigned to the species of atom or an array of charges to assign, with order consistent with the order in \nframework.atoms\n (units: electrons).\n\n\n\n\nnet_charge_tol::Float64\n: the net charge tolerated when asserting charge neutrality of\n\n\n\n\nthe resulting framework\n\n\nReturns\n\n\n\n\nnew_framework::Framework\n: a new framework identical to the one passed except charges\n\n\n\n\nare assigned.\n\n\nsource\n\n\n\n\nGrids\n#\n\n\n#\n\n\nPorousMaterials.Grid\n \n \nType\n.\n\n\nData structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box (\nBox\n). Each grid point has data, \ndata\n, associated with it, of type \nT\n, stored in a 3D array.\n\n\nAttributes\n\n\n\n\nbox::Box\n: describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.\n\n\nn_pts::Tuple{Int, Int, Int}\n: number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.\n\n\ndata::Array{T, 3}\n: three dimensional array conaining data associated with each grid point.\n\n\nunits::Symbol\n: the units associated with each data point.\n\n\norigin::Array{Float64, 1}\n: the origin of the grid.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.xf_to_id\n \n \nFunction\n.\n\n\nvoxel_id = xf_to_id(n_pts, xf)\n\n\n\n\nReturns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of \nn_pts[1]\n by \nn_pts[2]\n by \nn_pts[3]\n voxels. Periodic boundary conditions are applied.\n\n\nArguments\n\n\n\n\nn_pts::Tuple{Int, Int, Int}\n: The number of points for each axis in the \nGrid\n\n\nxf::Array{Float64, 1}\n: The fractional coordinates to be converted to an id\n\n\n\n\nReturns\n\n\n\n\nid::Array{Int, 1}\n: The array indices for storing this point in space\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.update_density!\n \n \nFunction\n.\n\n\nupdate_density!(grid, molecule, species)\n\n\n\n\nupdates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a \n./ = num_snapshots\n at the end of the GCMC simulation.\n\n\nArguments\n\n\n\n\ngrid::Grid\n: the grid to be updated\n\n\nmolecules::Array{Molecule, 1}\n: An array of molecules whose positions will  be added to the grid\n\n\nspecies::Symbol\n: The species of atom that can be added to this density grid\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.apply_periodic_boundary_condition!\n \n \nFunction\n.\n\n\napply_periodic_boundary_condition!(molecule)\n\n\n\n\nCheck if the \ncenter_of_mass\n of a \nMolecule\n is outside of a \nBox\n. If so, apply periodic boundary conditions and translate the center of mass of the \nMolecule\n (and its atoms and point charges) so that it is inside of the \nBox\n.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: A molecule we're interested in seeing if its' center of mass falls within \nsimulation_box\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.write_cube\n \n \nFunction\n.\n\n\nwrite_cube(grid, filename, verbose=true)\n\n\n\n\nWrite grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.\n\n\nArguments\n\n\n\n\ngrid::Grid\n: grid with associated data at each grid point.\n\n\nfilename::AbstractString\n: name of .cube file to which we write the grid; this is relative to \nPorousMaterials.PATH_TO_DATA\n/grids/.\n\n\nverbose::Bool\n: print name of file after writing.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.read_cube\n \n \nFunction\n.\n\n\ngrid = read_cube(filename)\n\n\n\n\nRead a .cube file and return a populated \nGrid\n data structure.\n\n\nArguments\n\n\n\n\nfilename::AbstractString\n: name of .cube file to which we write the grid; this is relative to \nPorousMaterials.PATH_TO_DATA\ngrids/.\n\n\n\n\nReturns\n\n\n\n\ngrid::Grid\n: A grid data structure\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.energy_grid\n \n \nFunction\n.\n\n\ngrid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750)\n\n\n\n\nSuperimposes a regular grid of points (regularly spaced in fractional coordinates of the \nframework.box\n) over the unit cell of a crystal, with \nn_gridpts\n dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.\n\n\nThe ensemble average is a Boltzmann average over rotations:  - R T log \u27e8e\u207b\u1d47\u1d41\u27e9\n\n\nArguments\n\n\n\n\nframework::Framework\n: crystal in which we seek to compute an energy grid for a molecule. \ngrid.box\n will be \nframework.box\n.\n\n\nmolecule::Molecule\n: molecule for which we seek an energy grid\n\n\nljforcefield::LJForceField\n: molecular model for computing molecule-framework interactions\n\n\nn_pts::Tuple{Int, Int, Int}=(50,50,50)\n: number of grid points in each fractional coordinate dimension, including endpoints (0, 1)\n\n\nn_rotations::Int\n: number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.\n\n\n\n\nThis is only relevant for molecules that are comprised of more than one Lennard Jones sphere.\n\n\n\n\ntemperature::Float64\n: the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.\n\n\nunits::Symbol\n: either \n:K\n or \n:kJ_mol\n, the units in which the energy should be stored in the returned \nGrid\n.\n\n\ncenter::Bool\n: shift coords of grid so that the origin is the center of the unit cell \nframework.box\n.\n\n\nverbose::Bool=true\n: print some information.\n\n\n\n\nReturns\n\n\n\n\ngrid::Grid\n: A grid data structure containing the potential energy of the system\n\n\n\n\nsource", 
            "title": "Boxes, Crystals, and Grids"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#loading-in-crystal-structure-files", 
            "text": "Place  .cif  and  .cssr  crystal structure files in  data/crystals .  PorousMaterials.jl  currently takes crystals in P1 symmetry only. From here you can start julia and do the following to load a framework and start working with it.  using PorousMaterials\n\nf = Framework( SBMOF-1.cif )  PorousMaterials will then output information about the framework you just loaded:  Name: SBMOF-1.cif\nBravais unit cell of a crystal.\n        Unit cell angles \u03b1 = 90.000000 deg. \u03b2 = 100.897000 deg. \u03b3 = 90.000000 deg.\n        Unit cell dimensions a = 11.619300 \u212b. b = 5.566700 \u212b, c = 22.931200 \u212b\n        Volume of unit cell: 1456.472102 \u212b\u00b3\n\nNumber of atoms = 120\nNumber of charges = 0\nChemical formula: Dict(:H= 8,:S= 1,:Ca= 1,:O= 6,:C= 14)", 
            "title": "Loading in Crystal Structure Files"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#building-blocks-of-porousmaterials-bravais-lattice", 
            "text": "We later apply periodic boundary conditions to mimic a crystal of infinite extent. A  Box  describes a  Bravais lattice .  To make a 10 by 10 by 10 \u212b Bravais lattice with right angles:  box = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2)\n\nbox.a, box.b, box.c # unit cell dimensions (10.0 \u212b)\nbox.\u03b1, box.\u03b2, box.\u03b3 # unit cell angles (1.57... radians)\nbox.\u03a9 # volume (1000.0 \u212b\u00b3)\nbox.f_to_c # fractional to Cartesian coordinate transformation matrix\nbox.c_to_f # Cartesian to fractional coordinate transformation matrix\nbox.reciprocal_lattice # rows are reciprocal lattice vectors  Replicate a box as follows:  box = replicate(box, (2, 2, 2)) # new box replicated 2 by 2 by 2\nbox.a # 20 \u212b", 
            "title": "Building Blocks of PorousMaterials: Bravais lattice"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#building-blocks-of-porousmaterials-porous-crystals", 
            "text": "using PorousMaterials\n\n# read in xtal structure file\nframework = Framework( SBMOF-1.cif )\n\n# access unit cell box\nframework.box\n\n# access Lennard-Jones spheres and point charges comprising the crystal\nframework.atoms\nframework.charges\n\n# remove annoying numbers on the atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# compute crystal density\n\u03c1 = crystal_density(framework) # kg/m3\n\n# compute the chemical formula\ncf = chemical_formula(framework)\n\n# assign charges according to atom type\ncharges = Dict(:Ca =  3.0, :O =  2.0, :C =  -1.0, :S =  7.0, :H =  -1.0)\ncharged_framework = assign_charges(framework, charges)\n\n# replicate   visualize\nframework = replicate(framework, (3, 3, 3))\nwrite_to_xyz(framework,  SBMOF-1.xyz )", 
            "title": "Building Blocks of PorousMaterials: Porous Crystals"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#demo-of-potential-energy-grid", 
            "text": "Superimpose a grid of points about the unit cell of SBMOF-1. Compute the potential energy of xenon at each point and store as a grid.  using PorousMaterials\n\nframework = Framework( SBMOF-1.cif )\nmolecule = Molecule( Xe )\nforcefield = LJForceField( UFF.csv )\n\ngrid = energy_grid(framework, molecule, forcefield,\n    n_pts=(50, 50, 50), units=:kJ_mol) # Grid data structure  Write to a .cube volume file to visualize the potential energy contours.  write_cube(grid,  CH4_in_SBMOF1.cube )", 
            "title": "Demo of Potential Energy Grid"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#boxes", 
            "text": "#  PorousMaterials.Box     Type .  box = Box(a, b, c, \u03b1, \u03b2, \u03b3, volume, f_to_c, c_to_f, reciprocal_lattice)\nbox = Box(a, b, c, \u03b1, \u03b2, \u03b3)\nbox = Box(f_to_c)  Data structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.  Attributes   a,b,c::Float64 : unit cell dimensions (units: Angstroms)  \u03b1,\u03b2,\u03b3::Float64 : unit cell angles (units: radians)  \u03a9::Float64 : volume of the unit cell (units: cubic Angtroms)  f_to_c::Array{Float64,2} : the 3x3 transformation matrix used to map fractional   coordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom   c_to_f::Array{Float64,2} : the 3x3 transformation matrix used to map Cartesian   coordinates to fractional coordinates. units: inverse Angstrom   reciprocal_lattice::Array{Float64, 2} : the  rows  are the reciprocal lattice vectors.   This choice was made (instead of columns) for speed of Ewald Sums.  source  #  PorousMaterials.replicate     Function .  new_box = replicate(original_box, repfactors)  Replicates a  Box  in positive directions to construct a new  Box  representing a supercell. The  original_box  is replicated according to the factors in  repfactors . Note  replicate(original_box, repfactors=(1, 1, 1))  returns same  Box . The new fractional coordinates as described by  f_to_c  and  c_to_f  still \u2208 [0, 1].  Arguments   original_box::Box : The box that you want to replicate  repfactors::Tuple{Int, Int, Int} : The factor you want to replicate the box by   Returns   box::Box : Fully formed Box object   source  replicated_frame = replicate(framework, repfactors)  Replicates the atoms and charges in a  Framework  in positive directions to construct a new  Framework . Note  replicate(framework, (1, 1, 1))  returns the same  Framework .  Arguments   framework::Framework : The framework to replicate  repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction.   Returns   replicated_frame::Framework : Replicated framework   source  #  PorousMaterials.UnitCube     Function .  unit_cube = UnitCube()  This function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.  source  #  PorousMaterials.write_vtk     Function .  write_vtk(box, filename; verbose=true, center_at_origin=false)\nwrite_vtk(framework)  Write a  Box  to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a  Framework  is passed, the  Box  of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.  Appends \".vtk\" extension to  filename  automatically if not passed.  Arguments   box::Box : a Bravais lattice  filename::AbstractString : filename of the .vtk file output (absolute path)  framework::Framework : A framework containing the crystal structure information  center_at_origin::Bool : center box at origin if true. if false, the origin is the corner of the box.   source  #  PorousMaterials.inside     Function .  inside_box = inside(x, box) # true or false  Determine whether a Cartesian vector  x  lays inside a  Box . This works by computing the  fractional coordinates of vector  x  and ensuring each lie within the interval  [0, 1] .  source", 
            "title": "Boxes"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#crystals", 
            "text": "#  PorousMaterials.Framework     Type .  framework = Framework(filename, check_charge_neutrality=true,\n                      net_charge_tol=0.001, check_atom_and_charge_overlap=true,\n                      remove_overlap=false)\nframework = Framework(name, box, atoms, charges)  Read a crystal structure file (.cif or .cssr) and populate a  Framework  data structure, or construct a  Framework  data structure directly.  Arguments   filename::AbstractString : the name of the crystal structure file (include \".cif\" or \".cssr\") read from  joinpath(PorousMaterials.PATH_TO_DATA, \"structures\") .  check_charge_neutrality::Bool : check for charge neutrality  net_charge_tol::Float64 : when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.  check_atom_and_charge_overlap::Bool : throw an error if overlapping atoms are detected.  remove_overlap::Bool : remove identical atoms automatically. Identical atoms are the same element atoms which overlap.   Returns   framework::Framework : A framework containing the crystal structure information   Attributes   name::AbstractString : name of crystal structure  box::Box : unit cell (Bravais Lattice)  atoms::Atoms : list of Atoms in crystal unit cell  charges::Charges : list of point charges in crystal unit cell   source  #  PorousMaterials.remove_overlapping_atoms_and_charges     Function .  new_framework = remove_overlapping_atoms_and_charges(framework, overlap_tol=0.1, verbose=true)  Takes in a framework and returns a new framework with where overlapping atoms and overlapping charges were removed. i.e. if there is an overlapping pair, one in the pair is removed. For any atoms or charges to be removed, the species and charge, respectively, must be identical.  Arguments   framework::Framework : The framework containing the crystal structure information  atom_overlap_tol::Float64 : The minimum distance between two atoms that is tolerated  charge_overlap_tol::Float64 : The minimum distance between two charges that is tolerated   Returns   new_framework::Framework : A new framework where identical atoms have been removed.   source  #  PorousMaterials.strip_numbers_from_atom_labels!     Function .  strip_numbers_from_atom_labels!(framework)  Strip numbers from labels for  framework.atoms . Precisely, for  atom  in  framework.atoms , find the first number that appears in  atom . Remove this number and all following characters from  atom . e.g. C12 \u2013  C    Ba12A_3 \u2013  Ba  Arguments   framework::Framework : The framework containing the crystal structure information   source  #  PorousMaterials.chemical_formula     Function .  formula = chemical_formula(framework, verbose=false)  Find the irreducible chemical formula of a crystal structure.  Arguments   framework::Framework : The framework containing the crystal structure information  verbose::Bool : If  true , will print the chemical formula as well   Returns   formula::Dict{Symbol, Int} : A dictionary with the irreducible chemical formula of a crystal structure   source  #  PorousMaterials.molecular_weight     Function .  mass_of_framework = molecular_weight(framework)  Calculates the molecular weight of a unit cell of the framework in amu using information stored in  data/atomicmasses.csv .  Arguments   framework::Framework : The framework containing the crystal structure information   Returns   mass_of_framework::Float64 : The molecular weight of a unit cell of the framework in amu   source  #  PorousMaterials.crystal_density     Function .  \u03c1 = crystal_density(framework) # kg/m\u00b2  Compute the crystal density of a framework. Pulls atomic masses from  read_atomic_masses .  Arguments   framework::Framework : The framework containing the crystal structure information   Returns   \u03c1::Float64 : The crystal density of a framework in kg/m\u00b3   source  #  PorousMaterials.replicate     Method .  replicated_frame = replicate(framework, repfactors)  Replicates the atoms and charges in a  Framework  in positive directions to construct a new  Framework . Note  replicate(framework, (1, 1, 1))  returns the same  Framework .  Arguments   framework::Framework : The framework to replicate  repfactors::Tuple{Int, Int, Int} : The factors by which to replicate the crystal structure in each direction.   Returns   replicated_frame::Framework : Replicated framework   source  #  PorousMaterials.charged     Method .  charged_flag = charged(framework, verbose=false) # true or false  Determine if a framework has point charges  source  #  PorousMaterials.write_cif     Function .  write_cif(framework, filename)  Write a  framework::Framework  to a .cif file with  filename::AbstractString . If  filename  does not include the .cif extension, it will automatically be added.  source  #  PorousMaterials.assign_charges     Function .  new_framework = assign_charges(framework, charges, net_charge_tol=1e-5)  Assign charges to the atoms present in the framework. Pass a dictionary of charges that place charges according to the species of the atoms or pass an array of charges to assign to each atom, with the order of the array consistent with the order of  framework.atoms .  If the framework already has charges, the charges are removed and new charges are added accordingly so that  framework.atoms.n_atoms == framework.charges.n_charges .  Examples  charges = Dict(:Ca =  2.0, :C =  1.0, :H =  -1.0)\nnew_framework = assign_charges(framework, charges)  charges = [4.0, 2.0, -6.0] # framework.atoms is length 3\nnew_framework = assign_charges(framework, charges)  Arguments   framework::Framework : the framework to which we should add charges (not modified in   this function)   charges::Union{Dict{Symbol, Float64}, Array{Float64, 1}} : a dictionary that returns the   charge assigned to the species of atom or an array of charges to assign, with order consistent with the order in  framework.atoms  (units: electrons).   net_charge_tol::Float64 : the net charge tolerated when asserting charge neutrality of   the resulting framework  Returns   new_framework::Framework : a new framework identical to the one passed except charges   are assigned.  source", 
            "title": "Crystals"
        }, 
        {
            "location": "/manual/boxes_crystals_grids/#grids", 
            "text": "#  PorousMaterials.Grid     Type .  Data structure for a regular [equal spacing between points in each coordinate] grid of points superimposed on a unit cell box ( Box ). Each grid point has data,  data , associated with it, of type  T , stored in a 3D array.  Attributes   box::Box : describes Bravais lattice over which a grid of points is super-imposed. grid points on all faces are included.  n_pts::Tuple{Int, Int, Int} : number of grid points in x, y, z directions. 0 and 1 fractional coordinates are included.  data::Array{T, 3} : three dimensional array conaining data associated with each grid point.  units::Symbol : the units associated with each data point.  origin::Array{Float64, 1} : the origin of the grid.   source  #  PorousMaterials.xf_to_id     Function .  voxel_id = xf_to_id(n_pts, xf)  Returns the indices of the voxel in which it falls when a unit cube is partitioned into a regular grid of  n_pts[1]  by  n_pts[2]  by  n_pts[3]  voxels. Periodic boundary conditions are applied.  Arguments   n_pts::Tuple{Int, Int, Int} : The number of points for each axis in the  Grid  xf::Array{Float64, 1} : The fractional coordinates to be converted to an id   Returns   id::Array{Int, 1} : The array indices for storing this point in space   source  #  PorousMaterials.update_density!     Function .  update_density!(grid, molecule, species)  updates the density grid based on an array of molecules. If a molecule doesn't match the specified species it won't be added to the density grid. This function doesn't calculate the actual densities, it will need a  ./ = num_snapshots  at the end of the GCMC simulation.  Arguments   grid::Grid : the grid to be updated  molecules::Array{Molecule, 1} : An array of molecules whose positions will  be added to the grid  species::Symbol : The species of atom that can be added to this density grid   source  #  PorousMaterials.apply_periodic_boundary_condition!     Function .  apply_periodic_boundary_condition!(molecule)  Check if the  center_of_mass  of a  Molecule  is outside of a  Box . If so, apply periodic boundary conditions and translate the center of mass of the  Molecule  (and its atoms and point charges) so that it is inside of the  Box .  Arguments   molecule::Molecule : A molecule we're interested in seeing if its' center of mass falls within  simulation_box   source  #  PorousMaterials.write_cube     Function .  write_cube(grid, filename, verbose=true)  Write grid to a .cube file format. This format is described here: http://paulbourke.net/dataformats/cube/ The atoms of the unit cell are not printed in the .cube. Instead, use .xyz files to also visualize atoms.  Arguments   grid::Grid : grid with associated data at each grid point.  filename::AbstractString : name of .cube file to which we write the grid; this is relative to  PorousMaterials.PATH_TO_DATA /grids/.  verbose::Bool : print name of file after writing.   source  #  PorousMaterials.read_cube     Function .  grid = read_cube(filename)  Read a .cube file and return a populated  Grid  data structure.  Arguments   filename::AbstractString : name of .cube file to which we write the grid; this is relative to  PorousMaterials.PATH_TO_DATA grids/.   Returns   grid::Grid : A grid data structure   source  #  PorousMaterials.energy_grid     Function .  grid = energy_grid(framework, molecule, ljforcefield; n_pts=(50, 50, 50), temperature=298.0, n_rotations=750)  Superimposes a regular grid of points (regularly spaced in fractional coordinates of the  framework.box ) over the unit cell of a crystal, with  n_gridpts  dictating the number of grid points in the a, b, c directions (including 0 and 1 fractional coords). The fractional coordinates 0 and 1 are included in the grid, although they are redundant. Then, at each grid point, calculate the ensemble average potential energy of the molecule when its mass is centered at that point. The average is taken over Boltzmann-weighted rotations.  The ensemble average is a Boltzmann average over rotations:  - R T log \u27e8e\u207b\u1d47\u1d41\u27e9  Arguments   framework::Framework : crystal in which we seek to compute an energy grid for a molecule.  grid.box  will be  framework.box .  molecule::Molecule : molecule for which we seek an energy grid  ljforcefield::LJForceField : molecular model for computing molecule-framework interactions  n_pts::Tuple{Int, Int, Int}=(50,50,50) : number of grid points in each fractional coordinate dimension, including endpoints (0, 1)  n_rotations::Int : number of random rotations to conduct in a Monte Carlo simulation for finding the free energy of a molecule centered at a given grid point.   This is only relevant for molecules that are comprised of more than one Lennard Jones sphere.   temperature::Float64 : the temperature at which to compute the free energy for molecules where rotations are required. Lower temperatures overemphasize the minimum potential energy rotational conformation at that point.  units::Symbol : either  :K  or  :kJ_mol , the units in which the energy should be stored in the returned  Grid .  center::Bool : shift coords of grid so that the origin is the center of the unit cell  framework.box .  verbose::Bool=true : print some information.   Returns   grid::Grid : A grid data structure containing the potential energy of the system   source", 
            "title": "Grids"
        }, 
        {
            "location": "/manual/molecules/", 
            "text": "Loading in Molecule Files\n#\n\n\nMolecule input files are stored in \ndata/molecules\n. Each molecule possesses its own directory and contains two files: \npoint_charges.csv\n and \nlennard_jones_spheres.csv\n, comma-separated-value files describing the point charges and Lennard Jones spheres, respectively, comprising the molecule. Only rigid molecules are currently supported. Units of length are in Angstrom; units of charges are electrons.\n\n\nusing PorousMaterials\n\nm = Molecule(\nCO2\n)\n\n\n\n\nPorousMaterials will then output information about the molecule you just loaded:\n\n\nMolecule species: CO2\nCenter of mass (fractional coords): [0.0, 0.0, 0.0]\nAtoms:\n\n        atom = C_CO2, xf = [0.000, 0.000, 0.000]\n        atom = O_CO2, xf = [-1.160, 0.000, 0.000]\n        atom = O_CO2, xf = [1.160, 0.000, 0.000]\nPoint charges:\n        charge = 0.700000, xf = [0.000, 0.000, 0.000]\n        charge = -0.350000, xf = [-1.160, 0.000, 0.000]\n        charge = -0.350000, xf = [1.160, 0.000, 0.000]\n\n\n\n\n\n\nBuilding Blocks of PorousMaterials: Molecules\n#\n\n\nmolecule = Molecule(\nCO2\n) # fractional coords in terms of unit cube box\n\n# access Lennard-Jones spheres \n point charges that comprise molecule\nmolecule.atoms\nmolecule.charges\n\n# translate to [1.0, 2.0, 3.0] fractional coordinates\ntranslate_to!(molecule, [1.0, 2.0, 3.0])\n\n# translate by [0.1, 0.0, 0.0] fractional coordinates\ntranslate_by!(molecule, [0.1, 0.0, 0.0])\n\n# conduct a uniform random rotation\nrotate!(molecule, UnitCube()) # b/c now fractional coords defined in context of a unit cube\n\n\n\n\n\n\nMolecules\n#\n\n\n#\n\n\nPorousMaterials.Molecule\n \n \nType\n.\n\n\nData structure for a molecule/adsorbate.\n\n\nAttributes\n\n\n\n\nspecies::Symbol\n: Species of molecule, e.g. \n:CO2\n\n\natoms::Atoms\n: array of Lennard-Jones spheres comprising the molecule\n\n\ncharges::Charges\n: array of point charges comprising the molecule\n\n\nxf_com::Array{Float64, 1}\n: center of mass of the molecule in fractional coordinates\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.n_atoms\n \n \nFunction\n.\n\n\nnum_atoms = n_atoms(molecules)\n\n\n\n\ncalculates the total number of atoms in an array of molecules\n\n\nArguments\n\n\n\n\nmolecule::Array{Molecule, 1}\n: The molecules to count the number of atoms in\n\n\n\n\nReturns\n\n\n\n\nThe total number of atoms in the molecules passed in\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.translate_to!\n \n \nFunction\n.\n\n\ntranslate_to!(molecule, xf)\ntranslate_to!(molecule, x, box)\n\n\n\n\nTranslate a molecule a molecule to point \nxf\n in fractional coordinate space or to \nx\n in Cartesian coordinate space. For the latter, a unit cell box is required for context. The molecule is translated such that its center of mass is at \nxf\n/x`.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule which will be translated to \nxf\n\n\nxf::Array{Float64, 1}\n: A vector containing the coordinates of the final destination of the molecule\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.rotate!\n \n \nFunction\n.\n\n\nrotate!(molecule, box)\n\n\n\n\nConduct a random rotation of the molecule about its center of mass. The box is needed because the molecule contains only its fractional coordinates.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule which will be subject to a random rotation\n\n\nbox::Box\n: The molecule only contains fractional coordinates, so the box is needed for a correct rotation\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.rotation_matrix\n \n \nMethod\n.\n\n\nr = rotation_matrix()\n\n\n\n\nGenerate a 3x3 random rotation matrix \nr\n such that when a point \nx\n is rotated using this rotation matrix via \nr * x\n, this point \nx\n is placed at a uniform random distributed position on the surface of a sphere of radius \nnorm(x)\n. See James Arvo. Fast Random Rotation Matrices.\n\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\n\nReturns\n\n\n\n\nr::Array{Float64, 2}\n: A 3x3 random rotation matrix\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.rotation_matrix\n \n \nMethod\n.\n\n\nR = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u\nR = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim`\n\n\n\n\nDetermine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis \nu\n.\n\n\nSee \nWikipedia\n.\n\n\nArguments\n\n\n\n\n\u03b8::Float64\n: angle to rotate about an axis, in radians\n\n\nu::Array{Float64, 1}\n: axis about which to rotate\n\n\ndim::Int\n: 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.\n\n\nassume_unit_vector::Bool\n: assume \nu\n is a unit vector; otherwise, \nu\n will be normalized\n\n\n\n\ninternal to this function.\n\n\nReturns\n\n\n\n\nR::Array{Float64, 2}\n: 3D rotation matrix. so \nR * x\n will rotate vector \nx\n as desired.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.rand_point_on_unit_sphere\n \n \nFunction\n.\n\n\nu = rand_point_on_unit_sphere()\n\n\n\n\nGenerate a unit vector with a random orientation.\n\n\nReturns\n\n\n\n\nu::Array{Float64, 1}\n: A unit vector with a random orientation\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.charged\n \n \nMethod\n.\n\n\ncharged_flag = charged(molecule, verbose=false)\n\n\n\n\nDetermine if a molecule has point charges\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule which will be checked for charges\n\n\nverbose::Bool\n: Will print result if \ntrue\n\n\n\n\nReturns\n\n\n\n\ncharged_flag::Bool\n: \ntrue\n if molecule is charged, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n\n\nMolecular Movement\n#\n\n\n#\n\n\nPorousMaterials.insert_molecule!\n \n \nFunction\n.\n\n\ninsert_molecule!(molecules, box, template)\n\n\n\n\nInserts an additional adsorbate molecule into the simulation box using the template provided. The center of mass of the molecule is chosen at a uniform random position in the simulation box. A uniformly random orientation of the molecule is chosen by rotating about the center of mass.\n\n\nArguments\n\n\n\n\nmolecules::Array{Molecule, 1}\n: An array of Molecule objects\n\n\nbox::Box\n: The simulation box\n\n\ntemplate::Molecule\n: A template molecule used as reference when inserting molecules\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.delete_molecule!\n \n \nFunction\n.\n\n\ndelete_molecule!(molecule_id, molecules)\n\n\n\n\nRemoves a random molecule from the current molecules in the framework. molecule_id decides which molecule will be deleted, for a simulation, it must be a randomly generated value\n\n\nArguments\n\n\n\n\nmolecule_id::Int\n: The molecule ID is used to determine which molecule in \nmolecules\n should be removed\n\n\nmolecules::Array{Molecule, 1}\n: An array of Molecule objects\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.translate_molecule!\n \n \nFunction\n.\n\n\ntranslate_molecule!(molecule, box)\n\n\n\n\nPerturbs the Cartesian coordinates of a molecule about its center of mass by a random vector of max length \u03b4. Applies periodic boundary conditions to keep the molecule inside the simulation box. Returns a deep copy of the old molecule in case it needs replaced if the Monte Carlo proposal is rejected.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule we want to perturb\n\n\nbox::Box\n: The simulation box\n\n\n\n\nReturns\n\n\n\n\nold_molecule::Molecule\n: The old molecule in case the MC proposal is rejected\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.reinsert_molecule!\n \n \nFunction\n.\n\n\nreinsert_molecule(molecule, box)\n\n\n\n\nMove molecule to a new center of mass randomly distrubted in the unit cell and choose a random orientation for it. Return a deep copy of the starting molecule for possible restoration. This MC move can be viewed as a more aggressive \ntranslate_molecule!\n.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule we want to perturb\n\n\nbox::Box\n: The simulation box\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.rotatable\n \n \nFunction\n.\n\n\nneed_to_rotate = rotatable(molecule)\n\n\n\n\nDetermines whether or not a given molecule needs to be rotated. For example, rotating a single atom isn't necessary.\n\n\nArguments\n\n\n\n\nmolecule::Molecule\n: The molecule being tested. This function determines if a   rotation of this molecule will do anything.\n\n\n\n\nReturns\n\n\n\n\nis_rotatable::Bool\n: A boolean describing whether or not rotating the molecule   will alter its interactions with other molecules\n\n\n\n\nsource", 
            "title": "Molecules"
        }, 
        {
            "location": "/manual/molecules/#loading-in-molecule-files", 
            "text": "Molecule input files are stored in  data/molecules . Each molecule possesses its own directory and contains two files:  point_charges.csv  and  lennard_jones_spheres.csv , comma-separated-value files describing the point charges and Lennard Jones spheres, respectively, comprising the molecule. Only rigid molecules are currently supported. Units of length are in Angstrom; units of charges are electrons.  using PorousMaterials\n\nm = Molecule( CO2 )  PorousMaterials will then output information about the molecule you just loaded:  Molecule species: CO2\nCenter of mass (fractional coords): [0.0, 0.0, 0.0]\nAtoms:\n\n        atom = C_CO2, xf = [0.000, 0.000, 0.000]\n        atom = O_CO2, xf = [-1.160, 0.000, 0.000]\n        atom = O_CO2, xf = [1.160, 0.000, 0.000]\nPoint charges:\n        charge = 0.700000, xf = [0.000, 0.000, 0.000]\n        charge = -0.350000, xf = [-1.160, 0.000, 0.000]\n        charge = -0.350000, xf = [1.160, 0.000, 0.000]", 
            "title": "Loading in Molecule Files"
        }, 
        {
            "location": "/manual/molecules/#building-blocks-of-porousmaterials-molecules", 
            "text": "molecule = Molecule( CO2 ) # fractional coords in terms of unit cube box\n\n# access Lennard-Jones spheres   point charges that comprise molecule\nmolecule.atoms\nmolecule.charges\n\n# translate to [1.0, 2.0, 3.0] fractional coordinates\ntranslate_to!(molecule, [1.0, 2.0, 3.0])\n\n# translate by [0.1, 0.0, 0.0] fractional coordinates\ntranslate_by!(molecule, [0.1, 0.0, 0.0])\n\n# conduct a uniform random rotation\nrotate!(molecule, UnitCube()) # b/c now fractional coords defined in context of a unit cube", 
            "title": "Building Blocks of PorousMaterials: Molecules"
        }, 
        {
            "location": "/manual/molecules/#molecules", 
            "text": "#  PorousMaterials.Molecule     Type .  Data structure for a molecule/adsorbate.  Attributes   species::Symbol : Species of molecule, e.g.  :CO2  atoms::Atoms : array of Lennard-Jones spheres comprising the molecule  charges::Charges : array of point charges comprising the molecule  xf_com::Array{Float64, 1} : center of mass of the molecule in fractional coordinates   source  #  PorousMaterials.n_atoms     Function .  num_atoms = n_atoms(molecules)  calculates the total number of atoms in an array of molecules  Arguments   molecule::Array{Molecule, 1} : The molecules to count the number of atoms in   Returns   The total number of atoms in the molecules passed in   source  #  PorousMaterials.translate_to!     Function .  translate_to!(molecule, xf)\ntranslate_to!(molecule, x, box)  Translate a molecule a molecule to point  xf  in fractional coordinate space or to  x  in Cartesian coordinate space. For the latter, a unit cell box is required for context. The molecule is translated such that its center of mass is at  xf /x`.  Arguments   molecule::Molecule : The molecule which will be translated to  xf  xf::Array{Float64, 1} : A vector containing the coordinates of the final destination of the molecule   source  #  PorousMaterials.rotate!     Function .  rotate!(molecule, box)  Conduct a random rotation of the molecule about its center of mass. The box is needed because the molecule contains only its fractional coordinates.  Arguments   molecule::Molecule : The molecule which will be subject to a random rotation  box::Box : The molecule only contains fractional coordinates, so the box is needed for a correct rotation   source  #  PorousMaterials.rotation_matrix     Method .  r = rotation_matrix()  Generate a 3x3 random rotation matrix  r  such that when a point  x  is rotated using this rotation matrix via  r * x , this point  x  is placed at a uniform random distributed position on the surface of a sphere of radius  norm(x) . See James Arvo. Fast Random Rotation Matrices.  https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf  Returns   r::Array{Float64, 2} : A 3x3 random rotation matrix   source  #  PorousMaterials.rotation_matrix     Method .  R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u\nR = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim`  Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis  u .  See  Wikipedia .  Arguments   \u03b8::Float64 : angle to rotate about an axis, in radians  u::Array{Float64, 1} : axis about which to rotate  dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.  assume_unit_vector::Bool : assume  u  is a unit vector; otherwise,  u  will be normalized   internal to this function.  Returns   R::Array{Float64, 2} : 3D rotation matrix. so  R * x  will rotate vector  x  as desired.   source  #  PorousMaterials.rand_point_on_unit_sphere     Function .  u = rand_point_on_unit_sphere()  Generate a unit vector with a random orientation.  Returns   u::Array{Float64, 1} : A unit vector with a random orientation   source  #  PorousMaterials.charged     Method .  charged_flag = charged(molecule, verbose=false)  Determine if a molecule has point charges  Arguments   molecule::Molecule : The molecule which will be checked for charges  verbose::Bool : Will print result if  true   Returns   charged_flag::Bool :  true  if molecule is charged,  false  otherwise   source", 
            "title": "Molecules"
        }, 
        {
            "location": "/manual/molecules/#molecular-movement", 
            "text": "#  PorousMaterials.insert_molecule!     Function .  insert_molecule!(molecules, box, template)  Inserts an additional adsorbate molecule into the simulation box using the template provided. The center of mass of the molecule is chosen at a uniform random position in the simulation box. A uniformly random orientation of the molecule is chosen by rotating about the center of mass.  Arguments   molecules::Array{Molecule, 1} : An array of Molecule objects  box::Box : The simulation box  template::Molecule : A template molecule used as reference when inserting molecules   source  #  PorousMaterials.delete_molecule!     Function .  delete_molecule!(molecule_id, molecules)  Removes a random molecule from the current molecules in the framework. molecule_id decides which molecule will be deleted, for a simulation, it must be a randomly generated value  Arguments   molecule_id::Int : The molecule ID is used to determine which molecule in  molecules  should be removed  molecules::Array{Molecule, 1} : An array of Molecule objects   source  #  PorousMaterials.translate_molecule!     Function .  translate_molecule!(molecule, box)  Perturbs the Cartesian coordinates of a molecule about its center of mass by a random vector of max length \u03b4. Applies periodic boundary conditions to keep the molecule inside the simulation box. Returns a deep copy of the old molecule in case it needs replaced if the Monte Carlo proposal is rejected.  Arguments   molecule::Molecule : The molecule we want to perturb  box::Box : The simulation box   Returns   old_molecule::Molecule : The old molecule in case the MC proposal is rejected   source  #  PorousMaterials.reinsert_molecule!     Function .  reinsert_molecule(molecule, box)  Move molecule to a new center of mass randomly distrubted in the unit cell and choose a random orientation for it. Return a deep copy of the starting molecule for possible restoration. This MC move can be viewed as a more aggressive  translate_molecule! .  Arguments   molecule::Molecule : The molecule we want to perturb  box::Box : The simulation box   source  #  PorousMaterials.rotatable     Function .  need_to_rotate = rotatable(molecule)  Determines whether or not a given molecule needs to be rotated. For example, rotating a single atom isn't necessary.  Arguments   molecule::Molecule : The molecule being tested. This function determines if a   rotation of this molecule will do anything.   Returns   is_rotatable::Bool : A boolean describing whether or not rotating the molecule   will alter its interactions with other molecules   source", 
            "title": "Molecular Movement"
        }, 
        {
            "location": "/manual/atomic_interactions/", 
            "text": "Loading in Forcefield Files\n#\n\n\nLennard-Jones forcefield parameters are stored in comma-separated-value format in \ndata/forcefields/\n.\n\n\nInteraction of an adsorbate with the framework is modeled as pair-wise additive and with Lennard-Jones potentials of the form:\n\n\nV(r) = 4 * epsilon * [ x ^ 12 - x ^ 6 ]\n, where \nx = sigma / r\n\n\nThe Lennard Jones force field input files, e.g. \nUFF.csv\n contain a list of pure (i.e. X-X, where X is an atom) sigmas and epsilons in units Angstrom and Kelvin, respectively. Note that, e.g., in the UFF paper, the Lennard Jones potential is written in a different form and thus parameters need to be converted to correspond to the functional form used in \nPorousMaterials.jl\n.\n\n\nusing PorousMaterials\n\nljff = LJForceField(\nUFF.csv\n)\n\n\n\n\nPorousMaterials will the output information about the forcefield file you just loaded:\n\n\n    Force field: UFF.csv\n    Number of atoms included: 106\n    Cut-off radius (\u212b) = 14.0    \n\n\n\n\nThis also prints all of the atoms included in the loaded forcefield with their given \u03f5 and \u03c3. This was excluded because it would use too much space on this page.\n\n\n\n\nBuilding Blocks of PorousMaterials: Lennard-Jones forcefields\n#\n\n\n# read in Lennard-Jones force field parameters from the Universal Force Field\nforcefield = LJForceField(\nUFF.csv\n, cutoffradius=14.0, mixing_rules=\nLorentz-Berthelot\n)\n\n# access the Lennard-Jones epsilon \n sigma for Xe\nforcefield.pure_\u03f5[:Xe] # K\nforcefield.pure_\u03c3[:Xe] # \u212b\n\n# access the Lennard-Jones epsilon \n sigma for Xe-C interactions\nforcefield.\u03f5[:Xe][:C] # K                                                                 \nforcefield.\u03c3\u00b2[:Xe][:C] # \u212b (store \u03c3\u00b2 for faster computation)\n\n\n\n\n\n\nBuilding Blocks of PorousMaterials: Potential energies\n#\n\n\nFirst, set the fractional coordinates of the molecule in the context of some unit cell box.\n\n\n# molecule in a framework\nset_fractional_coords!(molecule, framework.box)\n\n# molecule in a 10 by 10 by 10 cube\nbox = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) # make a box\nset_fractional_coords!(molecule, box)\n\n\n\n\n\n\nPotential Energies: Van der Waals\n#\n\n\nWhat is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at \n[0.0, 1.0, 3.0]\n Cartesian coordinates using the UFF as a molecular model?\n\n\nusing PorousMaterials\n\nframework = Framework(\nSBMOF-1.cif\n)\n\nforcefield = LJForceField(\nUFF.csv\n)\n\nmolecule = Molecule(\nXe\n)\nset_fractional_coords!(molecule, framework.box)\n\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\n\nenergy = vdw_energy(framework, molecule, forcefield) # K\n\n\n\n\n\n\nPotential Energies: Electrostatics\n#\n\n\nWhat is the electrostatic potential energy of a CO\n2\n adsorbate inside CAXVII_clean at \n[0.0, 1.0, 0.0]\n Cartesian coordinate?\n\n\nusing PorousMaterials\n\nframework = Framework(\nCAXVII_clean.cif\n) # has charges\n\nmolecule = Molecule(\nCO2\n)\nset_fractional_coords!(molecule, framework.box)\n\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\n\nrotate!(molecule, framework.box) # let's give it a random orientation\n\n# this is for speed. pre-compute k-vectors and allocate memory\neparams, kvectors, eikar, eikbr, eikcr = setup_Ewald_sum(12.0, framework.box)\n\nenergy = electrostatic_potential_energy(framework, molecule, eparams, kvectors, eikar, eikbr, eikcr)\n\n\n\n\n\n\nPotential Energies: Equations of state\n#\n\n\nCalculate fugacity, density of methane at 298 K and 65 bar using the Peng-Robinson EOS:\n\n\ngas = PengRobinsonGas(:CH4)\nprops = calculate_properties(gas, 298.0, 65.0) # dictionary of properties\nprops[\nfugacity coefficient\n] # 0.8729\n\n\n\n\nPass \neos=:PengRobinson\n to \ngcmc_simulation\n to automatically convert pressure to fugacity using the Peng-Robinson equation of state.\n\n\n\n\nForcefields\n#\n\n\n#\n\n\nPorousMaterials.LJForceField\n \n \nType\n.\n\n\nData structure for a Lennard Jones forcefield.\n\n\nAttributes\n\n\n\n\nname::String\n: name of forcefield; correponds to filename\n\n\npure_\u03c3::Dict{Symbol, Float64}\n: Dictionary that returns Lennard-Jones \u03c3 of an X-X interaction, where X is an atom. (units: Angstrom)\n\n\npure_\u03f5::Dict{Symbol, Float64}\n: Dictionary that returns Lennard-Jones \u03f5 of an X-X interaction, where X is an atom. (units: K)\n\n\n\u03c3\u00b2::Dict{Symbol, Dict{Symbol, Float64}}\n: Lennard Jones \u03c3\u00b2 (units: Angstrom\u00b2) for cross-interactions. Example use is \nsigmas_squared[:He][:C]\n\n\n\u03f5::Dict{Symbol, Dict{Symbol, Float64}}\n: Lennard Jones \u03f5 (units: K) for cross-interactions. Example use is \nepsilons[:He][:C]\n\n\ncutoffradius_squared::Float64\n: The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom\u00b2). We store \u03c3\u00b2 to speed up computations, which involve \u03c3\u00b2, not \u03c3.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.replication_factors\n \n \nFunction\n.\n\n\nrepfactors = replication_factors(unitcell, cutoffradius)\n\n\n\n\nFind the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied.\n\n\nA non-replicated supercell has 1 as the replication factor in each dimension (\nrepfactors = (1, 1, 1)\n).\n\n\nArguments\n\n\n\n\nunitcell::Box\n: The unit cell of the framework\n\n\ncutoff_radius::Float64\n: Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom)\n\n\n\n\nReturns\n\n\n\n\nrepfactors::Tuple{Int, Int, Int}\n: The replication factors in the a, b, c directions\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.check_forcefield_coverage\n \n \nFunction\n.\n\n\ncheck_forcefield_coverage(framework, ljforcefield)\ncheck_forcefield_coverage(molecule, ljforcefield)\n\n\n\n\nCheck that the force field contains parameters for every atom present in a framework or molecule. Will print out which atoms are missing.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The framework containing the crystal structure information\n\n\nmolecule::Molecule\n: A molecule object\n\n\nljforcefield::LJForceField\n: A Lennard Jones forcefield object containing information on atom interactions\n\n\n\n\nReturns\n\n\n\n\nall_covered::Bool\n: Returns true if all atoms in the \nframework\n are also included in \nljforcefield\n. False otherwise\n\n\n\n\nsource\n\n\n\n\nPotential Energy\n#\n\n\n#\n\n\nPorousMaterials.PotentialEnergy\n \n \nType\n.\n\n\npe = PotentialEnergy()\n\n\n\n\nData structure to store potential energy, partitioned into van der Waals (\nenergy.vdw\n) and electrostatic (\nenergy.coulomb\n) interactions, both \nFloat64\n.\n\n\nThis returns a PotentialEnergy data type where the vdw and coulomb attributes are set to 0.0\n\n\nReturns\n\n\n\n\npe::PotentialEnergy\n: A structure containing van der Waals and electrostatic energies, initialized at 0.0\n\n\n\n\nAttributes\n\n\n\n\nvdw::Float64\n: The potential energy contributions from Van der Waals interactions\n\n\ncoulomb::Float64\n: The potential energy contributions from electrostatic interactions\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.SystemPotentialEnergy\n \n \nType\n.\n\n\nsystem_potential_energy = SystemPotentialEnergy()\n\n\n\n\nData structure to facilitate storing/partitioning potential energy of a system. It stores the potential energy from guest-host and guest-guest interactions separately.\n\n\nThis initializes guest\nhost and guest\nguest with PotentialEnergy(), so when it is created the total energy recorded is 0.0\n\n\nReturns\n\n\n\n\nsystem_potential_energy::SystemPotentialEnergy\n: A structure containing the potential energy of the system,   broken down into guest-guest and guest-host interactions\n\n\n\n\nAttributes\n\n\n\n\nguest_host::PotentialEnergy\n: The total potential energy from all guest-host   interactions in the system\n\n\nguest_guest::PotentialEnergy\n: The total potential energy from all guest-guest   interactions in the system\n\n\n\n\nsource\n\n\n\n\nNearest Image Conventions\n#\n\n\n#\n\n\nPorousMaterials.nearest_image!\n \n \nFunction\n.\n\n\nnearest_image!(dxf)\n\n\n\n\nApplies the nearest image convention on a vector \ndxf\n between two atoms in fractional space; modifies \ndxf\n for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space.\n\n\nWarning: this assumes the two molecules are in the box described by fractional coords [0, 1]\u00b3.\n\n\nArguments\n\n\n\n\ndxf::Array{Float64}\n: A vector between two atoms in fractional space\n\n\n\n\nsource\n\n\n\n\nElectrostatics Energy\n#\n\n\n#\n\n\nPorousMaterials.Eikr\n \n \nType\n.\n\n\neikr = Eikr(eikar, eikbr, eikcr)\n\n\n\n\nmutable struct for holding the eikr vectors\n\n\nAttributes\n\n\n\n\neikar::OffsetArray{Complex{Float64}}\n: array for storing e^{i * ka \u22c5 r}; has indices   0:kreps[1] and corresponds to recip. vectors in a-direction\n\n\neikbr::OffsetArray{Complex{Float64}}\n: array for storing e^{i * kb \u22c5 r}; has indices   -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction\n\n\neikcr::OffsetArray{Complex{Float64}}\n: array for storing e^{i * kc \u22c5 r}; has indices   -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.electrostatic_potential_energy\n \n \nFunction\n.\n\n\n\u03d5 = electrostatic_potential_energy(framework, molecule, eparams, eikr)\n\n\n\n\nCompute the electrostatic potential energy of a molecule inside a framework.\n\n\nThe electrostatic potential is created by the point charges assigned to the framework atoms in \nframework.charges\n. Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at \ndifferences\n in energy in a Monte Carlo simulation.\n\n\nWarning: it is assumed that the framework is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in \neparams.sr_cutoff_r\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: Crystal structure (see \nframework.charges\n for charges)\n\n\nmolecule::Molecule\n: The molecule being compared to the atoms in the framework.\n\n\neparams::EwaldParams\n: data structure containing Ewald summation settings\n\n\neikr::Eikr\n: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\nReturns\n\n\n\n\npot::EwaldSum\n: Electrostatic potential between \nframework\n and \nmolecule\n (units: K)\n\n\n\n\nsource\n\n\n\u03d5 = electrostatic_potential_energy(molecules, eparams, box, eikr)\n\n\n\n\nCompute the electrostatic potential energy of a system comprised of an array of \nMolecule\ns.\n\n\nThe EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive.\n\n\nReturns an \nEwaldSum\n type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (\u03d5.sr, \u03d5.lr, \u03d5.self, \u03d5.intra).\n\n\nUnits of energy: Kelvin\n\n\nArguments\n\n\n\n\nmolecules::Array{Molecules, 1}\n: array of molecules comprising the system.\n\n\neparams::EwaldParams\n: data structure containing Ewald summation settings\n\n\nbox::Box\n: the box the energy is being computed in\n\n\neikr::Eikr\n: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\nReturns\n\n\n\n\n\u03d5::GGEwaldSum\n: The total electrostatic potential energy\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.precompute_kvec_wts\n \n \nFunction\n.\n\n\nkvectors = precompute_kvec_wts(kreps, box, \u03b1, max_mag_k_sqrd=Inf)\n\n\n\n\nFor speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry:     cos(-k\u22c5(x-x\u1d62)) + cos(k\u22c5(x-x\u1d62)) = 2 cos(k\u22c5(x-x\u1d62))\n\n\nIf \nmax_mag_k_sqrd\n is passed, k-vectors with a magnitude greater than \nmax_mag_k_sqrd\n are not included.\n\n\nArguments\n\n\n\n\nkreps::Tuple{Int, Int, Int}\n: number of k-vector replications required in a, b, c\n\n\nbox::Box\n: the simulation box containing the reciprocal lattice.\n\n\n\u03b1::Float64\n: Ewald sum convergence parameter (units: inverse \u212b)\n\n\nmax_mag_k_sqrd::Float64\n: cutoff for |k|\u00b2 in Fourier sum; if passed, do not include\n\n\n\n\nk-vectors with magnitude squared greater than this.\n\n\nReturns\n\n\n\n\nkvectors::Array{Kvector, 1}\n: array of k-vectors to include in the Fourier sum and their\n\n\n\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.setup_Ewald_sum\n \n \nFunction\n.\n\n\neparams = setup_Ewald_sum(box, sr_cutoff_r; \u03f5=1e-6, verbose=false)\n\n\n\n\nGiven the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information.\n\n\nAlso, pre-compute weights on k-vector contributions to Ewald sum in Fourier space.\n\n\nAlso, allocate OffsetArrays for storing e^{i * k \u22c5 r} where r = x - x\u2c7c and k is a reciprocal lattice vector.\n\n\nArguments\n\n\n\n\nbox::Box\n: the simulation box containing the reciprocal lattice.\n\n\nsr_cutoff_r::Float64\n: cutoff-radius (units: \u212b) for short-range contributions to Ewald\n\n\n\u03f5::Float64\n: desired level of precision. Typical value is 1e-6, but this does not\n\n\nverbose::Bool\n: If \ntrue\n will print results\n\n\n\n\nReturns\n\n\n\n\neparams::EwaldParams\n: data structure containing Ewald summation settings\n\n\n\n\ncorresponding weights indicating the contribution to the Fourier sum.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.total_electrostatic_potential_energy\n \n \nFunction\n.\n\n\ntotal_\u03d5 = total_electrostatic_potential_energy(molecules, eparams, box, eikr)\n\n\n\n\nCalculates the total electrostatic potential energy of an array of \nMolecule\ns using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this\n\n\nArguments\n\n\n\n\nmolecules::Array{Molecule, 1}\n: The molecules comprising the system.\n\n\neparams::EwaldParams\n: data structure containing Ewald summation settings\n\n\nbox::Box\n: The box the energy is being computed in.\n\n\neikr::Eikr\n: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\nReturns\n\n\n\n\n\u03d5::GGEwaldSum\n: The total electrostatic potential energy\n\n\n\n\nsource\n\n\ntotal_\u03d5 = total_electrostatic_potential_energy(framework, molecules, eparams, eikr)\n\n\n\n\nExplanation of total\nelectrostatic\npotential_energy that uses framework\n\n\nArguments\n\n\n\n\nframework::Framework\n: Crystal structure (see \nframework.charges\n for charges)\n\n\nmolecules::Array{Molecule, 1}\n: The molecules comprising the system.\n\n\neparams::EwaldParams\n: data structure containing Ewald summation settings\n\n\neikr::Eikr\n: Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.\n\n\n\n\nsource\n\n\n\n\nVan der Waals Energy\n#\n\n\n#\n\n\nPorousMaterials.lennard_jones\n \n \nFunction\n.\n\n\nenergy = lennard_jones(r\u00b2, \u03c3\u00b2, \u03f5)  (units: Kelvin)\n\n\n\n\nCalculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. \u03c3 and \u03f5 are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of \u03f5 are).\n\n\nArguments\n\n\n\n\nr\u00b2::Float64\n: distance between two (pseudo)atoms in question squared (Angstrom\u00b2)\n\n\n\u03c3\u00b2::Float64\n: sigma parameter in Lennard Jones potential squared (units: Angstrom\u00b2)\n\n\n\u03f5::Float64\n: epsilon parameter in Lennard Jones potential (units: Kelvin)\n\n\n\n\nReturns\n\n\n\n\nenergy::Float64\n: Lennard Jones potential energy\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.vdw_energy\n \n \nFunction\n.\n\n\nenergy = vdw_energy(framework, molecule, ljforcefield)\n\n\n\n\nCalculates the van der Waals interaction energy between a molecule and a framework. Applies the nearest image convention to find the closest replicate of a specific atom.\n\n\nWARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See \nreplicate\n.\n\n\nArguments\n\n\n\n\nframework::Framework\n: Crystal structure\n\n\nmolecule::Molecule\n: adsorbate (includes position/orientation/atoms)\n\n\nljforcefield::LJForceField\n: Lennard Jones force field\n\n\n\n\nReturns\n\n\n\n\nenergy::Float64\n: Van der Waals interaction energy\n\n\n\n\nsource\n\n\ngg_energy = vdw_energy(molecule_id, molecules, ljforcefield, simulation_box)\n\n\n\n\nCalculates van der Waals interaction energy of a single adsorbate \nmolecules[molecule_id]\n with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention.\n\n\nArguments\n\n\n\n\nmolecule_id::Int\n: Molecule ID used to determine which molecule in \nmolecules\n we wish to calculate the guest-guest interactions\n\n\nmolecules::Array{Molecule, 1}\n: An array of Molecule data structures\n\n\nljforcefield::LJForceField\n: A Lennard Jones forcefield data structure describing the interactions between different atoms\n\n\nsimulation_box::Box\n: The simulation box for the computation.\n\n\n\n\nReturns\n\n\n\n\ngg_energy::Float64\n: The guest-guest interaction energy of \nmolecules[molecule_id]\n with the other molecules in \nmolecules\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.vdw_energy_no_PBC\n \n \nFunction\n.\n\n\npot_energy = vdw_energy_no_PBC(atoms, molecule, ljff)\n\n\n\n\nAssumes unit cell box is a unit cube and no periodic boundary conditions are applied.\n\n\nsource", 
            "title": "Atomic Interactions"
        }, 
        {
            "location": "/manual/atomic_interactions/#loading-in-forcefield-files", 
            "text": "Lennard-Jones forcefield parameters are stored in comma-separated-value format in  data/forcefields/ .  Interaction of an adsorbate with the framework is modeled as pair-wise additive and with Lennard-Jones potentials of the form:  V(r) = 4 * epsilon * [ x ^ 12 - x ^ 6 ] , where  x = sigma / r  The Lennard Jones force field input files, e.g.  UFF.csv  contain a list of pure (i.e. X-X, where X is an atom) sigmas and epsilons in units Angstrom and Kelvin, respectively. Note that, e.g., in the UFF paper, the Lennard Jones potential is written in a different form and thus parameters need to be converted to correspond to the functional form used in  PorousMaterials.jl .  using PorousMaterials\n\nljff = LJForceField( UFF.csv )  PorousMaterials will the output information about the forcefield file you just loaded:      Force field: UFF.csv\n    Number of atoms included: 106\n    Cut-off radius (\u212b) = 14.0      This also prints all of the atoms included in the loaded forcefield with their given \u03f5 and \u03c3. This was excluded because it would use too much space on this page.", 
            "title": "Loading in Forcefield Files"
        }, 
        {
            "location": "/manual/atomic_interactions/#building-blocks-of-porousmaterials-lennard-jones-forcefields", 
            "text": "# read in Lennard-Jones force field parameters from the Universal Force Field\nforcefield = LJForceField( UFF.csv , cutoffradius=14.0, mixing_rules= Lorentz-Berthelot )\n\n# access the Lennard-Jones epsilon   sigma for Xe\nforcefield.pure_\u03f5[:Xe] # K\nforcefield.pure_\u03c3[:Xe] # \u212b\n\n# access the Lennard-Jones epsilon   sigma for Xe-C interactions\nforcefield.\u03f5[:Xe][:C] # K                                                                 \nforcefield.\u03c3\u00b2[:Xe][:C] # \u212b (store \u03c3\u00b2 for faster computation)", 
            "title": "Building Blocks of PorousMaterials: Lennard-Jones forcefields"
        }, 
        {
            "location": "/manual/atomic_interactions/#building-blocks-of-porousmaterials-potential-energies", 
            "text": "First, set the fractional coordinates of the molecule in the context of some unit cell box.  # molecule in a framework\nset_fractional_coords!(molecule, framework.box)\n\n# molecule in a 10 by 10 by 10 cube\nbox = Box(10.0, 10.0, 10.0, \u03c0/2, \u03c0/2, \u03c0/2) # make a box\nset_fractional_coords!(molecule, box)", 
            "title": "Building Blocks of PorousMaterials: Potential energies"
        }, 
        {
            "location": "/manual/atomic_interactions/#potential-energies-van-der-waals", 
            "text": "What is the van der Waals potential energy of a Xe adsorbate inside SBMOF-1 at  [0.0, 1.0, 3.0]  Cartesian coordinates using the UFF as a molecular model?  using PorousMaterials\n\nframework = Framework( SBMOF-1.cif )\n\nforcefield = LJForceField( UFF.csv )\n\nmolecule = Molecule( Xe )\nset_fractional_coords!(molecule, framework.box)\n\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\n\nenergy = vdw_energy(framework, molecule, forcefield) # K", 
            "title": "Potential Energies: Van der Waals"
        }, 
        {
            "location": "/manual/atomic_interactions/#potential-energies-electrostatics", 
            "text": "What is the electrostatic potential energy of a CO 2  adsorbate inside CAXVII_clean at  [0.0, 1.0, 0.0]  Cartesian coordinate?  using PorousMaterials\n\nframework = Framework( CAXVII_clean.cif ) # has charges\n\nmolecule = Molecule( CO2 )\nset_fractional_coords!(molecule, framework.box)\n\ntranslate_to!(molecule, [0.0, 1.0, 0.0], framework.box) # need box b/c we're talking Cartesian\n\nrotate!(molecule, framework.box) # let's give it a random orientation\n\n# this is for speed. pre-compute k-vectors and allocate memory\neparams, kvectors, eikar, eikbr, eikcr = setup_Ewald_sum(12.0, framework.box)\n\nenergy = electrostatic_potential_energy(framework, molecule, eparams, kvectors, eikar, eikbr, eikcr)", 
            "title": "Potential Energies: Electrostatics"
        }, 
        {
            "location": "/manual/atomic_interactions/#potential-energies-equations-of-state", 
            "text": "Calculate fugacity, density of methane at 298 K and 65 bar using the Peng-Robinson EOS:  gas = PengRobinsonGas(:CH4)\nprops = calculate_properties(gas, 298.0, 65.0) # dictionary of properties\nprops[ fugacity coefficient ] # 0.8729  Pass  eos=:PengRobinson  to  gcmc_simulation  to automatically convert pressure to fugacity using the Peng-Robinson equation of state.", 
            "title": "Potential Energies: Equations of state"
        }, 
        {
            "location": "/manual/atomic_interactions/#forcefields", 
            "text": "#  PorousMaterials.LJForceField     Type .  Data structure for a Lennard Jones forcefield.  Attributes   name::String : name of forcefield; correponds to filename  pure_\u03c3::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03c3 of an X-X interaction, where X is an atom. (units: Angstrom)  pure_\u03f5::Dict{Symbol, Float64} : Dictionary that returns Lennard-Jones \u03f5 of an X-X interaction, where X is an atom. (units: K)  \u03c3\u00b2::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03c3\u00b2 (units: Angstrom\u00b2) for cross-interactions. Example use is  sigmas_squared[:He][:C]  \u03f5::Dict{Symbol, Dict{Symbol, Float64}} : Lennard Jones \u03f5 (units: K) for cross-interactions. Example use is  epsilons[:He][:C]  cutoffradius_squared::Float64 : The square of the cut-off radius beyond which we define the potential energy to be zero (units: Angstrom\u00b2). We store \u03c3\u00b2 to speed up computations, which involve \u03c3\u00b2, not \u03c3.   source  #  PorousMaterials.replication_factors     Function .  repfactors = replication_factors(unitcell, cutoffradius)  Find the replication factors needed to make a supercell big enough to fit a sphere with the specified cutoff radius. In PorousMaterials.jl, rather than replicating the atoms in the home unit cell to build the supercell that serves as a simulation box, we replicate the home unit cell to form the supercell (simulation box) in a for loop. This function ensures enough replication factors such that the nearest image convention can be applied.  A non-replicated supercell has 1 as the replication factor in each dimension ( repfactors = (1, 1, 1) ).  Arguments   unitcell::Box : The unit cell of the framework  cutoff_radius::Float64 : Cutoff radius beyond which we define the potential energy to be zero (units: Angstrom)   Returns   repfactors::Tuple{Int, Int, Int} : The replication factors in the a, b, c directions   source  #  PorousMaterials.check_forcefield_coverage     Function .  check_forcefield_coverage(framework, ljforcefield)\ncheck_forcefield_coverage(molecule, ljforcefield)  Check that the force field contains parameters for every atom present in a framework or molecule. Will print out which atoms are missing.  Arguments   framework::Framework : The framework containing the crystal structure information  molecule::Molecule : A molecule object  ljforcefield::LJForceField : A Lennard Jones forcefield object containing information on atom interactions   Returns   all_covered::Bool : Returns true if all atoms in the  framework  are also included in  ljforcefield . False otherwise   source", 
            "title": "Forcefields"
        }, 
        {
            "location": "/manual/atomic_interactions/#potential-energy", 
            "text": "#  PorousMaterials.PotentialEnergy     Type .  pe = PotentialEnergy()  Data structure to store potential energy, partitioned into van der Waals ( energy.vdw ) and electrostatic ( energy.coulomb ) interactions, both  Float64 .  This returns a PotentialEnergy data type where the vdw and coulomb attributes are set to 0.0  Returns   pe::PotentialEnergy : A structure containing van der Waals and electrostatic energies, initialized at 0.0   Attributes   vdw::Float64 : The potential energy contributions from Van der Waals interactions  coulomb::Float64 : The potential energy contributions from electrostatic interactions   source  #  PorousMaterials.SystemPotentialEnergy     Type .  system_potential_energy = SystemPotentialEnergy()  Data structure to facilitate storing/partitioning potential energy of a system. It stores the potential energy from guest-host and guest-guest interactions separately.  This initializes guest host and guest guest with PotentialEnergy(), so when it is created the total energy recorded is 0.0  Returns   system_potential_energy::SystemPotentialEnergy : A structure containing the potential energy of the system,   broken down into guest-guest and guest-host interactions   Attributes   guest_host::PotentialEnergy : The total potential energy from all guest-host   interactions in the system  guest_guest::PotentialEnergy : The total potential energy from all guest-guest   interactions in the system   source", 
            "title": "Potential Energy"
        }, 
        {
            "location": "/manual/atomic_interactions/#nearest-image-conventions", 
            "text": "#  PorousMaterials.nearest_image!     Function .  nearest_image!(dxf)  Applies the nearest image convention on a vector  dxf  between two atoms in fractional space; modifies  dxf  for nearest image convention. Fractional coordinates here fall in [0, 1] so that the box is [0, 1]^3 in fractional space.  Warning: this assumes the two molecules are in the box described by fractional coords [0, 1]\u00b3.  Arguments   dxf::Array{Float64} : A vector between two atoms in fractional space   source", 
            "title": "Nearest Image Conventions"
        }, 
        {
            "location": "/manual/atomic_interactions/#electrostatics-energy", 
            "text": "#  PorousMaterials.Eikr     Type .  eikr = Eikr(eikar, eikbr, eikcr)  mutable struct for holding the eikr vectors  Attributes   eikar::OffsetArray{Complex{Float64}} : array for storing e^{i * ka \u22c5 r}; has indices   0:kreps[1] and corresponds to recip. vectors in a-direction  eikbr::OffsetArray{Complex{Float64}} : array for storing e^{i * kb \u22c5 r}; has indices   -kreps[2]:kreps[2] and corresponds to recip. vectors in b-direction  eikcr::OffsetArray{Complex{Float64}} : array for storing e^{i * kc \u22c5 r}; has indices   -kreps[2]:kreps[1] and corresponds to recip. vectors in c-direction   source  #  PorousMaterials.electrostatic_potential_energy     Function .  \u03d5 = electrostatic_potential_energy(framework, molecule, eparams, eikr)  Compute the electrostatic potential energy of a molecule inside a framework.  The electrostatic potential is created by the point charges assigned to the framework atoms in  framework.charges . Periodic boundary conditions are applied through the Ewald summation. The spurious self-interaction term is neglected here because we are looking at  differences  in energy in a Monte Carlo simulation.  Warning: it is assumed that the framework is replicated enough such that the nearest image convention can be applied for the short-range cutoff radius supplied in  eparams.sr_cutoff_r .  Arguments   framework::Framework : Crystal structure (see  framework.charges  for charges)  molecule::Molecule : The molecule being compared to the atoms in the framework.  eparams::EwaldParams : data structure containing Ewald summation settings  eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.   Returns   pot::EwaldSum : Electrostatic potential between  framework  and  molecule  (units: K)   source  \u03d5 = electrostatic_potential_energy(molecules, eparams, box, eikr)  Compute the electrostatic potential energy of a system comprised of an array of  Molecule s.  The EWald summation is used here in a double for loop; do not use this function for Monte Carlo simulations because it is computationally expensive.  Returns an  EwaldSum  type containing short-range and long-range contributions to the Ewald sum as well as the spurious self-interaction and intramolecular interactions. Access via (\u03d5.sr, \u03d5.lr, \u03d5.self, \u03d5.intra).  Units of energy: Kelvin  Arguments   molecules::Array{Molecules, 1} : array of molecules comprising the system.  eparams::EwaldParams : data structure containing Ewald summation settings  box::Box : the box the energy is being computed in  eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.   Returns   \u03d5::GGEwaldSum : The total electrostatic potential energy   source  #  PorousMaterials.precompute_kvec_wts     Function .  kvectors = precompute_kvec_wts(kreps, box, \u03b1, max_mag_k_sqrd=Inf)  For speed, pre-compute the weights for each reciprocal lattice vector for the Ewald sum in Fourier space. This function takes advantage of the symmetry:     cos(-k\u22c5(x-x\u1d62)) + cos(k\u22c5(x-x\u1d62)) = 2 cos(k\u22c5(x-x\u1d62))  If  max_mag_k_sqrd  is passed, k-vectors with a magnitude greater than  max_mag_k_sqrd  are not included.  Arguments   kreps::Tuple{Int, Int, Int} : number of k-vector replications required in a, b, c  box::Box : the simulation box containing the reciprocal lattice.  \u03b1::Float64 : Ewald sum convergence parameter (units: inverse \u212b)  max_mag_k_sqrd::Float64 : cutoff for |k|\u00b2 in Fourier sum; if passed, do not include   k-vectors with magnitude squared greater than this.  Returns   kvectors::Array{Kvector, 1} : array of k-vectors to include in the Fourier sum and their   corresponding weights indicating the contribution to the Fourier sum.  source  #  PorousMaterials.setup_Ewald_sum     Function .  eparams = setup_Ewald_sum(box, sr_cutoff_r; \u03f5=1e-6, verbose=false)  Given the short-range cutoff radius and simulation box, automatically compute Ewald convergence parameter and number of k-vector replications in Fourier space required for a given precision. Constructs and returns Ewald parameters data type with this information.  Also, pre-compute weights on k-vector contributions to Ewald sum in Fourier space.  Also, allocate OffsetArrays for storing e^{i * k \u22c5 r} where r = x - x\u2c7c and k is a reciprocal lattice vector.  Arguments   box::Box : the simulation box containing the reciprocal lattice.  sr_cutoff_r::Float64 : cutoff-radius (units: \u212b) for short-range contributions to Ewald  \u03f5::Float64 : desired level of precision. Typical value is 1e-6, but this does not  verbose::Bool : If  true  will print results   Returns   eparams::EwaldParams : data structure containing Ewald summation settings   corresponding weights indicating the contribution to the Fourier sum.  source  #  PorousMaterials.total_electrostatic_potential_energy     Function .  total_\u03d5 = total_electrostatic_potential_energy(molecules, eparams, box, eikr)  Calculates the total electrostatic potential energy of an array of  Molecule s using a Grand Canonical Monte Carlo (GCMC) algorithm. #TODO add to this  Arguments   molecules::Array{Molecule, 1} : The molecules comprising the system.  eparams::EwaldParams : data structure containing Ewald summation settings  box::Box : The box the energy is being computed in.  eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.   Returns   \u03d5::GGEwaldSum : The total electrostatic potential energy   source  total_\u03d5 = total_electrostatic_potential_energy(framework, molecules, eparams, eikr)  Explanation of total electrostatic potential_energy that uses framework  Arguments   framework::Framework : Crystal structure (see  framework.charges  for charges)  molecules::Array{Molecule, 1} : The molecules comprising the system.  eparams::EwaldParams : data structure containing Ewald summation settings  eikr::Eikr : Stores the eikar, eikbr, and eikcr OffsetArrays used in this calculation.   source", 
            "title": "Electrostatics Energy"
        }, 
        {
            "location": "/manual/atomic_interactions/#van-der-waals-energy", 
            "text": "#  PorousMaterials.lennard_jones     Function .  energy = lennard_jones(r\u00b2, \u03c3\u00b2, \u03f5)  (units: Kelvin)  Calculate the lennard jones potential energy given the square of the radius r between two lennard-jones spheres. \u03c3 and \u03f5 are specific to interaction between two elements. Return the potential energy in units Kelvin (well, whatever the units of \u03f5 are).  Arguments   r\u00b2::Float64 : distance between two (pseudo)atoms in question squared (Angstrom\u00b2)  \u03c3\u00b2::Float64 : sigma parameter in Lennard Jones potential squared (units: Angstrom\u00b2)  \u03f5::Float64 : epsilon parameter in Lennard Jones potential (units: Kelvin)   Returns   energy::Float64 : Lennard Jones potential energy   source  #  PorousMaterials.vdw_energy     Function .  energy = vdw_energy(framework, molecule, ljforcefield)  Calculates the van der Waals interaction energy between a molecule and a framework. Applies the nearest image convention to find the closest replicate of a specific atom.  WARNING: it is assumed that the framework is replicated sufficiently such that the nearest image convention can be applied. See  replicate .  Arguments   framework::Framework : Crystal structure  molecule::Molecule : adsorbate (includes position/orientation/atoms)  ljforcefield::LJForceField : Lennard Jones force field   Returns   energy::Float64 : Van der Waals interaction energy   source  gg_energy = vdw_energy(molecule_id, molecules, ljforcefield, simulation_box)  Calculates van der Waals interaction energy of a single adsorbate  molecules[molecule_id]  with all of the other molecules in the system. Periodic boundary conditions are applied, using the nearest image convention.  Arguments   molecule_id::Int : Molecule ID used to determine which molecule in  molecules  we wish to calculate the guest-guest interactions  molecules::Array{Molecule, 1} : An array of Molecule data structures  ljforcefield::LJForceField : A Lennard Jones forcefield data structure describing the interactions between different atoms  simulation_box::Box : The simulation box for the computation.   Returns   gg_energy::Float64 : The guest-guest interaction energy of  molecules[molecule_id]  with the other molecules in  molecules   source  #  PorousMaterials.vdw_energy_no_PBC     Function .  pot_energy = vdw_energy_no_PBC(atoms, molecule, ljff)  Assumes unit cell box is a unit cube and no periodic boundary conditions are applied.  source", 
            "title": "Van der Waals Energy"
        }, 
        {
            "location": "/manual/mof_simulations/", 
            "text": "Demo of Henry coefficients Calculation\n#\n\n\nCompute the Henry coefficient of CO\n2\n in CAXVII_clean (Fe\n2\n(dobdc)) at 298 K using the Dreiding force field:\n\n\nusing PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework(\nCAXVII_clean.cif\n)                                               \n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField(\nDreiding.csv\n, cutoffradius=12.5)                                  \n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule(\nCO2\n)                                                              \n\ntemperature = 298.0 # K\n\n# conduct Widom insertions and compute Henry coefficient, heat of adsorption\nresults = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[\nQst (kJ/mol)\n] # -21.0\nresults[\nhenry coefficient [mol/(kg-Pa)]\n] # 2.88e-05\n\n\n\n\nThe simulation is parallelized across a maximum of 5 cores.\n\n\n\n\nDemo of Grand-canonical Monte Carlo Simulations\n#\n\n\nSimulate the adsorption of CO\n2\n in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:\n\n\nusing PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework(\nFIQCEN_clean_min_charges.cif\n)\n# remove annoying numbers from atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField(\nUFF.csv\n, cutoffradius=12.8)\n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule(\nCO2\n)\n\ntemperature = 298.0 # K\npressure = 1.0 # bar\n\n# conduct grand-canonical Monte Carlo simulation\nresults, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[\n\u27e8N\u27e9 (molecules/unit cell)\n]\nresults[\nQ_st (K)\n]\n\n\n\n\nOr, compute the entire adsorption isotherm at once, parallelized across many cores:\n\n\npressures = [0.2, 0.6, 0.8, 1.0] # bar\n\n# loop over all pressures and compute entire adsorption isotherm in parallel\nresults = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)\n\n\n\n\nOr, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:\n\n\n# loop over all pressures and run GCMC simulations in series.\n# load in the configurations of the molecules from the previous pressure.\nresults = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=1000, n_sample_cycles=5000)\n\n\n\n\n\n\nHenry Coefficient Calculations\n#\n\n\n#\n\n\nPorousMaterials.henry_coefficient\n \n \nFunction\n.\n\n\nresult = henry_coefficient(framework, molecule, temperature, ljforcefield,\n                            nb_insertions=1e6, verbose=true, ewald_precision=1e-6,\n                            autosave=true)\n\n\n\n\nConduct particle insertions to compute the Henry coefficient K\u2095 of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): \u27e8N\u27e9 = K\u2095 P, where P is pressure and K\u2095 is the Henry coefficient.\n\n\nK\u2095 = \u03b2 \u27e8e^{-\u03b2 U}\u27e9, where the average is over positions and orientations of the molecule in the framework.\n\n\nArguments\n\n\n\n\nframework::Framework\n: the porous crystal in which we seek to simulate adsorption\n\n\nmolecule::Molecule\n: the adsorbate molecule\n\n\ntemperature::Float64\n: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\n\n\nljforcefield::LJForceField\n: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\n\n\ninsertions_per_volume::Int\n: number of Widom insertions to perform for computing the\n\n\n\n\naverage, per unit cell volume (\u212b\u00b3)\n\n\n\n\nverbose::Bool\n: whether or not to print off information during the simulation.\n\n\newald_precision::Float64\n: desired precision for Ewald summations; used to determine\n\n\n\n\nthe replication factors in reciprocal space.\n\n\n\n\nautosave::Bool\n: save results file as a .jld in PATH\nTO\nDATA * \nsims\n\n\nfilename_comment::AbstractString\n: An optional comment that will be appended to the name of the saved file.\n\n\nwrite_checkpoint::Bool\n: Will periodically save checkpoints to start the job from a previous state.\n\n\nload_checkpoint::Bool\n: Instructs the program to look for a checkpoint file in \ndata/henry_checkpoints\n\n\n\n\nand start the simulation from that point.\n\n\n\n\ncheckpoint_frequency::Int\n: The frequency at which we will save a checkpoint file. Is only used if \nwrite_checkpoint=true\n\n\n\n\nReturns\n\n\n\n\nresult::Dict{String, Float64}\n: A dictionary containing all the results from the Henry coefficient simulation\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.henry_result_savename\n \n \nFunction\n.\n\n\nsave_name = henry_result_savename(framework, molecule, temperature,\n                               ljforcefield, insertions_per_volume;\n                               comment=\n)\n\n\n\n\nDetermine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\n\nArguments\n\n\n\n\nframework::Framework\n: The porous crystal being tested\n\n\nmolecule::Molecule\n: The molecule being tested inside the crystal\n\n\ntemperature::Float64\n: The temperature used in the simulation units: Kelvin (K)\n\n\nljforcefield::LJForceField\n: The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces\n\n\ninsertions_per_volume::Union{Int, Float64}\n: The number of widom insertions per unit volume.   Will be scaled according to the framework we're working with\n\n\ncomment::AbstractString\n: An optional comment that will be appended to the filename\n\n\n\n\nsource\n\n\n\n\nGrand-Canonical Monte Carlo Simulations\n#\n\n\n#\n\n\nPorousMaterials.gcmc_simulation\n \n \nFunction\n.\n\n\nresults, molecules = gcmc_simulation(framework, molecule, temperature, pressure,\n                                     ljforcefield; n_sample_cycles=5000,\n                                     n_burn_cycles=5000, sample_frequency=1,\n                                     verbose=false, molecules=Molecule[],\n                                     eos=:ideal, ewald_precision=1e-6,\n                                     load_checkpoint_file=false,\n                                     show_progress_bar=false, checkpoint=Dict(),\n                                     write_checkpoints=false, checkpoint_frequency=100,\n                                     filename_comment=\n)\n\n\n\n\nRuns a grand-canonical (\u03bcVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field.\n\n\nA cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation.\n\n\nArguments\n\n\n\n\nframework::Framework\n: the porous crystal in which we seek to simulate adsorption\n\n\nmolecule::Molecule\n: a template of the adsorbate molecule of which we seek to simulate\n\n\ntemperature::Float64\n: temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)\n\n\npressure::Float64\n: pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material. units: bar   the adsorption\n\n\nljforcefield::LJForceField\n: the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.\n\n\nn_burn_cycles::Int\n: number of cycles to allow the system to reach equilibrium before   sampling.\n\n\nn_sample_cycles::Int\n: number of cycles used for sampling\n\n\nsample_frequency::Int\n: during the sampling cycles, sample e.g. the number of adsorbed   gas molecules every this number of Markov proposals.\n\n\nverbose::Bool\n: whether or not to print off information during the simulation.\n\n\nmolecules::Array{Molecule, 1}\n: a starting configuration of molecules in the framework.\n\n\n\n\nNote that we assume these coordinates are Cartesian, i.e. corresponding to a unit box.\n\n\n\n\newald_precision::Float64\n: The desired precision for the long range Ewald summation\n\n\neos::Symbol\n: equation of state to use for calculation of fugacity from pressure. Default\n\n\n\n\nis ideal gas, where fugacity = pressure.\n\n\n\n\nload_checkpoint_file::Bool\n: Will find a checkpoint file corresponding to the \ngcmc_result_savename\n if true.   If that file is not found, function will throw an error.\n\n\ncheckpoint::Dict\n: A checkpoint dictionary that will work as a starting configuration for the run.   The dictionary has to have the following keys: \nouter_cycle\n, \nmolecules\n, \nsystem_energy\n, \ncurrent_block\n, \ngcmc_stats\n, \nmarkov_counts\n, \nmarkov_chain_time\n and \ntime\n. If this argument is used, keep \nload_checkpoint_file=false\n.\n\n\nwrite_checkpoints::Bool\n: Will save checkpoints in data/gcmc_checkpoints if this is true.\n\n\ncheckpoint_frequency::Int\n: Will save checkpoint files every \ncheckpoint_frequency\n cycles.\n\n\nwrite_adsorbate_snapshots::Bool\n: Whether the simulation will create and save a snapshot file\n\n\nsnapshot_frequency::Int\n: The number of cycles taken between each snapshot (after burn cycle completion)\n\n\ncalculate_density_grid::Bool\n: Whether the simulation will keep track of a density grid for adsorbates\n\n\ndensity_grid_dx::Float64\n: The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by \nrequired_n_pts\n.\n\n\ndensity_grid_species::Symbol\n: The atomic species within the \nmolecule\n for which we will compute the density grid.\n\n\nfilename_comment::AbstractString\n: An optional comment that will be appended to the name of the saved file (if autosaved)\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.adsorption_isotherm\n \n \nFunction\n.\n\n\nresults = adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal, \n                              load_checkpoint_file=false, checkpoint=Dict(), \n                              write_checkpoints=false, checkpoint_frequency=50,\n                              filename_comment=\n, show_progress_bar=false)\n\n\n\n\nRun a set of grand-canonical (\u03bcVT) Monte Carlo simulations in parallel. Arguments are the same as \ngcmc_simulation\n, as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as \njulia -p 4 mysim.jl\n to allocate e.g. four cores. See \nParallel Computing\n.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.stepwise_adsorption_isotherm\n \n \nFunction\n.\n\n\nresults = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              load_checkpoint_file=false, checkpoint=Dict(),\n                              write_checkpoints=false, checkpoint_frequency=50,\n                              filename_comment=\n, show_progress_bar=false)\n\n\n\n\nRun a set of grand-canonical (\u03bcVT) Monte Carlo simulations in series. Arguments are the same as \ngcmc_simulation\n, as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of \npressures\n is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see \nadsorption_isotherm\n which runs the \u03bcVT simulation at each pressure in parallel.\n\n\nsource\n\n\n#\n\n\nPorousMaterials.gcmc_result_savename\n \n \nFunction\n.\n\n\nfile_save_name = gcmc_result_savename(framework_name, molecule_species,\n                                    ljforcefield_name, temperature, pressure,\n                                    n_burn_cycles, n_sample_cycles; comment=\n,\n                                    extension=\n)\n\n\n\n\nDetermine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.\n\n\nArguments\n\n\n\n\nframework_name::AbstractString\n: The porous crystal being tested\n\n\nmolecule_species::Symbol\n: The molecule being tested inside the porous crystal\n\n\nljforcefield_name::AbstractString\n: The molecular model being used in this   simulation to describe intermolecular Van der Waals interactions\n\n\ntemperature::Float64\n: The temperature used in the simulation units: Kelvin (K)\n\n\npressure::Float64\n: The pressure used in the simulation units: bar\n\n\nn_burn_cycles::Int\n: The number of burn cycles used in this simulation\n\n\nn_sample_cycles::Int\n: The number of sample cycles used in this simulation\n\n\ncomment::AbstractString\n: An optional comment that will be appended to the end of the filename\n\n\nextension::AbstractString\n: The extension for the file being created\n\n\n\n\nsource", 
            "title": "Molecular Simulations"
        }, 
        {
            "location": "/manual/mof_simulations/#demo-of-henry-coefficients-calculation", 
            "text": "Compute the Henry coefficient of CO 2  in CAXVII_clean (Fe 2 (dobdc)) at 298 K using the Dreiding force field:  using PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework( CAXVII_clean.cif )                                               \n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField( Dreiding.csv , cutoffradius=12.5)                                  \n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule( CO2 )                                                              \n\ntemperature = 298.0 # K\n\n# conduct Widom insertions and compute Henry coefficient, heat of adsorption\nresults = henry_coefficient(framework, molecule, temperature, forcefield, insertions_per_volume=200)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[ Qst (kJ/mol) ] # -21.0\nresults[ henry coefficient [mol/(kg-Pa)] ] # 2.88e-05  The simulation is parallelized across a maximum of 5 cores.", 
            "title": "Demo of Henry coefficients Calculation"
        }, 
        {
            "location": "/manual/mof_simulations/#demo-of-grand-canonical-monte-carlo-simulations", 
            "text": "Simulate the adsorption of CO 2  in FIQCEN_clean_min_charges (CuBTC) at 298 K at 1 bar using the Universal Force Field:  using PorousMaterials\n\n# read in xtal structure file and populate a Framework data structure\nframework = Framework( FIQCEN_clean_min_charges.cif )\n# remove annoying numbers from atom labels\nstrip_numbers_from_atom_labels!(framework)\n\n# read in Lennard-Jones force field parameters and populate a LJForceField data structure\nforcefield = LJForceField( UFF.csv , cutoffradius=12.8)\n\n# read in a molecule format file and populate a Molecule data structure\nmolecule = Molecule( CO2 )\n\ntemperature = 298.0 # K\npressure = 1.0 # bar\n\n# conduct grand-canonical Monte Carlo simulation\nresults, molecules = gcmc_simulation(framework, molecule, temperature, pressure, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)\n\n# ... prints stuff\n# results automatically saved to .jld load later in one line of code\n\n# returns dictionary for easy querying\nresults[ \u27e8N\u27e9 (molecules/unit cell) ]\nresults[ Q_st (K) ]  Or, compute the entire adsorption isotherm at once, parallelized across many cores:  pressures = [0.2, 0.6, 0.8, 1.0] # bar\n\n# loop over all pressures and compute entire adsorption isotherm in parallel\nresults = adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=5000, n_sample_cycles=5000)  Or, compute the adsorption isotherm in a step-wise manner, loading the molecules from the previous simulation to save on burn cycles:  # loop over all pressures and run GCMC simulations in series.\n# load in the configurations of the molecules from the previous pressure.\nresults = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures, forcefield,\n            n_burn_cycles=1000, n_sample_cycles=5000)", 
            "title": "Demo of Grand-canonical Monte Carlo Simulations"
        }, 
        {
            "location": "/manual/mof_simulations/#henry-coefficient-calculations", 
            "text": "#  PorousMaterials.henry_coefficient     Function .  result = henry_coefficient(framework, molecule, temperature, ljforcefield,\n                            nb_insertions=1e6, verbose=true, ewald_precision=1e-6,\n                            autosave=true)  Conduct particle insertions to compute the Henry coefficient K\u2095 of a molecule in a framework. Also, for free, the heat of adsorption and ensemble average energy of adsorption is computed. The Henry coefficient is a model for adsorption at infinite dilution (low coverage): \u27e8N\u27e9 = K\u2095 P, where P is pressure and K\u2095 is the Henry coefficient.  K\u2095 = \u03b2 \u27e8e^{-\u03b2 U}\u27e9, where the average is over positions and orientations of the molecule in the framework.  Arguments   framework::Framework : the porous crystal in which we seek to simulate adsorption  molecule::Molecule : the adsorbate molecule  temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)  ljforcefield::LJForceField : the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.  insertions_per_volume::Int : number of Widom insertions to perform for computing the   average, per unit cell volume (\u212b\u00b3)   verbose::Bool : whether or not to print off information during the simulation.  ewald_precision::Float64 : desired precision for Ewald summations; used to determine   the replication factors in reciprocal space.   autosave::Bool : save results file as a .jld in PATH TO DATA *  sims  filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file.  write_checkpoint::Bool : Will periodically save checkpoints to start the job from a previous state.  load_checkpoint::Bool : Instructs the program to look for a checkpoint file in  data/henry_checkpoints   and start the simulation from that point.   checkpoint_frequency::Int : The frequency at which we will save a checkpoint file. Is only used if  write_checkpoint=true   Returns   result::Dict{String, Float64} : A dictionary containing all the results from the Henry coefficient simulation   source  #  PorousMaterials.henry_result_savename     Function .  save_name = henry_result_savename(framework, molecule, temperature,\n                               ljforcefield, insertions_per_volume;\n                               comment= )  Determine the name of files saved while calculating the henry coefficient. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.  Arguments   framework::Framework : The porous crystal being tested  molecule::Molecule : The molecule being tested inside the crystal  temperature::Float64 : The temperature used in the simulation units: Kelvin (K)  ljforcefield::LJForceField : The molecular model being used in the simulation   to describe the intermolecular Van der Waals forces  insertions_per_volume::Union{Int, Float64} : The number of widom insertions per unit volume.   Will be scaled according to the framework we're working with  comment::AbstractString : An optional comment that will be appended to the filename   source", 
            "title": "Henry Coefficient Calculations"
        }, 
        {
            "location": "/manual/mof_simulations/#grand-canonical-monte-carlo-simulations", 
            "text": "#  PorousMaterials.gcmc_simulation     Function .  results, molecules = gcmc_simulation(framework, molecule, temperature, pressure,\n                                     ljforcefield; n_sample_cycles=5000,\n                                     n_burn_cycles=5000, sample_frequency=1,\n                                     verbose=false, molecules=Molecule[],\n                                     eos=:ideal, ewald_precision=1e-6,\n                                     load_checkpoint_file=false,\n                                     show_progress_bar=false, checkpoint=Dict(),\n                                     write_checkpoints=false, checkpoint_frequency=100,\n                                     filename_comment= )  Runs a grand-canonical (\u03bcVT) Monte Carlo simulation of the adsorption of a molecule in a framework at a particular temperature and pressure using a Lennard Jones force field.  A cycle is defined as max(20, number of adsorbates currently in the system) Markov chain proposals. Current Markov chain moves implemented are particle insertion/deletion and translation.  Arguments   framework::Framework : the porous crystal in which we seek to simulate adsorption  molecule::Molecule : a template of the adsorbate molecule of which we seek to simulate  temperature::Float64 : temperature of bulk gas phase in equilibrium with adsorbed phase   in the porous material. units: Kelvin (K)  pressure::Float64 : pressure of bulk gas phase in equilibrium with adsorbed phase in the   porous material. units: bar   the adsorption  ljforcefield::LJForceField : the molecular model used to describe the   energetics of the adsorbate-adsorbate and adsorbate-host van der Waals interactions.  n_burn_cycles::Int : number of cycles to allow the system to reach equilibrium before   sampling.  n_sample_cycles::Int : number of cycles used for sampling  sample_frequency::Int : during the sampling cycles, sample e.g. the number of adsorbed   gas molecules every this number of Markov proposals.  verbose::Bool : whether or not to print off information during the simulation.  molecules::Array{Molecule, 1} : a starting configuration of molecules in the framework.   Note that we assume these coordinates are Cartesian, i.e. corresponding to a unit box.   ewald_precision::Float64 : The desired precision for the long range Ewald summation  eos::Symbol : equation of state to use for calculation of fugacity from pressure. Default   is ideal gas, where fugacity = pressure.   load_checkpoint_file::Bool : Will find a checkpoint file corresponding to the  gcmc_result_savename  if true.   If that file is not found, function will throw an error.  checkpoint::Dict : A checkpoint dictionary that will work as a starting configuration for the run.   The dictionary has to have the following keys:  outer_cycle ,  molecules ,  system_energy ,  current_block ,  gcmc_stats ,  markov_counts ,  markov_chain_time  and  time . If this argument is used, keep  load_checkpoint_file=false .  write_checkpoints::Bool : Will save checkpoints in data/gcmc_checkpoints if this is true.  checkpoint_frequency::Int : Will save checkpoint files every  checkpoint_frequency  cycles.  write_adsorbate_snapshots::Bool : Whether the simulation will create and save a snapshot file  snapshot_frequency::Int : The number of cycles taken between each snapshot (after burn cycle completion)  calculate_density_grid::Bool : Whether the simulation will keep track of a density grid for adsorbates  density_grid_dx::Float64 : The (approximate) space between voxels (in Angstroms) in the density grid. The number of voxels in the simulation box is computed automatically by  required_n_pts .  density_grid_species::Symbol : The atomic species within the  molecule  for which we will compute the density grid.  filename_comment::AbstractString : An optional comment that will be appended to the name of the saved file (if autosaved)   source  #  PorousMaterials.adsorption_isotherm     Function .  results = adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal, \n                              load_checkpoint_file=false, checkpoint=Dict(), \n                              write_checkpoints=false, checkpoint_frequency=50,\n                              filename_comment= , show_progress_bar=false)  Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in parallel. Arguments are the same as  gcmc_simulation , as this is the function run in parallel behind the scenes. The only exception is that we pass an array of pressures. To give Julia access to multiple cores, run your script as  julia -p 4 mysim.jl  to allocate e.g. four cores. See  Parallel Computing .  source  #  PorousMaterials.stepwise_adsorption_isotherm     Function .  results = stepwise_adsorption_isotherm(framework, molecule, temperature, pressures,\n                              ljforcefield; n_sample_cycles=5000,\n                              n_burn_cycles=5000, sample_frequency=1,\n                              verbose=true, ewald_precision=1e-6, eos=:ideal,\n                              load_checkpoint_file=false, checkpoint=Dict(),\n                              write_checkpoints=false, checkpoint_frequency=50,\n                              filename_comment= , show_progress_bar=false)  Run a set of grand-canonical (\u03bcVT) Monte Carlo simulations in series. Arguments are the same as  gcmc_simulation , as this is the function run behind the scenes. An exception is that we pass an array of pressures. The adsorption isotherm is computed step- wise, where the ending configuration from the previous simulation (array of molecules) is passed into the next simulation as a starting point. The ordering of  pressures  is honored. By giving each simulation a good starting point, (if the next pressure does not differ significantly from the previous pressure), we can reduce the number of burn cycles required to reach equilibrium in the Monte Carlo simulation. Also see  adsorption_isotherm  which runs the \u03bcVT simulation at each pressure in parallel.  source  #  PorousMaterials.gcmc_result_savename     Function .  file_save_name = gcmc_result_savename(framework_name, molecule_species,\n                                    ljforcefield_name, temperature, pressure,\n                                    n_burn_cycles, n_sample_cycles; comment= ,\n                                    extension= )  Determine the name of files saved during the GCMC simulation, be molecule positions or results. It uses many pieces of information from the simulation to ensure the file name accurately describes what it holds.  Arguments   framework_name::AbstractString : The porous crystal being tested  molecule_species::Symbol : The molecule being tested inside the porous crystal  ljforcefield_name::AbstractString : The molecular model being used in this   simulation to describe intermolecular Van der Waals interactions  temperature::Float64 : The temperature used in the simulation units: Kelvin (K)  pressure::Float64 : The pressure used in the simulation units: bar  n_burn_cycles::Int : The number of burn cycles used in this simulation  n_sample_cycles::Int : The number of sample cycles used in this simulation  comment::AbstractString : An optional comment that will be appended to the end of the filename  extension::AbstractString : The extension for the file being created   source", 
            "title": "Grand-Canonical Monte Carlo Simulations"
        }, 
        {
            "location": "/manual/other/", 
            "text": "PorousMaterials relies on functions that fall outside of the sections discussed up to this point. They are useful, but operate on their own for the most part.\n\n\n\n\nPATH_TO_DATA Control\n#\n\n\nThe PATH_TO_DATA is crucial for loading in data files. These functions allow the user to control this after they have done \nusing PorusMaterials\n. The \nset_tutorial_mode()\n function has been discussed before, and it allows you to recreate our example and try PorouMaterials before loading your data. The other functions allow the user to reset the PATH_TO_DATA to the data folder in their current directory or to another directory on their machine if their files are stored in many places.\n\n\n\n\nReading in Atomic Values\n#\n\n\nThese functions are used to read in the \natomicmasses.csv\n, \natom_properties.csv\n, and \ncpk_atom_colors.csv\n files from the current \nPATH_TO_DATA\n directory. They contain information on the masses, radii, and cpk color scheme for atoms.\n\n\n\n\nUsing .xyz files\n#\n\n\nThese functions allow the user to load and save .xyz files describing where molecules appear in a given space. This can be used to save the location of molecules in the middle of a simulation or to visualize what is happening.\n\n\n\n\nPATH_TO_DATA Control\n#\n\n\n#\n\n\nPorousMaterials.set_path_to_data\n \n \nFunction\n.\n\n\nset_path_to_data(\nuser/path/to/data\n)\nset_path_to_data()\n\n\n\n\nSets PorousMaterials \nPATH_TO_DATA\n variable which dictates where crystal, forcefield, and molecule files are loaded from. This function allows the user to set \nPATH_TO_DATA\n manually to any directory or to a \"/data/\" folder within their current directory. This function WILL change the \nPATH_TO_DATA\n regardless of whether or not the path exists, but will give a warning alerting the user that PorousMaterials cannot load files from the chosen path.\n\n\nArguments\n\n\n\n\nnew_path_to_data::String\n: The desired \nPATH_TO_DATA\n in string form.\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.set_tutorial_mode\n \n \nFunction\n.\n\n\nset_tutorial_mode()\n\n\n\n\nPlaces PorousMaterials in \"Tutorial Mode\". It changes the \nPATH_TO_DATA\n variable to the directory where the PorousMaterials test data is stored. It can be used to follow examples shown in the README. It displays a warning so that the user knows They are no longer using their own data.\n\n\nsource\n\n\n\n\nReading in Atomic Values\n#\n\n\n#\n\n\nPorousMaterials.read_atomic_radii\n \n \nFunction\n.\n\n\natomic_radii = read_atomic_radii()\n\n\n\n\nReturn \natomic_radii::Dict{Symbol, Float64}\n, where \natom_masses[\":C\"]\n gives the atomic radii of carbon (10.87 Angstrom).\n\n\nReturns\n\n\n\n\natomic_radii::Dict{Symbol, Float64}\n: A dictionary linking an element symbol to its' corresponding atomic radius\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.read_atomic_masses\n \n \nFunction\n.\n\n\natomic_masses = read_atomic_masses()\n\n\n\n\nRead the \ndata/atomicmasses.csv\n file to construct a dictionary of atoms and their atomic masses in amu.\n\n\nReturns\n\n\n\n\natomic_masses::Dict{Symbol, Float64}\n: A dictionary containing the atomic masses of each atom stored in \ndata/atomicmasses.csv\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.read_cpk_colors\n \n \nFunction\n.\n\n\natom_colors = read_cpk_colors()\n\n\n\n\nRead in CPK color scheme for atoms. Return \natom_colors::Dict{Symbol, Tuple{Int, Int, Int}}\n such that \natom_colors[\":C\"]\n gives RGB code for carbon as a tuple, \n(144, 144, 144)\n. https://en.wikipedia.org/wiki/CPK_coloring\n\n\nReturns\n\n\n\n\natom_colors::Dict{Symbol, Tuple{Int, Int, Int}}\n: A dictionary linking an element symbol to its' corresponding CPK color in RGB\n\n\n\n\nsource\n\n\n\n\nUsing .xyz files\n#\n\n\n#\n\n\nPorousMaterials.read_xyz\n \n \nFunction\n.\n\n\natoms, x = read_xyz(filename)\n\n\n\n\nReturn the list of \natoms\n (Array{Symbol, 1}) and their Cartesian coordinates \nx::Array{Float64, 2}\n as stored in the .xyz file. \nx[:, k]\n will return Cartesian coords of the kth atom.\n\n\nArguments\n\n\n\n\nfilename::AbstractString\n: The filename of the .xyz file\n\n\n\n\nReturns\n\n\n\n\natoms::Array{Symbol, 1}\n: An array of atoms stored as symbols e.g. [:H, :H, :O] read\n\n\n\n\nfrom the .xyz file.\n\n\n\n\nx::Array{Float64, 2}\n: The Cartesian coordinates of the atoms. \nx[:, k]\n will return cartesian coordinates of the k-th atom\n\n\n\n\nsource\n\n\n#\n\n\nPorousMaterials.write_xyz\n \n \nFunction\n.\n\n\nwrite_xyz(atoms, x, filename; comment=\n)\nwrite_xyz(molecules, box, filename; comment=\n)\nwrite_xyz(framework, filename; comment=\n, center=false)\n\n\n\n\nWrite a molecule, framework, or array of atoms \n positions to an .xyz file.\n\n\nArguments\n\n\n\n\natoms::Array{Symbol, 1}\n: An array of atoms stored as symbols e.g. [:H, :H, :O]\n\n\nx::Array{Float64, 2}\n: The Cartesian coordinates of the atoms.\n\n\n\n\nx[:, k]\n contains Cartesian coordinates of the k-th atom\n\n\n\n\nmolecules::Array{Molecule, 1}\n: an array of molecules whose atoms to write to .xyz\n\n\nframework::Framework\n: a crystal structure whose atoms to write to .xyz\n\n\nfilename::AbstractString\n: The filename of the .xyz file. (\".xyz\" appended automatically\n\n\n\n\nif the extension is not provided.) (absolute path)\n\n\n\n\ncomment::AbstractString\n: comment if you'd like to write to the file.\n\n\ncenter::Bool\n: shift atoms so that origin is the center of the \nframework.box\n\n\n\n\nsource\n\n\nwrite_xyz(box, molecules, xyz_file)\n\n\n\n\nWrites the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end.\n\n\nThis writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion.\n\n\nArguments\n\n\n\n\nbox::Box\n: The box the molecules are in, to convert molecule positions      to cartesian coordinates\n\n\nmolecules::Array{Molecule, 1}\n: The array of molecules to be written to the file\n\n\nxyz_file::IOStream\n: The open 'write' file stream the data will be saved to\n\n\n\n\nsource\n\n\n\n\nGeneric Rotations\n#\n\n\n#\n\n\nPorousMaterials.rotation_matrix\n \n \nFunction\n.\n\n\nr = rotation_matrix()\n\n\n\n\nGenerate a 3x3 random rotation matrix \nr\n such that when a point \nx\n is rotated using this rotation matrix via \nr * x\n, this point \nx\n is placed at a uniform random distributed position on the surface of a sphere of radius \nnorm(x)\n. See James Arvo. Fast Random Rotation Matrices.\n\n\nhttps://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf\n\n\nReturns\n\n\n\n\nr::Array{Float64, 2}\n: A 3x3 random rotation matrix\n\n\n\n\nsource\n\n\nR = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u\nR = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim`\n\n\n\n\nDetermine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis \nu\n.\n\n\nSee \nWikipedia\n.\n\n\nArguments\n\n\n\n\n\u03b8::Float64\n: angle to rotate about an axis, in radians\n\n\nu::Array{Float64, 1}\n: axis about which to rotate\n\n\ndim::Int\n: 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.\n\n\nassume_unit_vector::Bool\n: assume \nu\n is a unit vector; otherwise, \nu\n will be normalized\n\n\n\n\ninternal to this function.\n\n\nReturns\n\n\n\n\nR::Array{Float64, 2}\n: 3D rotation matrix. so \nR * x\n will rotate vector \nx\n as desired.\n\n\n\n\nsource", 
            "title": "Other"
        }, 
        {
            "location": "/manual/other/#path_to_data-control", 
            "text": "The PATH_TO_DATA is crucial for loading in data files. These functions allow the user to control this after they have done  using PorusMaterials . The  set_tutorial_mode()  function has been discussed before, and it allows you to recreate our example and try PorouMaterials before loading your data. The other functions allow the user to reset the PATH_TO_DATA to the data folder in their current directory or to another directory on their machine if their files are stored in many places.", 
            "title": "PATH_TO_DATA Control"
        }, 
        {
            "location": "/manual/other/#reading-in-atomic-values", 
            "text": "These functions are used to read in the  atomicmasses.csv ,  atom_properties.csv , and  cpk_atom_colors.csv  files from the current  PATH_TO_DATA  directory. They contain information on the masses, radii, and cpk color scheme for atoms.", 
            "title": "Reading in Atomic Values"
        }, 
        {
            "location": "/manual/other/#using-xyz-files", 
            "text": "These functions allow the user to load and save .xyz files describing where molecules appear in a given space. This can be used to save the location of molecules in the middle of a simulation or to visualize what is happening.", 
            "title": "Using .xyz files"
        }, 
        {
            "location": "/manual/other/#path_to_data-control_1", 
            "text": "#  PorousMaterials.set_path_to_data     Function .  set_path_to_data( user/path/to/data )\nset_path_to_data()  Sets PorousMaterials  PATH_TO_DATA  variable which dictates where crystal, forcefield, and molecule files are loaded from. This function allows the user to set  PATH_TO_DATA  manually to any directory or to a \"/data/\" folder within their current directory. This function WILL change the  PATH_TO_DATA  regardless of whether or not the path exists, but will give a warning alerting the user that PorousMaterials cannot load files from the chosen path.  Arguments   new_path_to_data::String : The desired  PATH_TO_DATA  in string form.   source  #  PorousMaterials.set_tutorial_mode     Function .  set_tutorial_mode()  Places PorousMaterials in \"Tutorial Mode\". It changes the  PATH_TO_DATA  variable to the directory where the PorousMaterials test data is stored. It can be used to follow examples shown in the README. It displays a warning so that the user knows They are no longer using their own data.  source", 
            "title": "PATH_TO_DATA Control"
        }, 
        {
            "location": "/manual/other/#reading-in-atomic-values_1", 
            "text": "#  PorousMaterials.read_atomic_radii     Function .  atomic_radii = read_atomic_radii()  Return  atomic_radii::Dict{Symbol, Float64} , where  atom_masses[\":C\"]  gives the atomic radii of carbon (10.87 Angstrom).  Returns   atomic_radii::Dict{Symbol, Float64} : A dictionary linking an element symbol to its' corresponding atomic radius   source  #  PorousMaterials.read_atomic_masses     Function .  atomic_masses = read_atomic_masses()  Read the  data/atomicmasses.csv  file to construct a dictionary of atoms and their atomic masses in amu.  Returns   atomic_masses::Dict{Symbol, Float64} : A dictionary containing the atomic masses of each atom stored in  data/atomicmasses.csv   source  #  PorousMaterials.read_cpk_colors     Function .  atom_colors = read_cpk_colors()  Read in CPK color scheme for atoms. Return  atom_colors::Dict{Symbol, Tuple{Int, Int, Int}}  such that  atom_colors[\":C\"]  gives RGB code for carbon as a tuple,  (144, 144, 144) . https://en.wikipedia.org/wiki/CPK_coloring  Returns   atom_colors::Dict{Symbol, Tuple{Int, Int, Int}} : A dictionary linking an element symbol to its' corresponding CPK color in RGB   source", 
            "title": "Reading in Atomic Values"
        }, 
        {
            "location": "/manual/other/#using-xyz-files_1", 
            "text": "#  PorousMaterials.read_xyz     Function .  atoms, x = read_xyz(filename)  Return the list of  atoms  (Array{Symbol, 1}) and their Cartesian coordinates  x::Array{Float64, 2}  as stored in the .xyz file.  x[:, k]  will return Cartesian coords of the kth atom.  Arguments   filename::AbstractString : The filename of the .xyz file   Returns   atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O] read   from the .xyz file.   x::Array{Float64, 2} : The Cartesian coordinates of the atoms.  x[:, k]  will return cartesian coordinates of the k-th atom   source  #  PorousMaterials.write_xyz     Function .  write_xyz(atoms, x, filename; comment= )\nwrite_xyz(molecules, box, filename; comment= )\nwrite_xyz(framework, filename; comment= , center=false)  Write a molecule, framework, or array of atoms   positions to an .xyz file.  Arguments   atoms::Array{Symbol, 1} : An array of atoms stored as symbols e.g. [:H, :H, :O]  x::Array{Float64, 2} : The Cartesian coordinates of the atoms.   x[:, k]  contains Cartesian coordinates of the k-th atom   molecules::Array{Molecule, 1} : an array of molecules whose atoms to write to .xyz  framework::Framework : a crystal structure whose atoms to write to .xyz  filename::AbstractString : The filename of the .xyz file. (\".xyz\" appended automatically   if the extension is not provided.) (absolute path)   comment::AbstractString : comment if you'd like to write to the file.  center::Bool : shift atoms so that origin is the center of the  framework.box   source  write_xyz(box, molecules, xyz_file)  Writes the coordinates of all atoms in molecules to the given xyz_file file object passing a file object around is faster for simulation because it can be opened once at the beginning of the simulation and closed at the end.  This writes the coordinates of the molecules in cartesian coordinates, so the box is needed for the conversion.  Arguments   box::Box : The box the molecules are in, to convert molecule positions      to cartesian coordinates  molecules::Array{Molecule, 1} : The array of molecules to be written to the file  xyz_file::IOStream : The open 'write' file stream the data will be saved to   source", 
            "title": "Using .xyz files"
        }, 
        {
            "location": "/manual/other/#generic-rotations", 
            "text": "#  PorousMaterials.rotation_matrix     Function .  r = rotation_matrix()  Generate a 3x3 random rotation matrix  r  such that when a point  x  is rotated using this rotation matrix via  r * x , this point  x  is placed at a uniform random distributed position on the surface of a sphere of radius  norm(x) . See James Arvo. Fast Random Rotation Matrices.  https://pdfs.semanticscholar.org/04f3/beeee1ce89b9adf17a6fabde1221a328dbad.pdf  Returns   r::Array{Float64, 2} : A 3x3 random rotation matrix   source  R = rotation_matrix(\u03b8, u, assume_unit_vector=false) # 3 by 3 rotation matrix, angle \u03b8 about vector u\nR = rotation_matrix(\u03b8, dim) # 3 by 3 rotation matrix, angle \u03b8 about axis `dim`  Determine the 3D rotation matrix to rotate an angle \u03b8 (radians) about axis  u .  See  Wikipedia .  Arguments   \u03b8::Float64 : angle to rotate about an axis, in radians  u::Array{Float64, 1} : axis about which to rotate  dim::Int : 1, 2, 3 for rotation about x-, y-, or z-axis, respectively.  assume_unit_vector::Bool : assume  u  is a unit vector; otherwise,  u  will be normalized   internal to this function.  Returns   R::Array{Float64, 2} : 3D rotation matrix. so  R * x  will rotate vector  x  as desired.   source", 
            "title": "Generic Rotations"
        }, 
        {
            "location": "/guides/faq/", 
            "text": "FAQ\n#\n\n\nHow do I type out the math symbols? e.g. \nbox.\u03b1\n?\n\n\nJulia supports \nunicode input\n! Type \nbox.\\alpha\n, then hit tab. Voil\u00e0. There is a vim extension for Julia \nhere\n.\n\n\nHow do I run as a script in the command line?\n\n\nIt is instructive to first run an example in the Julia REPL so you can print out and interact with attributes of your \nforcefield\n, \nframework\n, and \nmolecule\n to ensure they are correct. If you want to then run the Julia code in the command line, simply put the commands in a text file with a \n.jl\n extension and run in terminal as \njulia my_script.jl\n. For parallelization in \nadsorption_isotherm\n and \nhenry_coefficient\n, call e.g. 4 cores with \njulia -p 4 my_script.jl\n.\n\n\nCan I use \nPorousMaterials.jl\n in Jupyter Notebook/ Jupyter Lab?\n\n\nYes! See \nhere\n.\n\n\nHow can I convert my \n.cif\n into P1 symmetry for \nPorousMaterials.jl\n?\n\n\nWe hope someone will contribute this feature to \nPorousMaterials.jl\n eventually. For now, you can use \nOpenBabel\n:\n\n\nobabel -icif non-P1.cif -ocif -O P1.cif --fillUC strict", 
            "title": "FAQ"
        }, 
        {
            "location": "/guides/faq/#faq", 
            "text": "How do I type out the math symbols? e.g.  box.\u03b1 ?  Julia supports  unicode input ! Type  box.\\alpha , then hit tab. Voil\u00e0. There is a vim extension for Julia  here .  How do I run as a script in the command line?  It is instructive to first run an example in the Julia REPL so you can print out and interact with attributes of your  forcefield ,  framework , and  molecule  to ensure they are correct. If you want to then run the Julia code in the command line, simply put the commands in a text file with a  .jl  extension and run in terminal as  julia my_script.jl . For parallelization in  adsorption_isotherm  and  henry_coefficient , call e.g. 4 cores with  julia -p 4 my_script.jl .  Can I use  PorousMaterials.jl  in Jupyter Notebook/ Jupyter Lab?  Yes! See  here .  How can I convert my  .cif  into P1 symmetry for  PorousMaterials.jl ?  We hope someone will contribute this feature to  PorousMaterials.jl  eventually. For now, you can use  OpenBabel :  obabel -icif non-P1.cif -ocif -O P1.cif --fillUC strict", 
            "title": "FAQ"
        }, 
        {
            "location": "/guides/help_wanted/", 
            "text": "Help wanted and needed\n#\n\n\n\n\n\n\nthe speed of a GCMC or Henry simulation is determined primarily by how fast \nPorousMaterials.jl\n can compute the electrostatic and vdw potential energy. Some core functions that can speed up this are:\n\n\n\n\nnearest_image!\n in \nsrc/NearestImage.jl\n\n\nEwald sums in \nsrc/Electrostatics.jl\n. (electrostatics are a huge bottleneck.)\n\n\nsrc/VdWEnergetics.jl\n\n\nThe scripts \ntest/vdw_timing.jl\n and \ntest/ewald_timing.jl\n time the functions for benchmarking.\n\n\n\n\n\n\n\n\nconsolidate \neikar\n, \neikbr\n, \neikcr\n somehow without slowing down the Ewald sum.\n\n\n\n\nmore tests added to \ntests/runtests.jl\n, \ntests/henry_tests.jl\n, \ntests/gcmc_tests.jl\n\n\ngeometric-based pore size calculations (largest free and included spheres), surface area, and porosity calculations that take \nFramework\n's as input\n\n\nhandle .cif's without P1 symmetry. i.e. convert any .cif to P1 symmetry\n\n\nextend \ngcmc_simulation\n to handle mixtures\n\n\nbetter default rules for choosing Ewald sum parameters? alpha, kvectors required...\n\n\nHenry coefficient code prints off Ewald sum params 5 times if run with one core...\n\n\nset good defaults for \ngcmc_simulation\n probabilities (as now) but also allow user to change through default arguments to the function\n\n\nautomatically adjust the translation step \n\u03b4\n in \ngcmc_simulation\n during burn cycles to have 50% acceptance of translation moves (online gradient descent?)\n\n\nEQEq or other charge equilibration schemes for assinging charges, taking a \nFramework\n as input.", 
            "title": "Help Wanted"
        }, 
        {
            "location": "/guides/help_wanted/#help-wanted-and-needed", 
            "text": "the speed of a GCMC or Henry simulation is determined primarily by how fast  PorousMaterials.jl  can compute the electrostatic and vdw potential energy. Some core functions that can speed up this are:   nearest_image!  in  src/NearestImage.jl  Ewald sums in  src/Electrostatics.jl . (electrostatics are a huge bottleneck.)  src/VdWEnergetics.jl  The scripts  test/vdw_timing.jl  and  test/ewald_timing.jl  time the functions for benchmarking.     consolidate  eikar ,  eikbr ,  eikcr  somehow without slowing down the Ewald sum.   more tests added to  tests/runtests.jl ,  tests/henry_tests.jl ,  tests/gcmc_tests.jl  geometric-based pore size calculations (largest free and included spheres), surface area, and porosity calculations that take  Framework 's as input  handle .cif's without P1 symmetry. i.e. convert any .cif to P1 symmetry  extend  gcmc_simulation  to handle mixtures  better default rules for choosing Ewald sum parameters? alpha, kvectors required...  Henry coefficient code prints off Ewald sum params 5 times if run with one core...  set good defaults for  gcmc_simulation  probabilities (as now) but also allow user to change through default arguments to the function  automatically adjust the translation step  \u03b4  in  gcmc_simulation  during burn cycles to have 50% acceptance of translation moves (online gradient descent?)  EQEq or other charge equilibration schemes for assinging charges, taking a  Framework  as input.", 
            "title": "Help wanted and needed"
        }
    ]
}